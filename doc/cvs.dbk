<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                    "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
<!ENTITY dollar "$">
<!ENTITY hellip "...">
<!ENTITY version SYSTEM "version.inc">
]>

<book lang="en">
<bookinfo>
  <title>cvsnt--Concurrent Versions System &version;</title>
  <abstract>
  <para>
This info manual describes how to use and administer
cvsnt version &version;.
  </para>
  </abstract>
</bookinfo>
 <chapter id="Overview">
  <title>Overview
</title>
  <para><indexterm role="cp"><primary>Overview</primary></indexterm>
This chapter is for people who have never used
cvsnt, and perhaps have never used version control
software before.
  </para>

  <para>
If you are already familiar with cvsnt and are just
trying to learn a particular feature or remember a
certain command, you can probably skip everything here.
  </para>

  <sect1 id="What-is-CVS-">
   <title>What is CVS?
</title>
   <para><indexterm role="cp"><primary>What is CVS?</primary></indexterm><indexterm role="cp"><primary>Introduction to CVS</primary></indexterm><indexterm role="cp"><primary>CVS, introduction to</primary></indexterm>
cvsnt is a version control system.  Using it, you can
record the history of your source files.
   </para>


   <para>
For example, bugs sometimes creep in when
software is modified, and you might not detect the bug
until a long time after you make the modification.
With cvsnt, you can easily retrieve old versions to see
exactly which change caused the bug.  This can
sometimes be a big help.
   </para>

   <para>
You could of course save every version of every file
you have ever created.  This would
however waste an enormous amount of disk space.  cvsnt
stores all the versions of a file in a single file in a
clever way that only stores the differences between
versions.
   </para>

   <para>
cvsnt also helps you if you are part of a group of people working
on the same project.  It is all too easy to overwrite
each others' changes unless you are extremely careful.
Some editors, like gnu Emacs, try to make sure that
the same file is never modified by two people at the
same time.  Unfortunately, if someone is using another
editor, that safeguard will not work.  cvsnt solves this problem
by insulating the different developers from each other.  Every
developer works in his own directory, and cvsnt merges
the work when each developer is done.
   </para>

   <para><indexterm role="cp"><primary>History of cvsnt</primary></indexterm><indexterm role="cp"><primary>cvsnt, history of</primary></indexterm><indexterm role="cp"><primary>Credits (cvsnt program)</primary></indexterm><indexterm role="cp"><primary>Contributors (cvsnt program)</primary></indexterm>cvsnt started out as a bunch of shell scripts written by
Dick Grune, posted to the newsgroup
<command>comp.sources.unix</command> in the volume 6
release of December, 1986.  While no actual code from
these shell scripts is present in the current version
of cvsnt much of the cvsnt conflict resolution algorithms
come from them.
   </para>

   <para>
In April, 1989, Brian Berliner designed and coded cvs.
Jeff Polk later helped Brian with the design of the cvs
module and vendor branch support.
   </para>

   <para>
In December, 1999 Tony Hoyle converted the unix based CVS to run
under Windows NT.  This later became cvsnt, which developed into
a project of its own.
   </para>

   <para><indexterm role="cp"><primary>Source, getting cvsnt source</primary></indexterm>You can get cvsnt in a variety of ways, including
free download from the internet.  For more information
on downloading cvsnt and other cvsnt topics, see:
   </para>

   <para><screen>http://www.cvsnt.org/
</screen>   </para>
   <para><indexterm role="cp"><primary>Mailing list</primary></indexterm><indexterm role="cp"><primary>List, mailing list</primary></indexterm><indexterm role="cp"><primary>Newsgroups</primary></indexterm>There is a mailing list, known as <command>cvsnt</command>,
devoted to cvsnt.  To subscribe or
unsubscribe
see:
<screen>
http://www.cvsnt.org/mailman/listinfo/cvsnt
news://news.cvsnt.org/support.cvsnt
</screen>  
   </para>
</sect1>
  <sect1 id="What-is-CVS-not-">
   <title>What is CVS not?
</title>
   <para><indexterm role="cp"><primary>What is CVS not?</primary></indexterm>
cvsnt can do a lot of things for you, but it does
not try to be everything for everyone.
   </para>

   <variablelist>
    <varlistentry>
     <term>cvsnt is not a build system.</term>
     <listitem>

      <para>
Though the structure of your repository and modules
file interact with your build system
(e.g. <command>Makefile</command>s), they are essentially
independent.
      </para>

      <para>
cvsnt does not dictate how you build anything.  It
merely stores files for retrieval in a tree structure
you devise.
      </para>

      <para>
cvsnt does not dictate how to use disk space in the
checked out working directories.  If you write your
<command>Makefile</command>s or scripts in every directory so they
have to know the relative positions of everything else,
you wind up requiring the entire repository to be
checked out.
      </para>

      <para>
If you modularize your work, and construct a build
system that will share files (via links, mounts,
<command>VPATH</command> in <command>Makefile</command>s, etc.), you can
arrange your disk usage however you like.
      </para>

      <para>
But you have to remember that <emphasis>any</emphasis> such system is
a lot of work to construct and maintain.  cvsnt does
not address the issues involved.
      </para>

      <para>
Of course, you should place the tools created to
support such a build system (scripts, <command>Makefile</command>s,
etc) under cvsnt.
      </para>

      <para>
Figuring out what files need to be rebuilt when
something changes is, again, something to be handled
outside the scope of cvsnt.  One traditional
approach is to use <command>make</command> for building, and use
some automated tool for generating the dependencies which
<command>make</command> uses.
      </para>

      <para>
See <xref linkend="Builds" />, for more information on doing builds
in conjunction with cvsnt.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>cvsnt is not a substitute for management.</term>
     <listitem>

      <para>
Your managers and project leaders are expected to talk
to you frequently enough to make certain you are aware
of schedules, merge points, branch names and release
dates.  If they don't, cvsnt can't help.
      </para>

      <para>
cvsnt is an instrument for making sources dance to
your tune.  But you are the piper and the composer.  No
instrument plays itself or writes its own music.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>cvsnt is not a substitute for developer communication.</term>
     <listitem>

      <para>
When faced with conflicts within a single file, most
developers manage to resolve them without too much
effort.  But a more general definition of "conflict"
includes problems too difficult to solve without
communication between developers.
      </para>

      <para>
cvsnt cannot determine when simultaneous changes
within a single file, or across a whole collection of
files, will logically conflict with one another.  Its
concept of a <firstterm>conflict</firstterm> is purely textual, arising
when two changes to the same base file are near enough
to spook the merge (i.e. <command>diff3</command>) command.
      </para>

      <para>
cvsnt does not claim to help at all in figuring out
non-textual or distributed conflicts in program logic.
      </para>

      <para>
For example: Say you change the arguments to function
<command>X</command> defined in file <command>A</command>.  At the same time,
someone edits file <command>B</command>, adding new calls to
function <command>X</command> using the old arguments.  You are
outside the realm of cvsnt's competence.
      </para>

      <para>
Acquire the habit of reading specs and talking to your
peers.
      </para>

</listitem></varlistentry>
    <varlistentry>
     <term>cvsnt does not have change control</term>
     <listitem>

      <para>
Change control refers to a number of things.  First of
all it can mean <firstterm>bug-tracking</firstterm>, that is being able
to keep a database of reported bugs and the status of
each one (is it fixed?  in what release?  has the bug
submitter agreed that it is fixed?).  For interfacing
cvsnt to an external bug-tracking system, see the
<command>rcsinfo</command> and <command>verifymsg</command> files
(<xref linkend="Administrative-files" />).
      </para>

      <para>
Another aspect of change control is keeping track of
the fact that changes to several files were in fact
changed together as one logical change.  If you check
in several files in a single <command>cvs commit</command>
operation, cvsnt then forgets that those files were
checked in together, and the fact that they have the
same log message is the only thing tying them
together.  Keeping a gnu style <command>ChangeLog</command>
can help somewhat.
      </para>

      <para>
Another aspect of change control, in some systems, is
the ability to keep track of the status of each
change.  Some changes have been written by a developer,
others have been reviewed by a second developer, and so
on.  Generally, the way to do this with cvsnt is to
generate a diff (using <command>cvs diff</command> or <command>diff</command>)
and email it to someone who can then apply it using the
<command>patch</command> utility.  This is very flexible, but
depends on mechanisms outside cvsnt to make sure
nothing falls through the cracks.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>cvsnt is not an automated testing program</term>
     <listitem>

      <para>
It should be possible to enforce mandatory use of a
testsuite using the <command>commitinfo</command> file.  I haven't
heard a lot about projects trying to do that or whether
there are subtle gotchas, however.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>cvsnt does not have a builtin process model</term>
     <listitem>

      <para>
Some systems provide ways to ensure that changes or
releases go through various steps, with various
approvals as needed.  Generally, one can accomplish
this with cvsnt but it might be a little more work.
In some cases you'll want to use the <command>commitinfo</command>,
<command>loginfo</command>, <command>rcsinfo</command>, or <command>verifymsg</command>
files, to require that certain steps be performed
before cvs will allow a checkin.  Also consider whether
features such as branches and tags can be used to
perform tasks such as doing work in a development tree
and then merging certain changes over to a stable tree
only once they have been proven.
      </para></listitem></varlistentry></variablelist>
</sect1>
  <sect1 id="A-sample-session">
   <title>A sample session
</title>
   <para><indexterm role="cp"><primary>Example of a work-session</primary></indexterm><indexterm role="cp"><primary>Getting started</primary></indexterm><indexterm role="cp"><primary>Work-session, example of</primary></indexterm><indexterm role="cp"><primary>tc, Trivial Compiler (example)</primary></indexterm><indexterm role="cp"><primary>Trivial Compiler (example)</primary></indexterm>
   </para>

   <para>
As a way of introducing cvsnt, we'll go through a
typical work-session using cvsnt.  The first thing
to understand is that cvsnt stores all files in a
centralized <firstterm>repository</firstterm> (<xref linkend="Repository" />); this
section assumes that a repository is set up.
   </para>

   <para>
Suppose you are working on a simple compiler.  The source
consists of a handful of C files and a <command>Makefile</command>.
The compiler is called <command>tc</command> (Trivial Compiler),
and the repository is set up so that there is a module
called <command>tc</command>.
   </para>

   <sect2 id="Getting-the-source">
    <title>Getting the source
</title>
    <para><indexterm role="cp"><primary>Getting the source</primary></indexterm><indexterm role="cp"><primary>Checking out source</primary></indexterm><indexterm role="cp"><primary>Fetching source</primary></indexterm><indexterm role="cp"><primary>Source, getting from CVS</primary></indexterm><indexterm role="cp"><primary>Checkout, example</primary></indexterm>
The first thing you must do is to get your own working copy of the
source for <command>tc</command>.  For this, you use the <command>checkout</command> command:
    </para>

    <para><screen>$ cvs checkout tc
</screen>    </para>

    <para>
This will create a new directory called <command>tc</command> and populate it with
the source files (the commands used may be slightly different on Windows machines, but the
output is the same).
    </para>

    <para><screen>
$ cd tc
$ ls
CVS         Makefile    backend.c   driver.c    frontend.c  parser.c
</screen>    </para>
    <para>
The <command>CVS</command> directory is used internally by
cvsnt (on Windows clients it is normally hidden).  Normally, you should not modify or remove
any of the files in it.
    </para>
    <para>
You start your favorite editor, hack away at <command>backend.c</command>, and a couple
of hours later you have added an optimization pass to the compiler.
A note to rcs and sccs users: There is no need to lock the files that
you want to edit.  <xref linkend="Multiple-developers" />, for an explanation.
    </para>
</sect2>
   <sect2 id="Committing-your-changes">
    <title>Committing your changes
</title>
    <para><indexterm role="cp"><primary>Committing changes</primary></indexterm><indexterm role="cp"><primary>Log message entry</primary></indexterm><indexterm role="cp"><primary>CVSEDITOR, environment variable</primary></indexterm><indexterm role="cp"><primary>EDITOR, environment variable</primary></indexterm>
When you have checked that the compiler is still compilable you decide
to make a new version of <command>backend.c</command>.  This will
store your new <command>backend.c</command> in the repository and
make it available to anyone else who is using that same
repository.
    </para>

    <para><screen>$ cvs commit backend.c
</screen>    </para>

    <para>
cvsnt starts an editor, to allow you to enter a log
message.  You type in "Added an optimization pass.",
save the temporary file, and exit the editor.
    </para>

    <para>
The environment variable <command>$CVSEDITOR</command> determines
which editor is started.  If <command>$CVSEDITOR</command> is not
set, then if the environment variable <command>$EDITOR</command> is
set, it will be used. If both <command>$CVSEDITOR</command> and
<command>$EDITOR</command> are not set then there is a default
which will vary with your operating system, for example
<command>vi</command> for unix or <command>notepad</command> for Windows
NT/95.
    </para>

    <para>
When cvsnt starts the editor, it includes a list of
files which are modified.  For the cvsnt client,
this list is based on comparing the modification time
of the file against the modification time that the file
had when it was last gotten or updated.  Therefore, if
a file's modification time has changed but its contents
have not, it will show up as modified.  The simplest
way to handle this is simply not to worry about it--if
you proceed with the commit cvsnt will detect that
the contents are not modified and treat it as an
unmodified file.  The next <command>update</command> will clue
cvsnt in to the fact that the file is unmodified,
and it will reset its stored timestamp so that the file
will not show up in future editor sessions.
    </para>

    <para>
If you want to avoid
starting an editor you can specify the log message on
the command line using the <command>-m</command> flag instead, like
this:
    </para>

    <para><screen>
$ cvs commit -m "Added an optimization pass" backend.c
</screen>    </para>
</sect2>
   <sect2 id="Cleaning-up">
    <title>Cleaning up
</title>
    <para><indexterm role="cp"><primary>Cleaning up</primary></indexterm><indexterm role="cp"><primary>Working copy, removing</primary></indexterm><indexterm role="cp"><primary>Removing your working copy</primary></indexterm><indexterm role="cp"><primary>Releasing your working copy</primary></indexterm>
Before you turn to other tasks you decide to remove your working copy of
tc.  One acceptable way to do that is of course
    </para>

    <para><screen>$ cd ..
$ rm -r tc
</screen>    </para>

    <para>
but a better way is to use the <command>release</command> command (<xref linkend="release" />):
    </para>

    <para><screen>
$ cd ..
$ cvs release -d tc
M driver.c
? tc
You have [1] altered files in this repository.
Are you sure you want to release (and delete) directory `tc': n
** `release' aborted by user choice.
</screen>    </para>
    <para>
The <command>release</command> command checks that all your modifications have been
committed.  If history logging is enabled it also makes a note in the
history file.  <xref linkend="history-file" />.
    </para>
    <para>
When you use the <command>-d</command> flag with <command>release</command>, it
also removes your working copy.  The <command>-f</command> tells cvsnt to also delete unknown
files (such as object files).
    </para>
    <para>
The <command>release</command> command always finishes by telling
you how many modified files you have in your working
copy of the sources, and then asks you for confirmation
before deleting any files or making any note in the
history file.
    </para>
    <para>
You can decide to play it safe and answer <userinput>n <keycap>RET</keycap></userinput>
when <command>release</command> asks for confirmation.
    </para>
</sect2>
   <sect2 id="Viewing-differences">
    <title>Viewing differences
</title>
    <para><indexterm role="cp"><primary>Viewing differences</primary></indexterm><indexterm role="cp"><primary>Diff</primary></indexterm>
You do not remember modifying <command>driver.c</command>, so you want to see what
has happened to that file.
    </para>

    <para><screen>$ cd tc
$ cvs diff driver.c
</screen>    </para>
    <para>
This command runs <command>diff</command> to compare the version of <command>driver.c</command>
that you checked out with your working copy.  When you see the output
you remember that you added a command line option that enabled the
optimization pass.  You check it in, and release the module.
    </para>
    <para><screen>
$ cvs commit -m "Added an optimization pass" driver.c
Checking in driver.c;
/usr/local/cvsroot/tc/driver.c,v  &lt;--  driver.c
new revision: 1.2; previous revision: 1.1
done
$ cd ..
$ cvs release -d tc
? tc
You have [0] altered files in this repository.
Are you sure you want to release (and delete) directory `tc': y
</screen>
    </para></sect2></sect1></chapter>
 <chapter id="Repository">
  <title>The Repository
</title>
  <para><indexterm role="cp"><primary>Repository (intro)</primary></indexterm><indexterm role="cp"><primary>Repository, example</primary></indexterm><indexterm role="cp"><primary>Layout of repository</primary></indexterm><indexterm role="cp"><primary>Typical repository</primary></indexterm><indexterm role="cp"><primary>/usr/local/cvsroot, as example repository</primary></indexterm><indexterm role="cp"><primary>cvsroot</primary></indexterm>
The cvsnt <firstterm>repository</firstterm> stores a complete copy of
all the files and directories which are under version
control.
  </para>

  <para>
Normally, you never access any of the files in the
repository directly.  Instead, you use cvsnt
commands to get your own copy of the files into a
<firstterm>working directory</firstterm>, and then
work on that copy.  When you've finished a set of
changes, you check (or <firstterm>commit</firstterm>) them back into the
repository.  The repository then contains the changes
which you have made, as well as recording exactly what
you changed, when you changed it, and other such
information.  Note that the repository is not a
subdirectory of the working directory, or vice versa;
they should be in separate locations.
  </para>

  <para><indexterm role="cp"><primary>:local:, setting up</primary></indexterm>cvsnt can access a repository by a variety of
means.  It might be on the local computer, or it might
be on a computer across the room or across the world.
To distinguish various ways to access a repository, the
repository name can start with an <firstterm>access method</firstterm>.
For example, the access method <command>:local:</command> means to
access a repository directory, so the repository
<command>:local:/usr/local/cvsroot</command> means that the
repository is in <command>/usr/local/cvsroot</command> on the
computer running cvsnt.  For information on other
access methods, see <xref linkend="Remote-repositories" />.
  </para>

  <para>
If the access method is omitted, then if the repository
does not contain <command>@</command>, then <command>:local:</command> is
assumed.  If it does contain <command>@</command> then 
<command>:ext:</command> is assumed.  For
example, if you have a local repository in
<command>/usr/local/cvsroot</command>, you can use
<command>/usr/local/cvsroot</command> instead of
<command>:local:/usr/local/cvsroot</command>.  
  </para>

  <para>
The repository is split in two parts.  <command>$CVSROOT/CVSROOT</command> contains
administrative files for cvsnt.  The other directories contain the actual
user-defined modules.
  </para>

  <sect1 id="Specifying-a-repository">
   <title>Telling CVS where your repository is
</title>

   <para>
There are several ways to tell cvsnt
where to find the repository.  You can name the
repository on the command line explicitly, with the
<command>-d</command> (for "directory") option:
   </para>

   <para><screen>cvs -d /usr/local/cvsroot checkout yoyodyne/tc
</screen>   </para>
   <para><indexterm role="cp"><primary>.profile, setting CVSROOT in</primary></indexterm><indexterm role="cp"><primary>.cshrc, setting CVSROOT in</primary></indexterm><indexterm role="cp"><primary>.tcshrc, setting CVSROOT in</primary></indexterm><indexterm role="cp"><primary>.bashrc, setting CVSROOT in</primary></indexterm><indexterm role="cp"><primary>CVSROOT, environment variable</primary></indexterm>        Or you can set the <command>$CVSROOT</command> environment
variable to an absolute path to the root of the
repository, <command>/usr/local/cvsroot</command> in this example.
To set <command>$CVSROOT</command>, <command>csh</command> and <command>tcsh</command>
users should have this line in their <command>.cshrc</command> or
<command>.tcshrc</command> files:
   </para>
   <para><screen>
setenv CVSROOT /usr/local/cvsroot
</screen>      </para>

   <para><command>sh</command> and <command>bash</command> users should instead have these lines in their
<command>.profile</command> or <command>.bashrc</command>:
   </para>

   <para><screen>
CVSROOT=/usr/local/cvsroot
export CVSROOT
</screen>   </para>
<para>
It is common for cvs frontends to set this up automatically.  On most frontends
there will be a dialog box which prompts you for the CVSROOT when it is first configured.
</para>
   <para><indexterm role="cp"><primary>Root file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Root file</primary></indexterm>        A repository specified with <command>-d</command> will
override the <command>$CVSROOT</command> environment variable.
Once you've checked a working copy out from the
repository, it will remember where its repository is
(the information is recorded in the
<command>CVS/Root</command> file in the working copy).
   </para>
   <para>
The <command>-d</command> option and the <command>CVS/Root</command> file both
override the <command>$CVSROOT</command> environment variable.  If
<command>-d</command> option differs from <command>CVS/Root</command>, the
former is used.  Of course, for proper operation they
should be two ways of referring to the same repository.
   </para>
</sect1>
  <sect1 id="Repository-storage">
   <title>How data is stored in the repository
</title>
   <para><indexterm role="cp"><primary>Repository, how data is stored</primary></indexterm>
For most purposes it isn't important <emphasis>how</emphasis>
cvsnt stores information in the repository.  In
fact, the format has changed in the past, and is likely
to change in the future.  Since in almost all cases one
accesses the repository via cvsnt commands, such
changes need not be disruptive.
   </para>

   <para>
However, in some cases it may be necessary to
understand how cvsnt stores data in the repository,
for example you might need to track down cvsnt locks
(<xref linkend="Concurrency" />) or you might need to deal with
the file permissions appropriate for the repository.
   </para>

   <sect2 id="Repository-files">
    <title>Where files are stored within the repository
</title>


    <para>
The overall structure of the repository is a directory
tree corresponding to the directories in the working
directory.  For example, supposing the repository is in
    </para>

    <para><screen>/usr/local/cvsroot
</screen>    </para>

    <para>
here is a possible directory tree (showing only the
directories):
    </para>

    <para><screen>
<wordasword>/usr</wordasword>
 |
 +--<wordasword>local</wordasword>
 |   |
 |   +--<wordasword>cvsroot</wordasword>
 |   |    |
 |   |    +--<wordasword>CVSROOT</wordasword>
          |      (administrative files)
          |
          +--<wordasword>gnu</wordasword>
          |   |
          |   +--<wordasword>diff</wordasword>
          |   |   (source code to gnu diff)
          |   |
          |   +--<wordasword>rcs</wordasword>
          |   |   (source code to rcs)
          |   |
          |   +--<wordasword>cvsnt</wordasword>
          |       (source code to cvsnt)
          |
          +--<wordasword>yoyodyne</wordasword>
              |
              +--<wordasword>tc</wordasword>
              |    |
              |    +--<wordasword>man</wordasword>
              |    |
              |    +--<wordasword>testing</wordasword>
              |
              +--(other Yoyodyne software)
</screen>    </para>
    <para>
With the directories are <firstterm>history files</firstterm> for each file
under version control.  The name of the history file is
the name of the corresponding file with <command>,v</command>
appended to the end.  Here is what the repository for
the <command>yoyodyne/tc</command> directory might look like:
<screen>
  <command>$CVSROOT</command>
    |
    +--<wordasword>yoyodyne</wordasword>
    |   |
    |   +--<wordasword>tc</wordasword>
    |   |   |
            +--<wordasword>Makefile,v</wordasword>
            +--<wordasword>backend.c,v</wordasword>
            +--<wordasword>driver.c,v</wordasword>
            +--<wordasword>frontend.c,v</wordasword>
            +--<wordasword>parser.c,v</wordasword>
            +--<wordasword>man</wordasword>
            |    |
            |    +--<wordasword>tc.1,v</wordasword>
            |
            +--<wordasword>testing</wordasword>
                 |
                 +--<wordasword>testpgm.t,v</wordasword>
                 +--<wordasword>test2.t,v</wordasword>
</screen>       </para>
    <para><indexterm role="cp"><primary>History files</primary></indexterm><indexterm role="cp"><primary>rcs history files</primary></indexterm>The history files contain, among other things, enough
information to recreate any revision of the file, a log
of all commit messages and the user-name of the person
who committed the revision.  The history files are
known as <firstterm>rcs files</firstterm>, because the first program to
store files in that format was a version control system
known as rcs.  For a full
description of the file format, see the <command>man</command> page
<citation>rcsfile(5)</citation>, distributed with rcs, or the
file <command>doc/rcsFILES</command> in the cvsnt source
distribution.  This
file format has become very common--many systems other
than cvsnt or rcs can at least import history
files in this format.
    </para>
    <para>
The rcs files used in cvsnt differ in a few
ways from the standard format.  The biggest difference
is magic branches; for more information see <xref linkend="Magic-branch-numbers" />.  Also in cvsnt the valid tag names
are a subset of what rcs accepts; for cvsnt's
rules see <xref linkend="Tags" />.  Future versions of cvsnt may introduce further changes,
so it is unwise to try to read (or write to) the repository with rcs.  cvsnt provides some rcs 'lookalike'
comands for accessing the repository files.
    </para>
</sect2>
   <sect2 id="File-permissions">
    <title>File permissions
</title>
    <para><indexterm role="cp"><primary>Security, file permissions in repository</primary></indexterm><indexterm role="cp"><primary>File permissions, general</primary></indexterm><indexterm role="cp"><primary>Permissions, general</primary></indexterm><indexterm role="cp"><primary>Group</primary></indexterm><indexterm role="cp"><primary>Read-only files, in repository</primary></indexterm>All <command>,v</command> files are created read-only, and you
should not change the permission of those files.  The
directories inside the repository should be writable by
the persons that have permission to modify the files in
each directory.  On Unix, this normally means that you must
create a group (see group(5)) consisting of the
persons that are to edit the files in a project, and
set up the repository so that it is that group that
owns the directory.  On Windows, you must allow write access
to the files for each user or group that is accessing the
repository.  If impersonation is not enabled, then the
repository is always accessed as SYSTEM.
    </para>

    <para>
This means that you can only control access to files on
a per-directory basis.
    </para>

    <para>
Note that users must also have write access to check
out files, because cvsnt needs to create lock files
(<xref linkend="Concurrency" />).
    </para>

    <para>
Also note that users must have write access to the
<command>CVSROOT/val-tags</command> file.  cvsnt uses it to keep
track of what tags are valid tag names (it is sometimes
updated when tags are used, as well as when they are
created).
    </para>

    <para>
Normally each rcs file will be owned by the user who last
checked it in.  This has little significance; what
really matters is who owns the directories.  See also <xref linkend="Runas-User" />.
    </para>

    <para><indexterm role="cp"><primary>CVSUMASK, environment variable (Unix only)</primary></indexterm><indexterm role="cp"><primary>Umask, for repository files (Unix only)</primary></indexterm>cvsnt tries to set up reasonable file permissions
for new directories that are added inside the tree, but
you must fix the permissions manually when a new
directory should have different permissions than its
parent directory.  If you set the <command>CVSUMASK</command>
environment variable that will control the file
permissions which cvsnt uses in creating directories
and/or files in the repository.  <command>CVSUMASK</command> does
not affect the file permissions in the working
directory; such files have the permissions which are
typical for newly created files, except that sometimes
cvsnt creates them read-only (see the sections on
watches, <xref linkend="Setting-a-watch" />; -r, <xref linkend="Global-options" />; or <command>CVSREAD</command>, <xref linkend="Environment-variables" />).
    </para>

    <para>
Note that using the client/server cvsnt
(<xref linkend="Remote-repositories" />), there is no good way to
set <command>CVSUMASK</command>; the setting on the client machine
has no effect.  If you are connecting with <command>ssh</command>, you
can set <command>CVSUMASK</command> in <command>.bashrc</command> or <command>.cshrc</command>, as
described in the documentation for your operating
system.  This behavior might change in future versions
of cvsnt; do not rely on the setting of
<command>CVSUMASK</command> on the client having no effect.
    </para>
    <para>
    Under Windows NT, because of the way directory permissions work on that platform,
    setting CVSUMASK will have no effect.
    </para>

    <para>
Using remote repositories, you will generally need stricter
permissions on the cvsroot directory and
directories above it in the tree; see <xref linkend="Authentication-security" />.
    </para>

    <para><indexterm role="cp"><primary>Setuid (Unix only)</primary></indexterm><indexterm role="cp"><primary>Setgid (Unix only)</primary></indexterm><indexterm role="cp"><primary>Security, setuid (Unix only)</primary></indexterm>Some operating systems have features which allow a
particular program to run with the ability to perform
operations which the caller of the program could not.
For example, the set user ID (setuid) or set group ID
(setgid) features of unix or the installed image
feature of VMS.  cvsnt was not written to use such
features and therefore attempting to install cvsnt in
this fashion will provide protection against only
accidental lapses; anyone who is trying to circumvent
the measure will be able to do so, and depending on how
you have set it up may gain access to more than just
cvsnt.  You may wish to instead consider pserver or sserver.
They shares some of the same attributes, in terms of
possibly providing a false sense of security or opening
security holes wider than the ones you are trying to
fix, so read the documentation on pserver security
carefully if you are considering this option
(<xref linkend="Authentication-security" />).
    </para>

</sect2>
   <sect2 id="Attic">
    <title>The attic
</title>
    <para><indexterm role="cp"><primary>Attic</primary></indexterm>
    The attic was used in older versions of cvs to store files in the
    branches.  Its use has been depreciated since cvsnt 2.0.15, and cvsnt no
    longer stores files in the <command>Attic</command>.  It will, however, read files that have
    been stored in the <command>Attic</command> by previous versions of cvs.
    </para>
    <para><indexterm role="cp"><primary>Dead state</primary></indexterm>instead.  It should not matter from a user point of
view whether a file is in the attic; cvsnt keeps
track of this and looks in the attic when it needs to.
But in case you want to know, the rule was that the rcs
file is stored in the attic if and only if the head
revision on the trunk has state <command>dead</command>.  A
<command>dead</command> state means that file has been removed, or
never added, for that revision.  For example, if you
add a file on a branch, it will have a trunk revision
in <command>dead</command> state, and a branch revision in a
non-<command>dead</command> state.
    </para>
</sect2>
   <sect2 id="CVS-in-repository">
    <title>The CVS directory in the repository
</title>
    <para><indexterm role="cp"><primary>CVS directory, in repository</primary></indexterm>
The <command>CVS</command> directory in each repository directory
contains information such as file attributes (in a file
called <command>CVS/fileattr</command>.  In the
future additional files may be added to this directory,
so implementations should silently ignore additional
files.
    </para>

    <para>
This behavior is implemented only by cvsnt 1.7 and
later; for details see <xref linkend="Watches-Compatibility" />.
    </para>

    <para>
The format of the fileattr file is a series of entries
of the following form (where <command>{</command> and <command>}</command>
means the text between the braces can be repeated zero
or more times):
    </para>

    <para><varname>ent-type</varname> <varname>filename</varname> &lt;tab&gt; <varname>attrname</varname> = <varname>attrval</varname>
  {; <varname>attrname</varname> = <varname>attrval</varname>} &lt;linefeed&gt;
    </para>

    <para><varname>ent-type</varname> is <command>F</command> for a file, in which case the entry specifies the
attributes for that file.
    </para>

    <para><varname>ent-type</varname> is <command>D</command>,
and <varname>filename</varname> empty, to specify default attributes
to be used for newly added files.
    </para>

    <para>
Other <varname>ent-type</varname> are reserved for future expansion.  cvsnt 1.9 and older
will delete them any time it writes file attributes.
CVS 1.10 and later will preserve them.
    </para>

    <para>
Note that the order of the lines is not significant;
a program writing the fileattr file may
rearrange them at its convenience.
    </para>

    <para>
There is currently no way of quoting tabs or linefeeds in the
filename, <command>=</command> in <varname>attrname</varname>,
<command>;</command> in <varname>attrval</varname>, etc.  Note: some implementations also
don't handle a NUL character in any of the fields, but
implementations are encouraged to allow it.
    </para>

    <para>
By convention, <varname>attrname</varname> starting with <command>_</command> is for an attribute given
special meaning by cvsnt; other <varname>attrname</varname>s are for user-defined attributes
(or will be, once implementations start supporting user-defined attributes).
    </para>

    <para>
Builtin attributes:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>_watched</command></term>
      <listitem>
       <para>
Present means the file is watched and should be checked out
read-only.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>_watchers</command></term>
      <listitem>
       <para>
Users with watches for this file.  Value is
<varname>watcher</varname> &gt; <varname>type</varname> { , <varname>watcher</varname> &gt; <varname>type</varname> }
where <varname>watcher</varname> is a username, and <varname>type</varname>
is zero or more of edit,unedit,commit separated by
<command>+</command> (that is, nothing if none; there is no "none" or "all" keyword).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>_editors</command></term>
      <listitem>
       <para>
Users editing this file.  Value is
<varname>editor</varname> &gt; <varname>val</varname> { , <varname>editor</varname> &gt; <varname>val</varname> }
where <varname>editor</varname> is a username, and <varname>val</varname> is
<varname>time</varname>+<varname>hostname</varname>+<varname>pathname</varname>, where
<varname>time</varname> is when the <command>cvs edit</command> command (or
equivalent) happened,
and <varname>hostname</varname> and <varname>pathname</varname> are for the working directory.
       </para></listitem></varlistentry></variablelist>
    <para>
Example:
    </para>
    <para><screen>
Ffile1 _watched=;_watchers=joe&gt;edit,mary&gt;commit
Ffile2 _watched=;_editors=sue&gt;8 Jan 1975+workstn1+/home/sue/cvs
D _watched=
</screen>       </para>
    <para>
means that the file <command>file1</command> should be checked out
read-only.  Furthermore, joe is watching for edits and
mary is watching for commits.  The file <command>file2</command>
should be checked out read-only; sue started editing it
on 8 Jan 1975 in the directory <command>/home/sue/cvs</command> on
the machine <command>workstn1</command>.  Future files which are
added should be checked out read-only.  To represent
this example here, we have shown a space after
<command>D</command>, <command>Ffile1</command>, and <command>Ffile2</command>, but in fact
there must be a single tab character there and no spaces.
    </para>
</sect2>
   <sect2 id="Locks">
    <title>CVS locks in the repository
</title>
    <para><indexterm role="cp"><primary>#cvs.rfl, technical details</primary></indexterm><indexterm role="cp"><primary>#cvs.wfl, technical details</primary></indexterm><indexterm role="cp"><primary>#cvs.lock, technical details</primary></indexterm><indexterm role="cp"><primary>Locks, cvs, technical details</primary></indexterm>For an introduction to cvsnt locks focusing on
user-visible behavior, see <xref linkend="Concurrency" />.  The
following section is aimed at people who are writing
tools which want to access a cvsnt repository without
interfering with other tools acessing the same
repository.  If you find yourself confused by concepts
described here, like <firstterm>read lock</firstterm>, <firstterm>write lock</firstterm>,
and <firstterm>deadlock</firstterm>, you might consult the literature on
operating systems or databases.
    </para>
    <para><indexterm role="cp"><primary>Filesystem locks (obsolete)</primary></indexterm>
    cvsnt now uses the <command>LockServer</command> to handle lock concurrency in a dynamic
    way (see <xref linkend="Lockserver" />.  This following section refers to the 
    obsolete filesysem lock method, which may still be in use on some sites.
    </para>
    <para><indexterm role="cp"><primary>#cvs.tfl</primary></indexterm>Any file in the repository with a name starting
with <command>#cvs.rfl.</command> is a read lock.  Any file in
the repository with a name starting with
<command>#cvs.wfl</command> is a write lock.  Old versions of cvsnt
(before cvsnt 1.5) also created files with names starting
with <command>#cvs.tfl</command>, but they are not discussed here.
The directory <command>#cvs.lock</command> serves as a master
lock.  That is, one must obtain this lock first before
creating any of the other locks.
    </para>

    <para>
To obtain a readlock, first create the <command>#cvs.lock</command>
directory.  This operation must be atomic (which should
be true for creating a directory under most operating
systems).  If it fails because the directory already
existed, wait for a while and try again.  After
obtaining the <command>#cvs.lock</command> lock, create a file
whose name is <command>#cvs.rfl.</command> followed by information
of your choice (for example, hostname and process
identification number).  Then remove the
<command>#cvs.lock</command> directory to release the master lock.
Then proceed with reading the repository.  When you are
done, remove the <command>#cvs.rfl</command> file to release the
read lock.
    </para>

    <para>
To obtain a writelock, first create the
<command>#cvs.lock</command> directory, as with a readlock.  Then
check that there are no files whose names start with
<command>#cvs.rfl.</command>.  If there are, remove
<command>#cvs.lock</command>, wait for a while, and try again.  If
there are no readers, then create a file whose name is
<command>#cvs.wfl</command> followed by information of your choice
(for example, hostname and process identification
number).  Hang on to the <command>#cvs.lock</command> lock.  Proceed
with writing the repository.  When you are done, first
remove the <command>#cvs.wfl</command> file and then the
<command>#cvs.lock</command> directory. Note that unlike the
<command>#cvs.rfl</command> file, the <command>#cvs.wfl</command> file is just
informational; it has no effect on the locking operation
beyond what is provided by holding on to the
<command>#cvs.lock</command> lock itself.
    </para>

    <para>
Note that each lock (writelock or readlock) only locks
a single directory in the repository, including
<command>Attic</command> and <command>CVS</command> but not including
subdirectories which represent other directories under
version control.  To lock an entire tree, you need to
lock each directory (note that if you fail to obtain
any lock you need, you must release the whole tree
before waiting and trying again, to avoid deadlocks).
    </para>

    <para>
Note also that cvsnt expects writelocks to control
access to individual <command>foo,v</command> files.  rcs has
a scheme where the <command>,foo,</command> file serves as a lock,
but cvsnt does not implement it and so taking out a
cvsnt writelock is recommended.  See the comments at
rcs_internal_lockfile in the cvsnt source code for
further discussion/rationale.
    </para>

</sect2>
   <sect2 id="CVSROOT-storage">
    <title>How files are stored in the CVSROOT directory
</title>
    <para><indexterm role="cp"><primary>CVSROOT, storage of files</primary></indexterm>
The <command>$CVSROOT/CVSROOT</command> directory contains the
various administrative files.  In some ways this
directory is just like any other directory in the
repository; it contains rcs files whose names end
in <command>,v</command>, and many of the cvsnt commands operate
on it the same way.  However, there are a few
differences.
    </para>

    <para>
For each administrative file, in addition to the
rcs file, there is also a checked out copy of the
file.  For example, there is an rcs file
<command>loginfo,v</command> and a file <command>loginfo</command> which
contains the latest revision contained in
<command>loginfo,v</command>.  When you check in an administrative
file, cvsnt should print
    </para>

    <para><screen>cvs commit: Rebuilding administrative file database
</screen>    </para>

    <para>
and update the checked out copy in
<command>$CVSROOT/CVSROOT</command>.  If it does not, there is
something wrong (<xref linkend="BUGS" />).  To add your own files
to the files to be updated in this fashion, you can add
them to the <command>checkoutlist</command> administrative file
(<xref linkend="checkoutlist" />).
    </para>

    <para><indexterm role="cp"><primary>modules.db</primary></indexterm><indexterm role="cp"><primary>modules.pag</primary></indexterm><indexterm role="cp"><primary>modules.dir</primary></indexterm>By default, the <command>modules</command> file behaves as
described above.  If the modules file is very large,
storing it as a flat text file may make looking up
modules slow (I'm not sure whether this is as much of a
concern now as when cvsnt first evolved this
feature; I haven't seen benchmarks).  Therefore, by
making appropriate edits to the cvsnt source code
one can store the modules file in a database which
implements the <command>ndbm</command> interface, such as Berkeley
db or GDBM.  If this option is in use, then the modules
database will be stored in the files <command>modules.db</command>,
<command>modules.pag</command>, and/or <command>modules.dir</command>.
    </para>

    <para>
For information on the meaning of the various
administrative files, see <xref linkend="Administrative-files" />.
    </para>

</sect2></sect1>
  <sect1 id="Working-directory-storage">
   <title>How data is stored in the working directory
</title>


   <para><indexterm role="cp"><primary>CVS directory, in working directory</primary></indexterm>While we are discussing cvsnt internals which may
become visible from time to time, we might as well talk
about what cvsnt puts in the <command>CVS</command> directories
in the working directories.  As with the repository,
cvsnt handles this information and one can usually
access it via cvsnt commands.  But in some cases it
may be useful to look at it, and other programs, such
as the <command>jCVS</command> graphical user interface or the
<command>VC</command> package for emacs, may need to look at it.
Such programs should follow the recommendations in this
section if they hope to be able to work with other
programs which use those files, including future
versions of the programs just mentioned and the
command-line cvsnt client.
   </para>

   <para>
The <command>CVS</command> directory contains several files.
Programs which are reading this directory should
silently ignore files which are in the directory but
which are not documented here, to allow for future
expansion.
   </para>

   <para>
The files are stored according to the text file
convention for the system in question.  This means that
working directories are not portable between systems
with differing conventions for storing text files.
This is intentional, on the theory that the files being
managed by cvsnt probably will not be portable between
such systems either.
   </para>

   <variablelist>
    <varlistentry>
     <term><command>Root</command></term>
     <listitem>
      <para>
This file contains the current cvsnt root, as
described in <xref linkend="Specifying-a-repository" />.
      </para>

      <para><indexterm role="cp"><primary>Repository file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Repository file</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Repository</command></term>
     <listitem>
      <para>
This file contains the directory within the repository
which the current directory corresponds with.  It can
be either an absolute pathname or a relative pathname;
cvsnt has had the ability to read either format
since at least version 1.3 or so.  The relative
pathname is relative to the root, and is the more
sensible approach, but the absolute pathname is quite
common and implementations should accept either.  For
example, after the command
      </para>

      <para><screen>cvs -d :local:/usr/local/cvsroot checkout yoyodyne/tc
</screen>           </para>

      <para><command>Root</command> will contain
      </para>

      <para><screen>
:local:/usr/local/cvsroot
</screen>           </para>

      <para>
and <command>Repository</command> will contain either
      </para>

      <para><screen>
/usr/local/cvsroot/yoyodyne/tc
</screen>           </para>


      <para>
or
      </para>

      <para><screen>
yoyodyne/tc
</screen>           </para>

      <para>
If the particular working directory does not correspond
to a directory in the repository, then <command>Repository</command>
should contain <command>CVSROOT/Emptydir</command>.
      </para>

      <para><indexterm role="cp"><primary>Entries file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Entries file</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Entries</command></term>
     <listitem>
      <para>
This file lists the files and directories in the
working directory.
The first character of each line indicates what sort of
line it is.  If the character is unrecognized, programs
reading the file should silently skip that line, to
allow for future expansion.
      </para>

      <para>
If the first character is <command>/</command>, then the format is:
      </para>

      <para><screen>
/<varname>name</varname>/<varname>revision</varname>/<varname>timestamp</varname>[+<varname>conflict</varname>]/<varname>options</varname>/<varname>tagdate</varname>
</screen>           </para>

      <para>
where <command>[</command> and <command>]</command> are not part of the entry,
but instead indicate that the <command>+</command> and conflict
marker are optional.  <varname>name</varname> is the name of the
file within the directory.  <varname>revision</varname> is the
revision that the file in the working derives from, or
<command>0</command> for an added file, or <command>-</command> followed by a
revision for a removed file.  <varname>timestamp</varname> is the
timestamp of the file at the time that cvsnt created
it; if the timestamp differs with the actual
modification time of the file it means the file has
been modified.  It is stored in
the format used by the ISO C asctime() function (for
example, <command>Sun Apr  7 01:29:26 1996</command>).  One may
write a string which is not in that format, for
example, <command>Result of merge</command>, to indicate that the
file should always be considered to be modified.  This
is not a special case; to see whether a file is
modified a program should take the timestamp of the file
and simply do a string compare with <varname>timestamp</varname>.
If there was a conflict, <varname>conflict</varname> can be set to
the modification time of the file after the file has been
written with conflict markers (<xref linkend="Conflicts-example" />).
Thus if <varname>conflict</varname> is subsequently the same as the actual
modification time of the file it means that the user
has obviously not resolved the conflict.  <varname>options</varname>
contains sticky options (for example <command>-kb</command> for a
binary file).  <varname>tagdate</varname> contains <command>T</command> followed
by a tag name, or <command>D</command> for a date, followed by a
sticky tag or date.  Note that if <varname>timestamp</varname>
contains a pair of timestamps separated by a space,
rather than a single timestamp, you are dealing with a
version of cvsnt earlier than cvsnt 1.5 (not
documented here).
      </para>

      <para>
The timezone on the timestamp in CVS/Entries (local or
universal) should be the same as the operating system
stores for the timestamp of the file itself.  For
example, on Unix the file's timestamp is in universal
time (UT), so the timestamp in CVS/Entries should be
too.  On vms, the file's timestamp is in local
time, so cvsnt on vms should use local time.
This rule is so that files do not appear to be modified
merely because the timezone changed (for example, to or
from summer time).
      </para>

      <para>
If the first character of a line in <command>Entries</command> is
<command>D</command>, then it indicates a subdirectory.  <command>D</command>
on a line all by itself indicates that the program
which wrote the <command>Entries</command> file does record
subdirectories (therefore, if there is such a line and
no other lines beginning with <command>D</command>, one knows there
are no subdirectories).  Otherwise, the line looks
like:
      </para>

      <para><screen>
D/<varname>name</varname>/<varname>filler1</varname>/<varname>filler2</varname>/<varname>filler3</varname>/<varname>filler4</varname>
</screen>           </para>

      <para>
where <varname>name</varname> is the name of the subdirectory, and
all the <varname>filler</varname> fields should be silently ignored,
for future expansion.  Programs which modify
<command>Entries</command> files should preserve these fields.
      </para>

      <para>
The lines in the <command>Entries</command> file can be in any order.
      </para>

      <para><indexterm role="cp"><primary>Entries.Log file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Entries.Log file</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Entries.Log</command></term>
     <listitem>
      <para>
This file does not record any information beyond that
in <command>Entries</command>, but it does provide a way to update
the information without having to rewrite the entire
<command>Entries</command> file, including the ability to preserve
the information even if the program writing
<command>Entries</command> and <command>Entries.Log</command> abruptly aborts.
Programs which are reading the <command>Entries</command> file
should also check for <command>Entries.Log</command>.  If the latter
exists, they should read <command>Entries</command> and then apply
the changes mentioned in <command>Entries.Log</command>.  After
applying the changes, the recommended practice is to
rewrite <command>Entries</command> and then delete <command>Entries.Log</command>.
The format of a line in <command>Entries.Log</command> is a single
character command followed by a space followed by a
line in the format specified for a line in
<command>Entries</command>.  The single character command is
<command>A</command> to indicate that the entry is being added,
<command>R</command> to indicate that the entry is being removed,
or any other character to indicate that the entire line
in <command>Entries.Log</command> should be silently ignored (for
future expansion).  If the second character of the line
in <command>Entries.Log</command> is not a space, then it was
written by an older version of cvsnt (not documented
here).
      </para>

      <para>
Programs which are writing rather than reading can
safely ignore <command>Entries.Log</command> if they so choose.
      </para>

      <para><indexterm role="cp"><primary>Entries.Backup file, in CVS directory</primary></indexterm>
      <indexterm role="cp"><primary>CVS/Entries.Backup file</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Entries.Backup</command></term>
     <listitem>
      <para>
This is a temporary file.  Recommended usage is to
write a new entries file to <command>Entries.Backup</command>, and
then to rename it (atomically, where possible) to <command>Entries</command>.
      </para>
<para>
<indexterm role="cp"><primary>Entries.Old file, in CVS directory</primary></indexterm>
<indexterm role="cp"><primary>CVS/Entries.Old file</primary></indexterm>
 </para>
 </listitem>
 </varlistentry>
<varlistentry>
<term><command>Entries.Old</command></term>
<listitem>
<para>
This is the previous generation of the 'Entries' file. If your program modifies the 'Entries' file rename the existing file to 'Entries.Old' so that frontends are able to find out what has changed.
</para>
<para>
<indexterm role="cp"><primary>Entries.Static file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Entries.Static file</primary></indexterm>     
</para>
</listitem>
</varlistentry>
    <varlistentry>
     <term><command>Entries.Static</command></term>
     <listitem>
      <para>
The only relevant thing about this file is whether it
exists or not.  If it exists, then it means that only
part of a directory was gotten and cvsnt will
not create additional files in that directory.  To
clear it, use the <command>update</command> command with the
<command>-d</command> option, which will get the additional files
and remove <command>Entries.Static</command>.
      </para>
<para>
<indexterm role="cp"><primary>Entries.Extra file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Entries.Static file</primary></indexterm>     
<indexterm role="cp"><primary>CVS/Entries.Extra file</primary></indexterm><indexterm role="cp"><primary>CVS/Entries.Static file</primary></indexterm>     
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><command>Entries.Extra</command></term>
<listitem>
<para>
This holds extra information about the file that was not recorded by the original CVS client. If this file exists there is a line for each file in the Entries file. The lines can be in any order.
</para>
<para>
   The format of the lines is:
</para>
<para>
<symbol>
   /name/saved mergepoint/filler1/rcstime/
</symbol>
</para>
<para>
   If there are any extra fields after rcstime these should be ignored.
</para>
<para>
   The second field is the saved tag from an update -j, which is recorded the next time the file is committed to store the
   mergepoint data.
</para>
<para>
   The third field is unused (and reserved) at present.
</para>
<para>
   The fourth field is the last checkin time of the file, expressed as a time_t.
   Do not assume that this value will fit into a 32bit variable, as this will cause
   problems in 2038.
</para>
      <para>
<indexterm role="cp"><primary>Entries.Extra.Old file, in CVS directory</primary></indexterm>
<indexterm role="cp"><primary>CVS/Entries.Extra.Old file</primary></indexterm>
 </para>
 </listitem>
 </varlistentry>
<varlistentry>
<term><command>Entries.Extra.Old</command></term>
<listitem>
<para>
This is the previous generation of the 'Entries.Extra' file. If your program modifies the 'Entries' file rename the existing file to 'Entries.Extra.Old' so that frontends are able to find out what has changed.
</para>
<para>
     
      <indexterm role="cp"><primary>Tag file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Tag file</primary></indexterm><indexterm role="cp"><primary>Sticky tags/dates, per-directory</primary></indexterm><indexterm role="cp"><primary>Per-directory sticky tags/dates</primary></indexterm>
      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Tag</command></term>
     <listitem>
      <para>
This file contains per-directory sticky tags or dates.
The first character is <command>T</command> for a branch tag,
<command>N</command> for a non-branch tag, or <command>D</command> for a date,
or another character to mean the file should be
silently ignored, for future expansion.  This character
is followed by the tag or date.  Note that
per-directory sticky tags or dates are used for things
like applying to files which are newly added; they
might not be the same as the sticky tags or dates on
individual files.  For general information on sticky
tags and dates, see <xref linkend="Sticky-tags" />.
      </para>

      <para><indexterm role="cp"><primary>Notify file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Notify file</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Notify</command></term>
     <listitem>
      <para>
This file stores notifications (for example, for
<command>edit</command> or <command>unedit</command>) which have not yet been
sent to the server.  Its format is not yet documented
here.
      </para>

      <para><indexterm role="cp"><primary>Notify.tmp file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Notify.tmp file</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Notify.tmp</command></term>
     <listitem>
      <para>
This file is to <command>Notify</command> as <command>Entries.Backup</command>
is to <command>Entries</command>.  That is, to write <command>Notify</command>,
first write the new contents to <command>Notify.tmp</command> and
then (atomically where possible), rename it to
<command>Notify</command>.
      </para>

      <para><indexterm role="cp"><primary>Base directory, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Base directory</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Base</command></term>
     <listitem>
      <para>
If watches are in use, then an <command>edit</command> command
stores the original copy of the file in the <command>Base</command>
directory.  This allows the <command>unedit</command> command to
operate even if it is unable to communicate with the
server.
      </para>

      <para><indexterm role="cp"><primary>Baserev file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Baserev file</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Baserev</command></term>
     <listitem>
      <para>
The file lists the revision for each of the files in
the <command>Base</command> directory.  The format is:
      </para>

      <para><screen>
B<varname>name</varname>/<varname>rev</varname>/<varname>expansion</varname>
</screen>           </para>

      <para>
where <varname>expansion</varname> should be ignored, to allow for
future expansion.
      </para>

      <para><indexterm role="cp"><primary>Baserev.tmp file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Baserev.tmp file</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Baserev.tmp</command></term>
     <listitem>
      <para>
This file is to <command>Baserev</command> as <command>Entries.Backup</command>
is to <command>Entries</command>.  That is, to write <command>Baserev</command>,
first write the new contents to <command>Baserev.tmp</command> and
then (atomically where possible), rename it to
<command>Baserev</command>.
      </para>

      <para><indexterm role="cp"><primary>Template file, in CVS directory</primary></indexterm><indexterm role="cp"><primary>CVS/Template file</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>Template</command></term>
     <listitem>
      <para>
This file contains the template specified by the
<command>rcsinfo</command> file (<xref linkend="rcsinfo" />).  It is only used
by the client; the non-client/server cvsnt consults
<command>rcsinfo</command> directly.
      </para></listitem></varlistentry></variablelist>

</sect1>
  <sect1 id="Intro-administrative-files">
   <title>The administrative files
</title>
   <para><indexterm role="cp"><primary>Administrative files (intro)</primary></indexterm><indexterm role="cp"><primary>Modules file</primary></indexterm><indexterm role="cp"><primary>CVSROOT, module name</primary></indexterm><indexterm role="cp"><primary>Defining modules (intro)</primary></indexterm>
   </para>

   <para>
The directory <command>$CVSROOT/CVSROOT</command> contains some <firstterm>administrative
files</firstterm>.  <xref linkend="Administrative-files" />, for a complete description.
You can use cvsnt without any of these files, but
some commands work better when at least the
<command>modules</command> file is properly set up.
   </para>

   <para>
The most important of these files is the <command>modules</command>
file.  It defines all modules in the repository.  This
is a sample <command>modules</command> file.
   </para>

   <para><screen>CVSROOT         CVSROOT
modules         CVSROOT modules
cvs             gnu/cvs
rcs             gnu/rcs
diff            gnu/diff
tc              yoyodyne/tc
</screen>   </para>
   <para>
The <command>modules</command> file is line oriented.  In its
simplest form each line contains the name of the
module, whitespace, and the directory where the module
resides.  The directory is a path relative to
<command>$CVSROOT</command>.  The last four lines in the example
above are examples of such lines.
   </para>
   <para>
The line that defines the module called <command>modules</command>
uses features that are not explained here.
<xref linkend="modules" />, for a full explanation of all the
available features.
   </para>
   <para>
   In many cases the <command>modules2</command> file may be more suitable for defining modules.  See <xref linkend="modules2" /> for details.
   </para>
   <sect2>
    <title>Editing administrative files
</title>
    <para><indexterm role="cp"><primary>Editing administrative files</primary></indexterm><indexterm role="cp"><primary>Administrative files, editing them</primary></indexterm>
You edit the administrative files in the same way that you would edit
any other module.  Use <command>cvs checkout CVSROOT</command> to get a working
copy, edit it, and commit your changes in the normal way.
    </para>

    <para>
It is possible to commit an erroneous administrative
file.  You can often fix the error and check in a new
revision, but sometimes a particularly bad error in the
administrative file makes it impossible to commit new
revisions.
    </para>

</sect2></sect1>
  <sect1 id="Multiple-repositories">
   <title>Multiple repositories
</title>
   <para><indexterm role="cp"><primary>Multiple repositories</primary></indexterm><indexterm role="cp"><primary>Repositories, multiple</primary></indexterm><indexterm role="cp"><primary>Many repositories</primary></indexterm><indexterm role="cp"><primary>Parallel repositories</primary></indexterm><indexterm role="cp"><primary>Disjoint repositories</primary></indexterm><indexterm role="cp"><primary>CVSROOT, multiple repositories</primary></indexterm>
In some situations it is a good idea to have more than
one repository, for instance if you have two
development groups that work on separate projects
without sharing any code.  All you have to do to have
several repositories is to specify the appropriate
repository, using the <command>CVSROOT</command> environment
variable, the <command>-d</command> option to cvsnt, or (once
you have checked out a working directory) by simply
allowing cvsnt to use the repository that was used
to check out the working directory
(<xref linkend="Specifying-a-repository" />).
   </para>

   <para>
The big advantage of having multiple repositories is
that they can reside on different servers.  With CVS
version 1.10, a single command cannot recurse into
directories from different repositories.  With development
versions of cvsnt, you can check out code from multiple
servers into your working directory.  cvsnt will
recurse and handle all the details of making
connections to as many server machines as necessary to
perform the requested command.  Here is an example of
how to set up a working directory:
   </para>

   <para><screen>cvs -d server1:/cvs co dir1
cd dir1
cvs -d server2:/root co sdir
cvs update
</screen>   </para>
   <para>
The <command>cvs co</command> commands set up the working
directory, and then the <command>cvs update</command> command will
contact server2, to update the dir1/sdir subdirectory,
and server1, to update everything else.
   </para>
</sect1>
  <sect1 id="Creating-a-repository">
   <title>Creating a repository
</title>

   <para><indexterm role="cp"><primary>Repository, setting up</primary></indexterm><indexterm role="cp"><primary>Creating a repository</primary></indexterm><indexterm role="cp"><primary>Setting up a repository</primary></indexterm>
To set up a cvsnt repository, first choose the
machine and disk on which you want to store the
revision history of the source files.  CPU and memory
requirements are modest, so most machines should be
adequate.  For details see <xref linkend="Server-requirements" />.
   </para>

   <para>
To estimate disk space
requirements, if you are importing rcs files from
another system, the size of those files is the
approximate initial size of your repository, or if you
are starting without any version history, a rule of
thumb is to allow for the server approximately three
times the size of the code to be under cvsnt for the
repository (you will eventually outgrow this, but not
for a while).  On the machines on which the developers
will be working, you'll want disk space for
approximately one working directory for each developer
(either the entire tree or a portion of it, depending
on what each developer uses).
   </para>

   <para>
The repository should be accessible
(directly or via a networked file system) from all
machines which want to use cvsnt in server or local
mode; the client machines need not have any access to
it other than via the cvsnt protocol.  It is not
possible to use cvsnt to read from a repository
which one only has read access to; cvsnt needs to be
able to create lock files (<xref linkend="Concurrency" />).
   </para>

   <para><indexterm role="cp"><primary>init (subcommand)</primary></indexterm>To create a repository, run the <command>cvs init</command>
command.  It will set up an empty repository in the
cvsnt root specified in the usual way
(<xref linkend="Repository" />).  For example,
   </para>

   <para><screen>cvs -d /usr/local/cvsroot init
</screen>   </para>
   <para><command>cvs init</command> is careful to never overwrite any
existing files in the repository, so no harm is done if
you run <command>cvs init</command> on an already set-up
repository.
   </para>
   <para><command>cvs init</command> will enable history logging; if you
don't want that, remove the history file after running
<command>cvs init</command>.  <xref linkend="history-file" />.
   </para>
</sect1>
  <sect1 id="Backing-up">
   <title>Backing up a repository
</title>
   <para><indexterm role="cp"><primary>Repository, backing up</primary></indexterm><indexterm role="cp"><primary>Backing up, repository</primary></indexterm>
There is nothing particularly magical about the files
in the repository; for the most part it is possible to
back them up just like any other files.  However, there
are a few issues to consider.
   </para>

   <para><indexterm role="cp"><primary>Locks, cvs, and backups</primary></indexterm><indexterm role="cp"><primary>#cvs.rfl, and backups</primary></indexterm>The first is that to be paranoid, one should either not
use cvsnt during the backup, or have the backup
program lock cvsnt while doing the backup.  To not
use cvsnt, you might forbid logins to machines which
can access the repository, turn off your cvsnt
server, or similar mechanisms.  The details would
depend on your operating system and how you have
cvsnt set up.  To lock cvsnt, you would create
<command>#cvs.rfl</command> locks in each repository directory.
See <xref linkend="Concurrency" />, for more on cvsnt locks.
Having said all this, if you just back up without any
of these precautions, the results are unlikely to be
particularly dire.  Restoring from backup, the
repository might be in an inconsistent state, but this
would not be particularly hard to fix manually.
   </para>

   <para>
When you restore a repository from backup, assuming
that changes in the repository were made after the time
of the backup, working directories which were not
affected by the failure may refer to revisions which no
longer exist in the repository.  Trying to run cvsnt
in such directories will typically produce an error
message.  One way to get those changes back into the
repository is as follows:
   </para>

   <itemizedlist mark="bullet">
    <listitem>
     <para>
Get a new working directory.
     </para>
</listitem>
    <listitem>
     <para>
Copy the files from the working directory from before
the failure over to the new working directory (do not
copy the contents of the <command>CVS</command> directories, of
course).
     </para>
</listitem>
    <listitem>
     <para>
Working in the new working directory, use commands such
as <command>cvs update</command> and <command>cvs diff</command> to figure out
what has changed, and then when you are ready, commit
the changes into the repository.
     </para></listitem></itemizedlist>
</sect1>
  <sect1 id="Moving-a-repository">
   <title>Moving a repository
</title>
   <para><indexterm role="cp"><primary>Repository, moving</primary></indexterm><indexterm role="cp"><primary>Moving a repository</primary></indexterm><indexterm role="cp"><primary>Copying a repository</primary></indexterm>
Just as backing up the files in the repository is
pretty much like backing up any other files, if you
need to move a repository from one place to another it
is also pretty much like just moving any other
collection of files.
   </para>

   <para>
The main thing to consider is that working directories
point to the repository.  The simplest way to deal with
a moved repository is to just get a fresh working
directory after the move.  Of course, you'll want to
make sure that the old working directory had been
checked in before the move, or you figured out some
other way to make sure that you don't lose any
changes.  If you really do want to reuse the existing
working directory, it should be possible with manual
surgery on the <command>CVS/Repository</command> files.  You can
see <xref linkend="Working-directory-storage" />, for information on
the <command>CVS/Repository</command> and <command>CVS/Root</command> files, but
unless you are sure you want to bother, it probably
isn't worth it.
   </para>

</sect1>
  <sect1 id="Remote-repositories">
   <title>Remote repositories
</title>
   <para><indexterm role="cp"><primary>Repositories, remote</primary></indexterm><indexterm role="cp"><primary>Remote repositories</primary></indexterm><indexterm role="cp"><primary>Client/Server Operation</primary></indexterm><indexterm role="cp"><primary>Server, CVS</primary></indexterm><indexterm role="cp"><primary>Remote repositories, port specification</primary></indexterm><indexterm role="cp"><primary>Repositories, remote, port specification</primary></indexterm><indexterm role="cp"><primary>Client/Server Operation, port specification</primary></indexterm><indexterm role="cp"><primary>pserver (client/server connection method), port specification</primary></indexterm><indexterm role="cp"><primary>sspi (client/server connection method), port specification</primary></indexterm><indexterm role="cp"><primary>gserver (client/server connection method), port specification</primary></indexterm><indexterm role="cp"><primary>sserver (client/server connection method), port specification</primary></indexterm><indexterm role="cp"><primary>port, specifying for remote repositories</primary></indexterm>
        Your working copy of the sources can be on a
different machine than the repository.  Using cvsnt
in this manner is known as <firstterm>client/server</firstterm>
operation.  You run cvsnt on a machine which can
mount your working directory, known as the
<firstterm>client</firstterm>, and tell it to communicate to a machine
which can mount the repository, known as the
<firstterm>server</firstterm>.  Generally, using a remote
repository is just like using a local one, except that
the format of the repository name is:
   </para>

   <para><screen>:<varname>method</varname>:[[<varname>user</varname>][:<varname>password</varname>]@]<varname>hostname</varname>[:[<varname>port</varname>]][:]/path/to/repository
</screen>   </para>
   <para>
Specifying a password in the repository name is not recommended during
checkout, since this will cause cvsnt to store a cleartext copy of the
password in each created directory.  <command>cvs login</command> first instead
(<xref linkend="Authentication-client" />).
   </para>
   <para>
The details of exactly what needs to be set up depend
on how you are connecting to the server.
   </para>
   <para>
If <varname>method</varname> is not specified, and the repository
name contains <command>:</command>, then the default is <command>ext</command>
or <command>server</command>, depending on your platform; both are
described in <xref linkend="Connecting-via-ssh" />.
   </para>


   <sect2 id="Server-requirements">
    <title>Server requirements
</title>

    <para>
The quick answer to what sort of machine is suitable as
a server is that requirements are modest--a server
with 32M of memory or even less can handle a fairly
large source tree with a fair amount of activity.
    </para>

    <para>
The real answer, of course, is more complicated.
Estimating the known areas of large memory consumption
should be sufficient to estimate memory requirements.
There are two such areas documented here; other memory
consumption should be small by comparison (if you find
that is not the case, let us know, as described in
<xref linkend="BUGS" />, so we can update this documentation).
    </para>

    <para>
The first area of big memory consumption is large
checkouts, when using the cvsnt server.  The server
consists of two processes for each client that it is
serving.  Memory consumption on the child process
should remain fairly small.  Memory consumption on the
parent process, particularly if the network connection
to the client is slow, can be expected to grow to
slightly more than the size of the sources in a single
directory, or two megabytes, whichever is larger.
    </para>

    <para>
Multiplying the size of each cvsnt server by the
number of servers which you expect to have active at
one time should give an idea of memory requirements for
the server.  For the most part, the memory consumed by
the parent process probably can be swap space rather
than physical memory.
    </para>


    <para>
The second area of large memory consumption is
<command>diff</command>, when checking in large files.  This is
required even for binary files.  The rule of thumb is
to allow about ten times the size of the largest file
you will want to check in, although five times may be
adequate.  For example, if you want to check in a file
which is 10 megabytes, you should have 100 megabytes of
memory on the machine doing the checkin (the server
machine for client/server, or the machine running
cvsnt for non-client/server).  This can be swap
space rather than physical memory.  Because the memory
is only required briefly, there is no particular need
to allow memory for more than one such checkin at a
time.
    </para>

    <para>
Resource consumption for the client is even more
modest--any machine with enough capacity to run the
operating system in question should have little
trouble.
    </para>

    <para>
For information on disk space requirements, see
<xref linkend="Creating-a-repository" />.
    </para>

</sect2>
   <sect2 id="Connecting-via-ssh">
    <title>Connecting with ssh
</title>

    <para><indexterm role="cp"><primary>ssh</primary></indexterm>cvsnt uses the <command>ssh</command> protocol to perform these
operations, so the remote user host needs to have a
<command>.rhosts</command> file which grants access to the local
user.
    </para>

    <para>
For example, suppose you are the user <command>mozart</command> on
the local machine <command>toe.example.com</command>, and the
server machine is <command>faun.example.org</command>.  On
faun, put the following line into the file
<command>.rhosts</command> in <command>bach</command>'s home directory:
    </para>

    <para><screen>toe.example.com  mozart
</screen>    </para>
    <para>
Then test that <command>ssh</command> is working with
    </para>
    <para><screen>
ssh -l bach faun.example.org 'echo $PATH'
</screen>       </para>
    <para>
There is no need to edit <command>inetd.conf</command> or start a
cvsnt server daemon.
    </para>
    <para><indexterm role="cp"><primary>:ssh:, setting up</primary></indexterm>On some versions of cvsnt :ssh: protocol is available.  This is
a builtin ssh client which integrates cvs authentication with ssh security.
    </para>
    <para>
At its simplest, this is used like :pserver:, as in:
    </para>
    <para><screen>
cvs -d :ssh:user@machine.example.org:/usr/local/cvs login
Password: *****
cvs -d :ssh:user@machine.example.org:/usr/local/cvs co myproject
</screen>       </para>
    <para>
However you can also register your private key with cvs, which it will use
instead of a password:
    </para>
    <para><screen>
cvs -d :ssh;key='c:\id_dsa':user@machine.example.org:/usr/local/cvs login
Password: ******** (if your key has no passphrase, just press enter here)
cvs -d :ssh:user@machine.example.org:/usr/local/cvs co myproject
</screen>       </para>
    <para>
The keys should be in the following format:
    </para>
    <itemizedlist mark="bullet">
     <listitem>
      <para>
An SSH1 compatible private key file, unencrypted.
      </para>
</listitem>
     <listitem>
      <para>
An OpenSSH SSH2 compatibile private key file, which may be encrypted.
      </para></listitem></itemizedlist>   
    <para>
Several programs are available to convert various key formats to OpenSSH
format (for example PuttyGen on NT).
    </para>
    <para><indexterm role="cp"><primary>:server:, setting up</primary></indexterm><indexterm role="cp"><primary>:ext:, setting up</primary></indexterm><indexterm role="cp"><primary>Kerberos, using kerberized rsh</primary></indexterm><indexterm role="cp"><primary>ssh replacements (Kerberized RSH, &amp;c)</primary></indexterm><command>:ext:</command> specifies an external ssh program.  By
default this is <command>ssh</command> but you may specify another
program in the CVSROOT using the optional :ext:{program}
command.   You may alternatively set the
<command>CVS_EXT</command> environment variable to invoke another
program which can access the remote server (for
example, <command>remsh</command> on HP-UX 9 because <command>rsh</command> is
something different).  It must be a program which can
transmit data to and from the server without modifying
it
    </para>
    <para>
Continuing our example, supposing you want to access
the module <command>foo</command> in the repository
<command>/usr/local/cvsroot/</command>, on machine
<command>faun.example.org</command>, you are ready to go:
    </para>
    <para><screen>
cvs -d :ext:bach@faun.example.org/usr/local/cvsroot checkout foo
</screen>       </para>
    <para>
(The <command>bach@</command> can be omitted if the username is
the same on both the local and remote hosts.)
    </para>
    <para>
    <indexterm role="cp"><primary>extnt.exe</primary></indexterm>
    <indexterm role="cp"><primary>extnt.ini</primary></indexterm>
    <indexterm role="cp"><primary>Using CVSNT protocols with 3rd party clients</primary></indexterm>
    (Windows only at present)
    The extnt.exe program is a wrapper client which allows 3rd-party clients to use CVSNT protocols
    to access a CVSNT server.  It uses the :ext: protocol on the client so should be compatible with
    all existing clients.
    </para>
    <para>
    Before use the extnt.ini file must be setup with the server details.  For example:
    </para>
    <para><screen>
    [cvs.myserver.org]
    protocol=sspi
    hostname=cvs.myserver.org
    directory=/cvs
    </screen></para>
    <para>
    The cvsroot on the client for the above would be <screen>:ext:cvs.myserver.org:/cvs</screen>.  
    Configuring the client to call extnt.exe as its :ext: application is client specific.
    </para>
</sect2>
   <sect2 id="Password-authenticated">
    <title>Direct connection with password authentication
</title>

    <para>
The cvsnt client can also connect to the server
using a password protocol.  This is particularly useful
if using <command>ssh</command> is not feasible (for example,
the server is behind a firewall), and Kerberos also is
not available.
    </para>
        
    <para>
To use this method, it is necessary to make
some adjustments on both the server and client sides.
    </para>

    <sect3 id="Authentication-server">
     <title>Setting up the server for Authentication
</title>

     <para>
First of all, you probably want to tighten the
permissions on the <command>$CVSROOT</command> and
<command>$CVSROOT/CVSROOT</command> directories.  See <xref linkend="Authentication-security" />, for more details.
     </para>

     <para><indexterm role="cp"><primary>authserver (subcommand)</primary></indexterm><indexterm role="cp"><primary>Remote repositories, port specification</primary></indexterm><indexterm role="cp"><primary>Repositories, remote, port specification</primary></indexterm><indexterm role="cp"><primary>Client/Server Operation, port specification</primary></indexterm><indexterm role="cp"><primary>authserver (client/server connection method), port specification</primary></indexterm><indexterm role="cp"><primary>port, specifying for remote repositories</primary></indexterm><indexterm role="cp"><primary>Authenticating server, setting up</primary></indexterm>On Windows NT, on the server side, you must run the
cvsservice.exe program which calls the cvs.exe when
required.  Setup is done using the cvsnt control panel.
the rest of this chapter is mostly Unix related.
     </para>

     <para>
On Unix, on the server side, the file <command>/etc/inetd.conf</command>
needs to be edited so <command>inetd</command> knows to run the
command <command>cvs authserver</command> when it receives a
connection on the right port.
     </para>

     <para>
By default, the port number is for pserver is 2401
it would be different for pserver if your client
were compiled with <command>CVS_AUTH_PORT</command> defined to
something else, though.  This can also be sepcified in the CVSROOT variable
(<xref linkend="Remote-repositories" />) or overridden with the CVS_CLIENT_PORT
environment variable (<xref linkend="Environment-variables" />), or, on
NT, set in the cvsnt control panel.
     </para>
        
     <para>
If your <command>inetd</command> allows raw port numbers in
<command>/etc/inetd.conf</command>, then the following (all on a
single line in <command>inetd.conf</command>) should be sufficient:
     </para>

     <para><screen>2401  stream  tcp  nowait  root  /usr/local/bin/cvs
cvs -f --allow-root=/usr/cvsroot authserver
</screen>     </para>
     <para>
You could also use the
<command>-T</command> option to specify a temporary directory, or, on
NT set this within the cvsnt control panel.
     </para>
     <para>
The <command>-allow-root</command> option specifies the allowable
cvsroot directory.  Clients which attempt to use a
different cvsroot directory will not be allowed to
connect.  If there is more than one cvsroot
directory which you want to allow, repeat the option.
(Unfortunately, many versions of <command>inetd</command> have very small
limits on the number of arguments and/or the total length
of the command.  Unix based CVSNT servers usually use the <command>/etc/cvsnt/PServer</command>
file to store root strings, which avoids this limitation).
     </para>
     <para>
     You can also specify repository aliases in the <command>--allow-root</command> command (see <xref linkend="Repository-Alias" />)
     by specifying the alias after the real root, separated by comma.
     </para>
     <para>
If your <command>inetd</command> wants a symbolic service
name instead of a raw port number, then put this in
<command>/etc/services</command>:
     </para>
     <para><screen>
cvspserver      2401/tcp
</screen>        </para>
     <para>
and put <command>cvspserver</command> instead of
<command>2401</command> or <command>8003</command> in <command>inetd.conf</command>.
     </para>
     <para>
Once the above is taken care of, restart your
<command>inetd</command>, or do whatever is necessary to force it
to reread its initialization files.
     </para>
     <para>
If you are having trouble setting this up, see
<xref linkend="Connection" />.
     </para>
     <para><indexterm role="cp"><primary>CVS passwd file</primary></indexterm><indexterm role="cp"><primary>passwd (admin file)</primary></indexterm>Because the client stores and transmits passwords in
cleartext (almost--see <xref linkend="Authentication-security" />, for details), a separate cvsnt password
file is generally used, so people don't compromise
their regular passwords when they access the
repository.  This file is
<command>$CVSROOT/CVSROOT/passwd</command> (<xref linkend="Intro-administrative-files" />).  It uses a colon-separated
format, similar to <command>/etc/passwd</command> on Unix systems,
except that it has fewer fields: cvsnt username,
optional password, and an optional system username for
cvsnt to run as if authentication succeeds.  Here is
an example <command>passwd</command> file with five entries:
     </para>
     <para><screen>
anonymous:
bach:ULtgRLXo7NRxs
spwang:1sOp854gDF3DY
melissa:tGX1fS8sun6rY:pubcvs
qproj:XR4EZcEs0szik:pubcvs
</screen>        </para>
     <para>
(The passwords are encrypted according to the standard
Unix <command>crypt()</command> function, so it is possible to
paste in passwords directly from regular Unix
<command>/etc/passwd</command> files.)
     </para>
     <para>
The first line in the example will grant access to any
cvsnt client attempting to authenticate as user
<command>anonymous</command>, no matter what password they use,
including an empty password.  (This is typical for
sites granting anonymous read-only access; for
information on how to do the "read-only" part, see
<xref linkend="Read-only-access" />.)
     </para>
     <para>
The second and third lines will grant access to
<command>bach</command> and <command>spwang</command> if they supply their
respective plaintext passwords.
     </para>
     <para><indexterm role="cp"><primary>User aliases</primary></indexterm>The fourth line will grant access to <command>melissa</command>, if
she supplies the correct password, but her cvsnt
operations will actually run on the server side under
the system user <command>pubcvs</command>.  Thus, there need not be
any system user named <command>melissa</command>, but there
<emphasis>must</emphasis> be one named <command>pubcvs</command>.
     </para>
     <para>
The fifth line shows that system user identities can be
shared: any client who successfully authenticates as
<command>qproj</command> will actually run as <command>pubcvs</command>, just
as <command>melissa</command> does.  That way you could create a
single, shared system user for each project in your
repository, and give each developer their own line in
the <command>$CVSROOT/CVSROOT/passwd</command> file.  The cvsnt
username on each line would be different, but the
system username would be the same.  The reason to have
different cvsnt usernames is that cvsnt will log their
actions under those names: when <command>melissa</command> commits
a change to a project, the checkin is recorded in the
project's history under the name <command>melissa</command>, not
<command>pubcvs</command>.  And the reason to have them share a
system username is so that you can arrange permissions
in the relevant area of the repository such that only
that account has write-permission there.
     </para>
     <para>
If the system-user field is present, all
password-authenticated cvsnt commands run as that
user; if no system user is specified, cvsnt simply
takes the cvsnt username as the system username and
runs commands as that user.  In either case, if there
is no such user on the system, then the cvsnt
operation will fail (regardless of whether the client
supplied a valid password).
     </para>
     <para>
The password and system-user fields can both be omitted
(and if the system-user field is omitted, then also
omit the colon that would have separated it from the
encrypted password).  For example, this would be a
valid <command>$CVSROOT/CVSROOT/passwd</command> file:
     </para>
     <para><screen>
anonymous::pubcvs
fish:rKa5jzULzmhOo:kfogel
sussman:1sOp854gDF3DY
</screen>        </para>
     <para>
When the password field is omitted or empty, then the
client's authentication attempt will succeed with any
password, including the empty string.  However, the
colon after the cvsnt username is always necessary,
even if the password is empty.
     </para>
     <para>
cvsnt can also fall back to use system authentication.
When authenticating a password, the server first checks
for the user in the <command>$CVSROOT/CVSROOT/passwd</command>
file.  If it finds the user, it will use that entry for
authentication as described above.  But if it does not
find the user, or if the cvsnt <command>passwd</command> file
does not exist, then the server can try to authenticate
the username and password using the operating system's
user-lookup routines (this "fallback" behavior can be
disabled by setting <command>SystemAuth=no</command> in the
cvsnt <command>config</command> file, <xref linkend="config" />).  Be
aware, however, that falling back to system
authentication might be a security risk: cvsnt
operations would then be authenticated with that user's
regular login password, and the p
assword flies across
the network in plaintext.  See <xref linkend="Authentication-security" /> for more on this.
     </para>
     <para>
You can setup the passwd file by logging in to cvs using
another method (local, sserver, gserver, ssh, sspi) and using
the cvsnt passwd command to add new users.
     </para>
</sect3>
    <sect3 id="Authentication-client">
     <title>Using the client with password authentication
</title>
     <para><indexterm role="cp"><primary>Login (subcommand)</primary></indexterm><indexterm role="cp"><primary>Authenticated client, using</primary></indexterm><indexterm role="cp"><primary>:pserver:, setting up</primary></indexterm><indexterm role="cp"><primary>:sserver:, setting up</primary></indexterm><indexterm role="cp"><primary>:sspi:, setting up</primary></indexterm>To run a cvsnt command on a remote repository via
the password-authenticating server, one specifies the
protocol, optional username,
repository host, an
optional port number, and path to the repository.  For example:
     </para>

     <para><screen>cvs -d :pserver:faun.example.org:/usr/local/cvsroot checkout someproj

cvs -d :sserver:faun.example.org:/usr/local/cvsroot checkout someproj

cvs -d :sspi:faun.example.org:/usr/local/cvsroot checkout someproj
</screen>     </para>
     <para>
With certain protcols, unless you're connecting to a public-access
repository (i.e., one where that username doesn't
require a password), you'll need to supply a password or <firstterm>log in</firstterm> first.
Logging in verifies your password with the repository and stores it in a file.
It's done with the <command>login</command> command, which will
prompt you interactively for the password if you didn't supply one as part of
<varname>$CVSROOT</varname>:
     </para>
     <para><screen>
cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot login
CVS password:
</screen>        </para>
     <para>
or
     </para>
     <para><screen>
cvs -d :pserver:bach:p4ss30rd@faun.example.org:/usr/local/cvsroot login
</screen>        </para>
     <para>
After you enter the password, cvsnt verifies it with
the server.  If the verification succeeds, then that
combination of username, host, repository, and password
is permanently recorded, so future transactions with
that repository won't require you to run <command>cvs
login</command>.  (If verification fails, cvsnt will exit
complaining that the password was incorrect, and
nothing will be recorded.)
     </para>
     <para>
The records are stored, by default, in the file
<command>$HOME/.cvspass</command> (Unix) or the Registry (NT).
The format human-readable, and to a degree human-editable, but
note that the passwords are not stored in
cleartext--they are trivially encoded to protect them
from "innocent" compromise (i.e., inadvertent viewing
by a system administrator or other non-malicious
person).
     </para>
     <para>
Once you have logged in, all cvsnt commands using
that remote repository and username will authenticate
with the stored password.  So, for example
     </para>
     <para><screen>
cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot checkout foo
</screen>        </para>
     <para>
should just work (unless the password changes on the
server side, in which case you'll have to re-run
<command>cvs login</command>).
     </para>
     <para>
Note that if the <command>:pserver:</command> were not present in
the repository specification, cvsnt would assume it
should use <command>ssh</command> to connect with the server
instead (<xref linkend="Connecting-via-ssh" />).
     </para>
     <para>
Of course, once you have a working copy checked out and
are running cvsnt commands from within it, there is
no longer any need to specify the repository
explicitly, because cvsnt can deduce the repository
from the working copy's <command>CVS</command> subdirectory.
     </para>
     <para><indexterm role="cp"><primary>Logout (subcommand)</primary></indexterm>The password for a given remote repository can be
removed from the <command>CVS_PASSFILE</command> by using the
<command>cvs logout</command> command.
     </para>
</sect3>
    <sect3 id="Authentication-security">
     <title>Security considerations with password authentication
</title>

     <para><indexterm role="cp"><primary>Security, of pserver</primary></indexterm><indexterm role="cp"><primary>Security, of sserver</primary></indexterm><indexterm role="cp"><primary>Security, of sspi</primary></indexterm><indexterm role="cp"><primary>Secutiry, of ntserver</primary></indexterm>
With pserver and sserver,  the passwords are stored on
the client side in a trivial encoding of the cleartext
and in the pserver case transmitted in the same encoding.
The encoding is done only to prevent inadvertent password
compromises (i.e., a system administrator accidentally
looking at the file), and will not prevent even a naive
attacker from gaining the password.
     </para>

     <para>
With sserver, the client/server connection is encrypted using
SSL, and the risk of the password being sniffed 'on the wire'
is very low.
     </para>

     <para>
With sspi, if cvsnt login is used to gain access to a remote
server, the passwords are stored on the client side in the same
manner as pserver.  However the passwords are never transmitted
insecurely over the internet.
     </para>

     <para>
With pserver and sserver, the separate cvsnt password file
(<xref linkend="Authentication-server" />) allows people to use a different password for repository access than
for login access.  With other protocols the system passwords
are used and the password field in the passwd file is ignored.
     </para>

     <para>
Once a user has non-read-only access to the repository, she can execute programs on
the server system through a variety of means.  Thus, repository
access implies fairly broad system access as well.  It
might be possible to modify cvsnt to prevent that,
but no one has done so as of this writing.
     </para>

     <para>
Note that because the <command>$CVSROOT/CVSROOT</command> directory
contains <command>passwd</command> and other files which are used
to check security, you must control the permissions on
this directory as tightly as the permissions on
<command>/etc</command>.  The same applies to the <command>$CVSROOT</command>
directory itself and any directory
above it in the tree.  Anyone who has write access to
such a directory will have the ability to become any
user on the system.  Note that these permissions are
typically tighter than you would use if you are not
using pserver.
     </para>

     <para>
In summary,  with a password server anyone who gets the password gets
repository access (which may imply some measure of general system
access as well).
     </para>

     <para>
With pserver, the password is available to anyone
who can sniff network packets or read a protected
(i.e., user read-only) file.  Other protocols do not have this
problem.
     </para>

</sect3></sect2>
   <sect2 id="GSSAPI-authenticated">
    <title>Direct connection with GSSAPI
</title>

    <para><indexterm role="cp"><primary>GSSAPI</primary></indexterm><indexterm role="cp"><primary>Security, GSSAPI</primary></indexterm><indexterm role="cp"><primary>:gserver:, setting up</primary></indexterm><indexterm role="cp"><primary>Kerberos, using :gserver:</primary></indexterm>GSSAPI is a generic interface to network security
systems such as Kerberos 5.
If you have a working GSSAPI library, you can have
cvsnt connect via a direct tcp connection,
authenticating with GSSAPI.
    </para>

    <para>
To do this, cvsnt needs to be compiled with GSSAPI
support; when configuring cvsnt it tries to detect
whether GSSAPI libraries using kerberos version 5 are
present.  You can also use the <command>-with-gssapi</command>
flag to configure.
    </para>

    <para>
The connection is authenticated using GSSAPI, but the
message stream is <emphasis>not</emphasis> authenticated by default.
You must use the <command>-a</command> global option to request
stream authentication.
    </para>

    <para>
The data transmitted is <emphasis>not</emphasis> encrypted by
default.  Encryption support must be compiled into both
the client and the server; use the
<command>-enable-encrypt</command> configure option to turn it on.
You must then use the <command>-x</command> global option to
request encryption.
    </para>

    <para>
GSSAPI connections are handled on the server side by
the same server which handles the password
authentication server; see <xref linkend="Authentication-server" />.  If you are using a GSSAPI mechanism such as
Kerberos which provides for strong authentication, you
will probably want to disable the ability to
authenticate via cleartext passwords.  To do so, create
an empty <command>CVSROOT/passwd</command> password file, and set
<command>SystemAuth=no</command> in the config file
(<xref linkend="config" />).
    </para>

    <para>
The GSSAPI server uses a principal name of
cvs/<varname>hostname</varname>, where <varname>hostname</varname> is the
canonical name of the server host.  You will have to
set this up as required by your GSSAPI mechanism.
    </para>

    <para>
To connect using GSSAPI, use <command>:gserver:</command>.  For
example,
    </para>

    <para><screen>cvs -d :gserver:faun.example.org:/usr/local/cvsroot checkout foo
</screen>    </para>
</sect2>
   <sect2 id="Connecting-via-fork">
    <title>Connecting with fork
</title>

    <para><indexterm role="cp"><primary>fork, access method</primary></indexterm><indexterm role="cp"><primary>:fork:, setting up</primary></indexterm>This access method allows you to connect to a
repository on your local disk via the remote protocol.
In other words it does pretty much the same thing as
<command>:local:</command>, but various quirks, bugs and the like are
those of the remote cvsnt rather than the local
cvsnt.
    </para>

    <para>
For day-to-day operations you might prefer either
<command>:local:</command> or <command>:fork:</command>, depending on your
preferences.  Of course <command>:fork:</command> comes in
particularly handy in testing or
debugging <command>cvsnt</command> and the remote protocol.
Specifically, we avoid all of the network-related
setup/configuration, timeouts, and authentication
inherent in the other remote access methods but still
create a connection which uses the remote protocol.
    </para>

    <para>
To connect using the <command>fork</command> method, use
<command>:fork:</command> and the pathname to your local
repository.  For example:
    </para>

    <para><screen>cvs -d :fork:/usr/local/cvsroot checkout foo
</screen>    </para>
</sect2>
   <sect2 id="Repository-Alias">
    <title>Using repository aliases</title>
    <para><indexterm role="cp"><primary>Repository Prefix</primary></indexterm>
    	  <indexterm role="cp"><primary>Prefix, Repository</primary></indexterm>
    	  <indexterm role="cp"><primary>Repository Alias</primary></indexterm>
    	  <indexterm role="cp"><primary>Alias, Repository</primary></indexterm>
    </para>
    <para>
      Repository aliases hide the real paths to the repositories on the server behind virtual
      names.  The server information is hidden to clients which increases security and means
      the cvs root strings are independent of the server architecture.
    </para>
    <para>
      Aliases are normally specified in the <command>/etc/cvsnt/PServer</command> file on Unix, or in
      the Control Panel on NT.  Especially on NT is is recommended that aliases are used to avoid
      exposing NT drive letters to the clients.
     </para>
</sect2></sect1></chapter>
 <chapter id="Security">
  <title>Security
</title>
  <para><indexterm role="cp"><primary>Security (intro)</primary></indexterm><indexterm role="cp"><primary>Security, example</primary></indexterm>
A remote cvsnt <firstterm>repository</firstterm> can be set up to
have its own security system outside of the standard
security provided by the system.  This allows the
administrator to provide cvsnt accounts without
having to set up accounts on the system.  It also
provides some directory-level security.
  </para>

  <para>
This feature has only been checked with pserver.  It
may or may not work with kerberos.
  </para>

  <para>
To enable this feature, add the <command>-L</command> option to
the invokation from the <command>inetd.conf</command> file.  It
would be best to run the command as some user besides
root that will own the repository.
  </para>

  <para>
The provided security will only work at a directory
level.  Files cannot be individually protected with
this feature.
  </para>

  <sect1 id="Setting-up-security">
   <title>How to set up security
</title>

   <para>
Security is rather easy to set up.  First setup the
<command>inetd.conf</command> file to invoke cvs. 
Changing the base path as described in
<xref linkend="Repository-Alias" /> can be very convenient.
The command should run as the user that owns the
repository (not root).  
   </para>

   <para>
Next, running as the user that will own the repository,
create the repository.  Pick a user name to be the
administrator.  In the <command>CVSROOT</command> directory, create
a <command>passwd</command> file and add the administrator as
described in <xref linkend="Authentication-server" />.
You have to figure out a clever way of setting the
first password, such as using the <command>passwd</command> file on
your system to get the first password in for the admin.
   </para>

   <para>
Now create a file named <command>admin</command> and put the
administrators name in it on the first line.  Now check
both of these files in using rcs and add them to the
<command>checkoutlist</command> file as described in that file's
instructions.  Don't forget to check out the files
again after they have been checked in.
   </para>

   <para>
At this point, the administrator is ready to go.  Set
the environment variable to the repository (using the
pserver method) and log in.
   </para>

</sect1>
  <sect1 id="User-maintenance">
   <title>How to add and delete users
</title>

   <para>
The cvsnt password command can be used to add or delete
new users.  Only an administrator can do this.
   </para>

   <para>
Note that deleting a user does not remove them from any
user permissions.
   </para>

</sect1>
  <sect1 id="Setting-permissions">
   <title>Setting permissions for directories
</title>

   <para>
The owner of a file and the administrator can modify
directory permissions.  Three permissions are available:
   </para>

   <para><screen>c - create - create and delete files and directories
r - read   - retrieve file and look at information
w - write  - modify files and change information
n - none   - no access allowed
</screen>   </para>
   <para>
The owner and administrator have all these
capabilities.  Other users can be granted these
capabilities using the cvsnt chacl command.  It
takes a user name or 'default' and a set of permissions
separated by a colon then a list of directories to grant
permissions for.  So for instance:
   </para>
   <para><screen>
cvs chacl theuser:rw dir1 dir2 dir3
</screen>      </para>
   <para>
will grant the user named <command>theuser</command> read and write
access to the three specified directories.  Specifying
just the user or nothing after the colon will delete
all the user's permissions.
   </para>
   <para>
To view the current permissions the cvsnt lsacl
command can be used.  It will show the owner and all
the users that have permissions in the given
directories.
   </para>
   <para>
If the user name <command>default</command> is granted permissions,
those permissions will be given to all users of the
directory, if not overriden by other entries.  This
is an easy way to give everyone read
access to a directory, for instance.  If a users is
specifically in the permissions, the <command>default</command> will
not be applied to them, just the permissions in their
entry.
   </para>
   <para>
You can block access to a specific branch by specifying
the <command>-r</command> option to the chacl command.  This allows
you to stop checkins to a specific branch except by certain
users, for example during a code freeze.
   </para>
   <para>
For a user to have access to a directory, they must have
at least read access to all the directories above it.
If a user has an 'n' (no access) ACL on a parent directory
they cannot be granted access to directories below it.
   </para>
   <para>
The owner or a directory can be reassigned using the
cvsnt chown command.
   </para>
</sect1>
  <sect1 id="Setting-up-groups">
   <title>Groups of users can be assigned permissions
</title>

   <para>
Sometime administrators find it easier to maintain permissions on
groups of users instead of on individual users.  That way, if a group
of people have access to a directory, the group can be assigned rights
to the directories and the administrator only needs to modify the
members of the group to maintain the permissions.
   </para>

   <para>
The <command>group</command> file in the <command>CVSROOT</command> directory holds a list of
groups.  The file has two fields seperated by a colon, the first
is the group name, the second is a list of group members, separated
by white space, such as:
   </para>

   <para><screen>group1: user1 user2 user3
group2: me you dognamedblue
group3: peter paul mary
</screen>   </para>
   <para>
To set up groups, check out the <command>CVSROOT</command>
directory as the admin, create the <command>group</command> file,
add the groups, then check it in.  Then set up the
permissions for the groups, commit the changes, and you
are done.  It's that easy.  You should always access
the group file by checking out CVSROOT, accessing it
directly on the server can cause problems.
   </para>
   <para>
Repository administrators are automatically made a member
of the group 'admin'.  Don't list this group in the group file.
   </para>
</sect1>
  <sect1 id="Security-files">
   <title>Files in the repository
</title>

   <para>
Every directory in the repository will contain two
security files: the <command>owner</command> file and the
<command>perms</command> file.  The <command>owner</command> file contains the
name of the directory's owner.  The <command>perms</command> file
contains the permissions for other users.  These files
will not be checked out in any way, they stay internal
to the repository.  The repository owner can modify
these file if necessary; their format is
straightforward.
   </para>

</sect1>
<sect1 id="Runas-User">
<title>Running CVSNT as a nonprivileged user</title>
<para><indexterm role="cp"><primary>Security, running as a nonprivileged user</primary></indexterm>
Under the traditional CVS execution model, the server runs as the user checking in the file.  For
some security requirements this is inadequate, so CVSNT also provides a RunAsUser parameter (in the
<command>/etc/cvsnt/PServer</command> or the in the registry under Windows).  If this is set, the server always runs
as the specified user, who should be a nonprivileged user who has read/write access only to the repository files.
See also <xref linkend="Chroot" />.
</para>
</sect1>
<sect1 id="Chroot">
<title>Running within a chroot jail</title>
<para><indexterm role="cp"><primary>Security, running within a chroot jail</primary></indexterm>
On operating systems that support this operation, cvsnt provides the Chroot parameter (in the
<command>/etc/cvsnt/PServer</command> file).  After CVSNT has loaded it will perform the chroot just prior
to dropping privileges and before any filesystem operations.
</para>
<para>
The chroot jail must contain a /tmp directory for use by the server but does not need any binary or library directories. 
In the minimal (most secure) configuration it is impossible to run scripts of any kind.  Adding binaries/libraries to allow script
execution should be done with care.  Never add setuid binaries to a chroot jail as it may allow an attacker an avenue
to break out of it.
</para>
</sect1>
  <sect1 id="Passwords">
   <title>Setting and changing passwords
</title>

   <para>
Users can use the cvsnt passwd command with no
parameters to modify their passwords.  The
administrator can specify a user on the command line
to change their password.
   </para>

</sect1>
  <sect1 id="Administrators">
   <title>Repository administrators
</title>
   <para><indexterm role="cp"><primary>Repository administrators</primary></indexterm><indexterm role="cp"><primary>CVSROOT/admin</primary></indexterm>
If SystemAuth = Yes the user is considered to be an administrator
of they are listed in the CVSROOT/admin file or if they
are in the 'Administrators' group (NT) or 'cvsadmin' group (Unix).
   </para>

   <para>
If SystemAuth = No only the CVSROOT/admin file is checked.
   </para>

   <para>
The CVSROOT/admin file contains a list of usernames who are designated
repository administrators, one per line.  This file should *not* be
put under cvsnt control, as that would be a security risk.
   </para>

   <para>
Repository administrators are automatically made members of the group
'admin'.
   </para>

</sect1>
  <sect1 id="Read-only-access">
   <title>Read-only repository access
</title>
   <para><indexterm role="cp"><primary>Read-only repository access</primary></indexterm><indexterm role="cp"><primary>readers (admin file)</primary></indexterm><indexterm role="cp"><primary>writers (admin file)</primary></indexterm>
        It is possible to grant read-only repository
access to people using the password-authenticated
server (<xref linkend="Password-authenticated" />).  (The
other access methods do not have explicit support for
read-only users because those methods all assume login
access to the repository machine anyway, and therefore
the user can do whatever local file permissions allow
her to do.)
   </para>
        
   <para>
A user who has read-only access can do only
those cvsnt operations which do not modify the
repository, except for certain "administrative" files
(such as lock files and the history file).  It may be
desirable to use this feature in conjunction with
user-aliasing (<xref linkend="Authentication-server" />).
   </para>

   <para>
Unlike with previous versions of cvsnt, read-only
users should be able merely to read the repository, and
not to execute programs on the server or otherwise gain
unexpected levels of access.  Or to be more accurate,
the <emphasis>known</emphasis> holes have been plugged.  Because this
feature is new and has not received a comprehensive
security audit, you should use whatever level of
caution seems warranted given your attitude concerning
security.
   </para>
        
   <para>
There are two ways to specify read-only access
for a user: by inclusion, and by exclusion.
   </para>
        
   <para>
"Inclusion" means listing that user
specifically in the <command>$CVSROOT/CVSROOT/readers</command>
file, which is simply a newline-separated list of
users.  Here is a sample <command>readers</command> file:
   </para>

   <para><screen>melissa
splotnik
jrandom
</screen>   </para>
   <para>
(Don't forget the newline after the last user.)
   </para>
   <para>
"Exclusion" means explicitly listing everyone
who has <emphasis>write</emphasis> access--if the file
   </para>
   <para><screen>
$CVSROOT/CVSROOT/writers
</screen>      </para>

   <para>
exists, then only
those users listed in it have write access, and
everyone else has read-only access (of course, even the
read-only users still need to be listed in the
cvsnt <command>passwd</command> file).  The
<command>writers</command> file has the same format as the
<command>readers</command> file.
   </para>
        
   <para>
Note: if your cvsnt <command>passwd</command>
file maps cvs users onto system users (<xref linkend="Authentication-server" />), make sure you deny or grant
read-only access using the <emphasis>cvsnt</emphasis> usernames, not
the system usernames.  That is, the <command>readers</command> and
<command>writers</command> files contain cvs usernames, which may
or may not be the same as system usernames.
   </para>
        
   <para>
Here is a complete description of the server's
behavior in deciding whether to grant read-only or
read-write access:
   </para>
        
   <para>
If <command>readers</command> exists, and this user is
listed in it, then she gets read-only access.  Or if
<command>writers</command> exists, and this user is NOT listed in
it, then she also gets read-only access (this is true
even if <command>readers</command> exists but she is not listed
there).  Otherwise, she gets full read-write access.
   </para>
        
   <para>
Of course there is a conflict if the user is
listed in both files.  This is resolved in the more
conservative way, it being better to protect the
repository too much than too little: such a user gets
read-only access.
   </para>

</sect1>
  <sect1 id="Server-temporary-directory">
   <title>Temporary directories for the server
</title>
   <para><indexterm role="cp"><primary>Temporary directories, and server</primary></indexterm><indexterm role="cp"><primary>Server, temporary directories</primary></indexterm>
While running, the cvsnt server creates temporary
directories.  They are named
   </para>

   <para><screen>cvs-serv<varname>pid</varname>
</screen>   </para>

   <para>
where <varname>pid</varname> is the process identification number of
the server.  They are located in the directory
specified by the <command>TMPDIR</command> environment variable
(<xref linkend="Environment-variables" />), the <command>-T</command> global
option (<xref linkend="Global-options" />), or failing that
<command>/tmp</command>.
   </para>

   <para>
In most cases the server will remove the temporary
directory when it is done, whether it finishes normally
or abnormally.  However, there are a few cases in which
the server does not or cannot remove the temporary
directory, for example:
   </para>

   <itemizedlist mark="bullet">
    <listitem>
     <para>
If the server aborts due to an internal server error,
it may preserve the directory to aid in debugging
     </para>
</listitem>
    <listitem>
     <para>
If the server is killed in a way that it has no way of
cleaning up (most notably, <command>kill -KILL</command> on unix).
     </para>
</listitem>
    <listitem>
     <para>
If the system shuts down without an orderly shutdown,
which tells the server to clean up.
     </para></listitem></itemizedlist>
   <para>
In cases such as this, you will need to manually remove
the <command>cvs-serv<varname>pid</varname></command> directories.  As long as
there is no server running with process identification
number <varname>pid</varname>, it is safe to do so.
   </para>
</sect1>
<sect1 id="Lockserver">
<title>The CVSNT lockserver</title>
<para><indexterm role="cp"><primary>Lockserver</primary></indexterm>
<indexterm role="cp"><primary>cvslockd</primary></indexterm>
<indexterm role="cp"><primary>Lockserver, setting up</primary></indexterm>
<indexterm role="cp"><primary>Setting up the Lockserver</primary></indexterm>
In all recent versions of CVSNT the lockserver is the primary means of handling file
locking.  There should normally only be one lockserver, which may be shared by multiple
repositories.  Once running it should require little or no maintenence.
</para>
<para>
The lockserver provides file-level locking for the server, which allows much greater concurrency
than previous versions of CVS.  It also provides checkout atomicity which ensures that you always
get a coherent view of the repository.  The previous method of locking using directory locks on the filesystem is
now depreciated and should not be used as it does not have these advantages.
</para>
<para>
Setting up the lockserver under Windows is handled by the setup program and happens automatically.
Under Unix you need to arrange to run the <command>cvslockd</command> on startup - this varies between
versions.
</para>
</sect1>
</chapter>
 <chapter id="Starting-a-new-project">
  <title>Starting a project with CVS
</title>
  <para><indexterm role="cp"><primary>Starting a project with CVS</primary></indexterm><indexterm role="cp"><primary>Creating a project</primary></indexterm>
Because renaming files and moving them between
directories is somewhat inconvenient, the first thing
you do when you start a new project should be to think
through your file organization.  It is not impossible
to rename or move files, but it does increase the
potential for confusion and cvsnt does have some
quirks particularly in the area of renaming
directories.  <xref linkend="Moving-files" />.
  </para>

  <para>
What to do next depends on the situation at hand.
  </para>

  <sect1 id="Setting-up-the-files">
   <title>Setting up the files
</title>

   <para>
The first step is to create the files inside the repository.  This can
be done in a couple of different ways.
   </para>

   <sect2 id="From-files">
    <title>Creating a directory tree from a number of files
</title>
    <para><indexterm role="cp"><primary>Importing files</primary></indexterm>
When you begin using cvsnt, you will probably already have several
projects that can be
put under cvsnt control.  In these cases the easiest way is to use the
<command>import</command> command.  An example is probably the easiest way to
explain how to use it.  If the files you want to install in
cvsnt reside in <command><varname>wdir</varname></command>, and you want them to appear in the
repository as <command>$CVSROOT/yoyodyne/<varname>rdir</varname></command>, you can do this:
    </para>

    <para><screen>$ cd <varname>wdir</varname>
$ cvs import -m "Imported sources" yoyodyne/<varname>rdir</varname> yoyo start
</screen>    </para>
    <para>
Unless you supply a log message with the <command>-m</command>
flag, cvsnt starts an editor and prompts for a
message.  The string <command>yoyo</command> is a <firstterm>vendor tag</firstterm>,
and <command>start</command> is a <firstterm>release tag</firstterm>.  They may fill
no purpose in this context, but since cvsnt requires
them they must be present.  <xref linkend="Tracking-sources" />, for
more information about them.
    </para>
    <para>
You can now verify that it worked, and remove your
original source directory.
    </para>
    <para><screen>
$ cd ..
$ cvs checkout yoyodyne/<varname>rdir</varname>       # Explanation below
$ diff -r <varname>wdir</varname> yoyodyne/<varname>rdir</varname>
$ rm -r <varname>wdir</varname>
</screen>       </para>

    <para>
Erasing the original sources is a good idea, to make sure that you do
not accidentally edit them in <varname>wdir</varname>, bypassing cvsnt.
Of course, it would be wise to make sure that you have
a backup of the sources before you remove them.
    </para>

    <para>
The <command>checkout</command> command can either take a module
name as argument (as it has done in all previous
examples) or a path name relative to <command>$CVSROOT</command>,
as it did in the example above.
    </para>

    <para>
It is a good idea to check that the permissions
cvsnt sets on the directories inside <command>$CVSROOT</command>
are reasonable, and that they belong to the proper
groups.  <xref linkend="File-permissions" />.
    </para>

    <para>
If some of the files you want to import are binary, you
may want to use the wrappers features to specify which
files are binary and which are not.  <xref linkend="Wrappers" />.
    </para>

</sect2>
   <sect2 id="From-other-version-control-systems">
    <title>Creating Files From Other Version Control Systems
</title>
    <para><indexterm role="cp"><primary>Importing files, from other version control systems</primary></indexterm>
If you have a project which you are maintaining with
another version control system, such as rcs, you
may wish to put the files from that project into
cvsnt, and preserve the revision history of the
files.
    </para>

    <variablelist>
     <title><indexterm role="cp"><primary>rcs, importing files from</primary></indexterm></title>
     <varlistentry>
      <term>From rcs</term>
      <listitem>
       <para>
If you have been using rcs, find the rcs
files--usually a file named <command>foo.c</command> will have its
rcs file in <command>rcs/foo.c,v</command> (but it could be
other places; consult the rcs documentation for
details).  Then create the appropriate directories in
cvsnt if they do not already exist.  Then copy the
files into the appropriate directories in the cvsnt
repository (the name in the repository must be the name
of the source file with <command>,v</command> added; the files go
directly in the appropriate directory of the repository,
not in an <command>rcs</command> subdirectory).  This is one of the
few times when it is a good idea to access the cvsnt
repository directly, rather than using cvsnt
commands.  Then you are ready to check out a new
working directory.
       </para>

       <para>
The rcs file should not be locked when you move it
into cvsnt; if it is, cvsnt will have trouble
letting you operate on it.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term>From another version control system</term>
      <listitem>
       <para>
Many version control systems have the ability to export
rcs files in the standard format.  If yours does,
export the rcs files and then follow the above
instructions.
       </para>

       <para>
Failing that, probably your best bet is to write a
script that will check out the files one revision at a
time using the command line interface to the other
system, and then check the revisions into cvsnt.
The <command>sccs2rcs</command> script mentioned below may be a
useful example to follow.
       </para>

       <para><indexterm role="cp"><primary>SCCS, importing files from</primary></indexterm>       </para></listitem></varlistentry>
     <varlistentry>
      <term>From SCCS</term>
      <listitem>
       <para>
There is a script in the <command>contrib</command> directory of
the cvsnt source distribution called <command>sccs2rcs</command>
which converts sccs files to rcs files.
Note: you must run it on a machine which has both
sccs and rcs installed, and like everything
else in contrib it is unsupported (your mileage may
vary).
       </para>

       <para><indexterm role="cp"><primary>PVCS, importing files from</primary></indexterm>       </para></listitem></varlistentry>
     <varlistentry>
      <term>From PVCS</term>
      <listitem>
       <para>
There is a script in the <command>contrib</command> directory of
the cvsnt source distribution called <command>pvcs_to_rcs</command>
which converts pvcs archives to rcs files.
You must run it on a machine which has both
pvcs and rcs installed, and like everything
else in contrib it is unsupported (your mileage may
vary).  See the comments in the script for details.
       </para></listitem></varlistentry></variablelist>
</sect2>
   <sect2 id="From-scratch">
    <title>Creating a directory tree from scratch
</title>

    <para>
For a new project, the easiest thing to do is probably
to create an empty directory structure, like this:
    </para>

    <para><screen>$ mkdir tc
$ mkdir tc/man
$ mkdir tc/testing
</screen>    </para>
    <para>
After that, you use the <command>import</command> command to create
the corresponding (empty) directory structure inside
the repository:
    </para>
    <para><screen>
$ cd tc
$ cvs import -m "Created directory structure" yoyodyne/<varname>dir</varname> yoyo start
</screen>       </para>
    <para>
Then, use <command>add</command> to add files (and new directories)
as they appear.
    </para>
    <para>
Check that the permissions cvsnt sets on the
directories inside <command>$CVSROOT</command> are reasonable.
    </para>
</sect2></sect1>
  <sect1 id="Defining-the-module">
   <title>Defining the module
</title>
   <para><indexterm role="cp"><primary>Defining a module</primary></indexterm><indexterm role="cp"><primary>Editing the modules file</primary></indexterm><indexterm role="cp"><primary>Module, defining</primary></indexterm><indexterm role="cp"><primary>Modules file, changing</primary></indexterm>
The next step is to define the module in the
<command>modules</command> file.  This is not strictly necessary,
but modules can be convenient in grouping together
related files and directories.
   </para>

   <para>
In simple cases these steps are sufficient to define a module.
   </para>

   <orderedlist numeration="arabic">
    <listitem>
     <para>
Get a working copy of the modules file.
     </para>

     <para><screen>$ cvs checkout CVSROOT/modules
$ cd CVSROOT
</screen>          </para>
</listitem>
    <listitem>
     <para>
Edit the file and insert a line that defines the module.  <xref linkend="Intro-administrative-files" />, for an introduction.  <xref linkend="modules" />, for a full
description of the modules file.  You can use the
following line to define the module <command>tc</command>:
     </para>

     <para><screen>
tc   yoyodyne/tc
</screen>          </para>
</listitem>
    <listitem>
     <para>
Commit your changes to the modules file.
     </para>

     <para><screen>
$ cvs commit -m "Added the tc module." modules
</screen>          </para>
</listitem>
    <listitem>
     <para>
Release the modules module.
     </para>

     <para><screen>
$ cd ..
$ cvs release -d CVSROOT
</screen>          </para></listitem></orderedlist>

</sect1></chapter>
 <chapter id="Revisions">
  <title>Revisions
</title>

  <para>
For many uses of cvsnt, one doesn't need to worry
too much about revision numbers; cvsnt assigns
numbers such as <command>1.1</command>, <command>1.2</command>, and so on, and
that is all one needs to know.  However, some people
prefer to have more knowledge and control concerning
how cvsnt assigns revision numbers.
  </para>

  <para>
If one wants to keep track of a set of revisions
involving more than one file, such as which revisions
went into a particular release, one uses a <firstterm>tag</firstterm>,
which is a symbolic revision which can be assigned to a
numeric revision in each file.
  </para>

  <sect1 id="Revision-numbers">
   <title>Revision numbers
</title>
   <para><indexterm role="cp"><primary>Revision numbers</primary></indexterm><indexterm role="cp"><primary>Revision tree</primary></indexterm><indexterm role="cp"><primary>Linear development</primary></indexterm><indexterm role="cp"><primary>Number, revision-</primary></indexterm><indexterm role="cp"><primary>Decimal revision number</primary></indexterm><indexterm role="cp"><primary>Branch number</primary></indexterm><indexterm role="cp"><primary>Number, branch</primary></indexterm>
Each version of a file has a unique <firstterm>revision
number</firstterm>.  Revision numbers look like <command>1.1</command>,
<command>1.2</command>, <command>1.3.2.2</command> or even <command>1.3.2.2.4.5</command>.
A revision number always has an even number of
period-separated decimal integers.  By default revision
1.1 is the first revision of a file.  Each successive
revision is given a new number by increasing the
rightmost number by one.  The following figure displays
a few revisions, with newer revisions to the right.
   </para>

   <para><screen>       +-----+    +-----+    +-----+    +-----+    +-----+
       ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
       +-----+    +-----+    +-----+    +-----+    +-----+
</screen>   </para>
   <para>
It is also possible to end up with numbers containing
more than one period, for example <command>1.3.2.2</command>.  Such
revisions represent revisions on branches
(<xref linkend="Branching-and-merging" />); such revision numbers
are explained in detail in <xref linkend="Branches-and-revisions" />.
   </para>
</sect1>
  <sect1 id="Versions-revisions-releases">
   <title>Versions, revisions and releases
</title>
   <para><indexterm role="cp"><primary>Revisions, versions and releases</primary></indexterm><indexterm role="cp"><primary>Versions, revisions and releases</primary></indexterm><indexterm role="cp"><primary>Releases, revisions and versions</primary></indexterm>
A file can have several versions, as described above.
Likewise, a software product can have several versions.
A software product is often given a version number such
as <command>4.1.1</command>.
   </para>

   <para>
Versions in the first sense are called <firstterm>revisions</firstterm>
in this document, and versions in the second sense are
called <firstterm>releases</firstterm>.  To avoid confusion, the word
<firstterm>version</firstterm> is almost never used in this document.
   </para>

</sect1>
  <sect1 id="Assigning-revisions">
   <title>Assigning revisions
</title>

   <para>
By default, cvsnt will assign numeric revisions by
leaving the first number the same and incrementing the
second number.  For example, <command>1.1</command>, <command>1.2</command>,
<command>1.3</command>, etc.
   </para>

   <para>
When adding a new file, the second number will always
be one and the first number will equal the highest
first number of any file in that directory.  For
example, the current directory contains files whose
highest numbered revisions are <command>1.7</command>, <command>3.1</command>,
and <command>4.12</command>, then an added file will be given the
numeric revision <command>4.1</command>.
   </para>

   <para>
Normally there is no reason to care
about the revision numbers--it is easier to treat them
as internal numbers that cvsnt maintains, and tags
provide a better way to distinguish between things like
release 1 versus release 2 of your product
(<xref linkend="Tags" />).  However, if you want to set the
numeric revisions, the <command>-r</command> option to <command>cvs
commit</command> can do that.  The <command>-r</command> option implies the
<command>-f</command> option, in the sense that it causes the
files to be committed even if they are not modified.
   </para>

   <para>
For example, to bring all your files up to
revision 3.0 (including those that haven't changed),
you might invoke:
   </para>

   <para><screen>$ cvs commit -r 3.0
</screen>   </para>
   <para>
Note that the number you specify with <command>-r</command> must be
larger than any existing revision number.  That is, if
revision 3.0 exists, you cannot <command>cvs commit
-r 1.3</command>.  If you want to maintain several releases in
parallel, you need to use a branch (<xref linkend="Branching-and-merging" />).
   </para>
</sect1>
  <sect1 id="Tags">
   <title>Tags-Symbolic revisions
</title>
   <para><indexterm role="cp"><primary>Tags</primary></indexterm>
The revision numbers live a life of their own.  They
need not have anything at all to do with the release
numbers of your software product.  Depending
on how you use cvsnt the revision numbers might change several times
between two releases.  As an example, some of the
source files that make up rcs 5.6 have the following
revision numbers:
<indexterm role="cp"><primary>rcs revision numbers</primary></indexterm>
<screen>ci.c            5.21
co.c            5.9
ident.c         5.3
rcs.c           5.12
rcsbase.h       5.11
rcsdiff.c       5.10
rcsedit.c       5.11
rcsfcmp.c       5.9
rcsgen.c        5.10
rcslex.c        5.11
rcsmap.c        5.2
rcsutil.c       5.10
</screen>   </para>
   <para><indexterm role="cp"><primary>tag, command, introduction</primary></indexterm><indexterm role="cp"><primary>Tag, symbolic name</primary></indexterm><indexterm role="cp"><primary>Symbolic name (tag)</primary></indexterm><indexterm role="cp"><primary>Name, symbolic (tag)</primary></indexterm><indexterm role="cp"><primary>HEAD, as reserved tag name</primary></indexterm><indexterm role="cp"><primary>BASE, as reserved tag name</primary></indexterm>You can use the <command>tag</command> command to give a symbolic name to a
certain revision of a file.  You can use the <command>-v</command> flag to the
<command>status</command> command to see all tags that a file has, and
which revision numbers they represent.  Tag names must
start with an uppercase or lowercase letter and can
contain uppercase and lowercase letters, digits,
<command>-</command>, and <command>_</command>.  The two tag names <command>BASE</command>
and <command>HEAD</command> are reserved for use by cvsnt.  It
is expected that future names which are special to
cvsnt will be specially named, for example by
starting with <command>.</command>, rather than being named analogously to
<command>BASE</command> and <command>HEAD</command>, to avoid conflicts with
actual tag names.
   </para>
   <para>
You'll want to choose some convention for naming tags,
based on information such as the name of the program
and the version number of the release.  For example,
one might take the name of the program, immediately
followed by the version number with <command>.</command> changed to
<command>-</command>, so that cvsnt 1.9 would be tagged with the name
<command>cvs1-9</command>.  If you choose a consistent convention,
then you won't constantly be guessing whether a tag is
<command>cvs-1-9</command> or <command>cvs1_9</command> or what.  You might
even want to consider enforcing your convention in the
taginfo file (<xref linkend="user-defined-logging" />).
   </para>
   <para><indexterm role="cp"><primary>Adding a tag</primary></indexterm><indexterm role="cp"><primary>Tag, example</primary></indexterm>The following example shows how you can add a tag to a
file.  The commands must be issued inside your working
directory.  That is, you should issue the
command in the directory where <command>backend.c</command>
resides.
   </para>
   <para><screen>
$ cvs tag rel-0-4 backend.c
T backend.c
$ cvs status -v backend.c
===================================================================
File: backend.c         Status: Up-to-date

    Version:            1.4     Tue Dec  1 14:39:01 1992
    rcs Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
    Sticky Tag:         (none)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-0-4                     (revision: 1.4)

</screen>      </para>
   <para>
For a complete summary of the syntax of <command>cvs tag</command>,
including the various options, see <xref linkend="Invoking-CVS" />.
   </para>
   <para>
There is seldom reason to tag a file in isolation.  A more common use is
to tag all the files that constitute a module with the same tag at
strategic points in the development life-cycle, such as when a release
is made.
   </para>
   <para><screen>
$ cvs tag rel-1-0 .
cvs tag: Tagging .
T Makefile
T backend.c
T driver.c
T frontend.c
T parser.c
</screen>      </para>
   <para>
(When you give cvsnt a directory as argument, it generally applies the
operation to all the files in that directory, and (recursively), to any
subdirectories that it may contain.  <xref linkend="Recursive-behavior" />.)
   </para>
   <para><indexterm role="cp"><primary>Retrieving an old revision using tags</primary></indexterm><indexterm role="cp"><primary>Tag, retrieving old revisions</primary></indexterm>The <command>checkout</command> command has a flag, <command>-r</command>, that lets you check out
a certain revision of a module.  This flag makes it easy to
retrieve the sources that make up release 1.0 of the module <command>tc</command> at
any time in the future:
   </para>
   <para><screen>
$ cvs checkout -r rel-1-0 tc
</screen>      </para>

   <para>
This is useful, for instance, if someone claims that there is a bug in
that release, but you cannot find the bug in the current working copy.
   </para>

   <para>
You can also check out a module as it was at any given date.
<xref linkend="checkout-options" />.  When specifying <command>-r</command> to
any of these commands, you will need beware of sticky
tags; see <xref linkend="Sticky-tags" />.
   </para>

   <para>
When you tag more than one file with the same tag you
can think about the tag as "a curve drawn through a
matrix of filename vs. revision number."  Say we have 5
files with the following revisions:
   </para>

   <para><screen>
        file1   file2   file3   file4   file5

        1.1     1.1     1.1     1.1  /--1.1*      &lt;-*-  TAG
        1.2*-   1.2     1.2    -1.2*-
        1.3  \- 1.3*-   1.3   / 1.3
        1.4          \  1.4  /  1.4
                      \-1.5*-   1.5
                        1.6
     </screen>   </para>

   <para>
At some time in the past, the <command>*</command> versions were tagged.
You can think of the tag as a handle attached to the curve
drawn through the tagged revisions.  When you pull on
the handle, you get all the tagged revisions.  Another
way to look at it is that you "sight" through a set of
revisions that is "flat" along the tagged revisions,
like this:
   </para>

   <para><screen>
        file1   file2   file3   file4   file5

                        1.1
                        1.2
                1.1     1.3                       _
        1.1     1.2     1.4     1.1              /
        1.2*----1.3*----1.5*----1.2*----1.1     (--- &lt;--- Look here
        1.3             1.6     1.3              \_
        1.4                     1.4
                                1.5
     </screen>   </para>

</sect1>
  <sect1 id="Tagging-the-working-directory">
   <title>Specifying what to tag from the working directory
</title>

   <para><indexterm role="cp"><primary>tag (subcommand)</primary></indexterm>The example in the previous section demonstrates one of
the most common ways to choose which revisions to tag.
Namely, running the <command>cvs tag</command> command without
arguments causes cvsnt to select the revisions which
are checked out in the current working directory.  For
example, if the copy of <command>backend.c</command> in working
directory was checked out from revision 1.4, then
cvsnt will tag revision 1.4.  Note that the tag is
applied immediately to revision 1.4 in the repository;
tagging is not like modifying a file, or other
operations in which one first modifies the working
directory and then runs <command>cvs commit</command> to transfer
that modification to the repository.
   </para>

   <para>
One potentially surprising aspect of the fact that
<command>cvs tag</command> operates on the repository is that you
are tagging the checked-in revisions, which may differ
from locally modified files in your working directory.
If you want to avoid doing this by mistake, specify the
<command>-c</command> option to <command>cvs tag</command>.  If there are any
locally modified files, cvsnt will abort with an
error before it tags any files:
   </para>

   <para><screen>$ cvs tag -c rel-0-4
cvs tag: backend.c is locally modified
cvs [tag aborted]: correct the above errors first!
</screen>   </para>
</sect1>
  <sect1 id="Tagging-by-date-tag">
   <title>Specifying what to tag by date or revision
</title>
   <para><indexterm role="cp"><primary>rtag (subcommand)</primary></indexterm>
The <command>cvs rtag</command> command tags the repository as of a
certain date or time (or can be used to tag the latest
revision).  <command>rtag</command> works directly on the
repository contents (it requires no prior checkout and
does not look for a working directory).
   </para>

   <para>
The following options specify which date or revision to
tag.  See <xref linkend="Common-options" />, for a complete
description of them.
   </para>

   <variablelist>
    <varlistentry>
     <term><command>-D <varname>date</varname></command></term>
     <listitem>
      <para>
Tag the most recent revision no later than <varname>date</varname>.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-f</command></term>
     <listitem>
      <para>
Only useful with the <command>-D <varname>date</varname></command> or <command>-r <varname>tag</varname></command>
flags.  If no matching revision is found, use the most
recent revision (instead of ignoring the file).
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-r <varname>tag</varname></command></term>
     <listitem>
      <para>
Only tag those files that contain existing tag <varname>tag</varname>.
      </para></listitem></varlistentry></variablelist>
   <para>
The <command>cvs tag</command> command also allows one to specify
files by revision or date, using the same <command>-r</command>,
<command>-D</command>, and <command>-f</command> options.  However, this
feature is probably not what you want.  The reason is
that <command>cvs tag</command> chooses which files to tag based on
the files that exist in the working directory, rather
than the files which existed as of the given tag/date.
Therefore, you are generally better off using <command>cvs
rtag</command>.  The exceptions might be cases like:
   </para>
   <para><screen>
cvs tag -r 1.4 backend.c
</screen>      </para>
</sect1>
  <sect1 id="Modifying-tags">
   <title>Deleting, moving, and renaming tags
</title>


   <para>
Normally one does not modify tags.  They exist in order
to record the history of the repository and so deleting
them or changing their meaning would, generally, not be
what you want.
   </para>

   <para>
However, there might be cases in which one uses a tag
temporarily or accidentally puts one in the wrong
place.  Therefore, one might delete, move, or rename a
tag.  Warning: the commands in this section are
dangerous; they permanently discard historical
information and it can difficult or impossible to
recover from errors.  If you are a cvsnt
administrator, you may consider restricting these
commands with taginfo (<xref linkend="user-defined-logging" />).
   </para>

   <para><indexterm role="cp"><primary>Deleting tags</primary></indexterm><indexterm role="cp"><primary>Removing tags</primary></indexterm><indexterm role="cp"><primary>Tags, deleting</primary></indexterm>To delete a tag, specify the <command>-d</command> option to either
<command>cvs tag</command> or <command>cvs rtag</command>.  For example:
   </para>

   <para><screen>cvs rtag -d rel-0-4 tc
</screen>   </para>
   <para>
deletes the tag <command>rel-0-4</command> from the module <command>tc</command>.
   </para>
   <para><indexterm role="cp"><primary>Moving tags</primary></indexterm><indexterm role="cp"><primary>Tags, moving</primary></indexterm>When we say <firstterm>move</firstterm> a tag, we mean to make the same
name point to different revisions.  For example, the
<command>stable</command> tag may currently point to revision 1.4
of <command>backend.c</command> and perhaps we want to make it
point to revision 1.6.  To move a tag, specify the
<command>-F</command> option to either <command>cvs tag</command> or <command>cvs
rtag</command>.  For example, the task just mentioned might be
accomplished as:
   </para>
   <para><screen>
cvs tag -r 1.6 -F stable backend.c
</screen>      </para>
   <para>
By default CVS doesn't allow moving and deleting branch tags, as
this should not be done without understanding the issues that this
raises.  To override this, specify the <command>-B</command> option on the command line.
   </para>
   <para><indexterm role="cp"><primary>Renaming tags</primary></indexterm><indexterm role="cp"><primary>Tags, renaming</primary></indexterm>When we say <firstterm>rename</firstterm> a tag, we mean to make a
different name point to the same revisions as the old
tag.  For example, one may have misspelled the tag name
and want to correct it (hopefully before others are
relying on the old spelling).  To rename a tag, first
create a new tag using the <command>-r</command> option to
<command>cvs rtag</command>, and then delete the old name.  This
leaves the new tag on exactly the same files as the old
tag.  For example:
   </para>
   <para><screen>
cvs rtag -r old-name-0-4 rel-0-4 tc
cvs rtag -d old-name-0-4 tc
</screen>      </para>
</sect1>
  <sect1 id="Tagging-add-remove">
   <title>Tagging and adding and removing files
</title>

   <para>
The subject of exactly how tagging interacts with
adding and removing files is somewhat obscure; for the
most part cvsnt will keep track of whether files
exist or not without too much fussing.  By default,
tags are applied to only files which have a revision
corresponding to what is being tagged.  Files which did
not exist yet, or which were already removed, simply
omit the tag, and cvsnt knows to treat the absence
of a tag as meaning that the file didn't exist as of
that tag.
   </para>

   <para>
However, this can lose a small amount of information.
For example, suppose a file was added and then removed.
Then, if the tag is missing for that file, there is no
way to know whether the tag refers to the time before
the file was added, or the time after it was removed.
If you specify the <command>-r</command> option to <command>cvs rtag</command>,
then cvsnt tags the files which have been removed,
and thereby avoids this problem.  For example, one
might specify <command>-r HEAD</command> to tag the head.
   </para>

</sect1>
<sect1 id="Alias-Tags">
  <title>Alias tags</title>
  <para><indexterm role="cp"><primary>Alias tags</primary></indexterm>
  	<indexterm role="cp"><primary>Tags, alias</primary></indexterm>
  </para>
  <para>
    Normally setting a tag equal to a branch with the <command>-r</command> causes
    the tag to be set to the revison at the head of the branch at that point.  The
    <command>-A</command> option to tag and rtag changes this behaviour so that the
    new tag becomes an alias name for the existing branch.
  </para>
</sect1>
  <sect1 id="Sticky-tags">
   <title>Sticky tags
</title>
   <para><indexterm role="cp"><primary>Sticky tags</primary></indexterm><indexterm role="cp"><primary>Tags, sticky</primary></indexterm>
   </para>

   <para>
Sometimes a working copy's revision has extra data
associated with it, for example it might be on a branch
(<xref linkend="Branching-and-merging" />), or restricted to
versions prior to a certain date by <command>checkout -D</command>
or <command>update -D</command>.  Because this data persists -
that is, it applies to subsequent commands in the
working copy - we refer to it as <firstterm>sticky</firstterm>.
   </para>

   <para>
Most of the time, stickiness is an obscure aspect of
cvsnt that you don't need to think about.  However,
even if you don't want to use the feature, you may need
to know <emphasis>something</emphasis> about sticky tags (for
example, how to avoid them!).
   </para>

   <para>
You can use the <command>status</command> command to see if any
sticky tags or dates are set:
   </para>

   <para><screen>$ cvs status driver.c
===================================================================
File: driver.c          Status: Up-to-date

    Version:            1.7.2.1 Sat Dec  5 19:35:03 1992
    rcs Version:        1.7.2.1 /u/cvsroot/yoyodyne/tc/driver.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

</screen>   </para>
   <para><indexterm role="cp"><primary>Resetting sticky tags</primary></indexterm><indexterm role="cp"><primary>Sticky tags, resetting</primary></indexterm><indexterm role="cp"><primary>Deleting sticky tags</primary></indexterm>The sticky tags will remain on your working files until
you delete them with <command>cvs update -A</command>.  The
<command>-A</command> option retrieves the version of the file from
the head of the trunk, and forgets any sticky tags,
dates, or options.
   </para>
   <para><indexterm role="cp"><primary>Sticky date</primary></indexterm>The most common use of sticky tags is to identify which
branch one is working on, as described in
<xref linkend="Accessing-branches" />.  However, non-branch
sticky tags have uses as well.  For example,
suppose that you want to avoid updating your working
directory, to isolate yourself from possibly
destabilizing changes other people are making.  You
can, of course, just refrain from running <command>cvs
update</command>.  But if you want to avoid updating only a
portion of a larger tree, then sticky tags can help.
If you check out a certain revision (such as 1.4) it
will become sticky.  Subsequent <command>cvs update</command>
commands will
not retrieve the latest revision until you reset the
tag with <command>cvs update -A</command>.  Likewise, use of the
<command>-D</command> option to <command>update</command> or <command>checkout</command>
sets a <firstterm>sticky date</firstterm>, which, similarly, causes that
date to be used for future retrievals.
   </para>
   <para>
People often want to retrieve an old version of
a file without setting a sticky tag.  This can
be done with the <command>-p</command> option to <command>checkout</command> or
<command>update</command>, which sends the contents of the file to
standard output.  For example:
<screen>
$ cvs update -p -r 1.1 file1 &gt;file1
===================================================================
Checking out file1
rcs:  /tmp/cvs-sanity/cvsroot/first-dir/Attic/file1,v
VERS: 1.1
***************
$
</screen>      </para>
   <para>
However, this isn't the easiest way, if you are asking
how to undo a previous checkin (in this example, put
<command>file1</command> back to the way it was as of revision
1.1).  In that case you are better off using the
<command>-j</command> option to <command>update</command>; for further
discussion see <xref linkend="Merging-two-revisions" />.
   </para>
</sect1></chapter>
 <chapter id="Branching-and-merging">
  <title>Branching and merging
</title>
  <para><indexterm role="cp"><primary>Branching</primary></indexterm><indexterm role="cp"><primary>Merging</primary></indexterm><indexterm role="cp"><primary>Copying changes</primary></indexterm><indexterm role="cp"><primary>Main trunk and branches</primary></indexterm><indexterm role="cp"><primary>Revision tree, making branches</primary></indexterm><indexterm role="cp"><primary>Branches, copying changes between</primary></indexterm><indexterm role="cp"><primary>Changes, copying between branches</primary></indexterm><indexterm role="cp"><primary>Modifications, copying between branches</primary></indexterm>
cvsnt allows you to isolate changes onto a separate
line of development, known as a <firstterm>branch</firstterm>.  When you
change files on a branch, those changes do not appear
on the main trunk or other branches.
  </para>

  <para>
Later you can move changes from one branch to another
branch (or the main trunk) by <firstterm>merging</firstterm>.  Merging
involves first running <command>cvs update -j</command>, to merge
the changes into the working directory.
You can then commit that revision, and thus effectively
copy the changes onto another branch.
  </para>

  <sect1 id="Branches-motivation">
   <title>What branches are good for
</title>
   <para><indexterm role="cp"><primary>Branches motivation</primary></indexterm><indexterm role="cp"><primary>What branches are good for</primary></indexterm><indexterm role="cp"><primary>Motivation for branches</primary></indexterm>
Suppose that release 1.0 of tc has been made.  You are continuing to
develop tc, planning to create release 1.1 in a couple of months.  After a
while your customers start to complain about a fatal bug.  You check
out release 1.0 (<xref linkend="Tags" />) and find the bug
(which turns out to have a trivial fix).  However, the current revision
of the sources are in a state of flux and are not expected to be stable
for at least another month.  There is no way to make a
bugfix release based on the newest sources.
   </para>

   <para>
The thing to do in a situation like this is to create a <firstterm>branch</firstterm> on
the revision trees for all the files that make up
release 1.0 of tc.  You can then make
modifications to the branch without disturbing the main trunk.  When the
modifications are finished you can elect to either incorporate them on
the main trunk, or leave them on the branch.
   </para>

</sect1>
  <sect1 id="Creating-a-branch">
   <title>Creating a branch
</title>
   <para><indexterm role="cp"><primary>Creating a branch</primary></indexterm><indexterm role="cp"><primary>Branch, creating a</primary></indexterm><indexterm role="cp"><primary>tag, creating a branch using</primary></indexterm><indexterm role="cp"><primary>rtag, creating a branch using</primary></indexterm>
You can create a branch with <command>tag -b</command>; for
example, assuming you're in a working copy:
   </para>

   <para><screen>$ cvs tag -b rel-1-0-patches
</screen>   </para>
   <para>
This splits off a branch based on the current revisions
in the working copy, assigning that branch the name
<command>rel-1-0-patches</command>.
   </para>
   <para>
It is important to understand that branches get created
in the repository, not in the working copy.  Creating a
branch based on current revisions, as the above example
does, will <emphasis>not</emphasis> automatically switch the working
copy to be on the new branch.  For information on how
to do that, see <xref linkend="Accessing-branches" />.
   </para>
   <para>
You can also create a branch without reference to any
working copy, by using <command>rtag</command>:
   </para>
   <para><screen>
$ cvs rtag -b -r rel-1-0 rel-1-0-patches tc
</screen>      </para>
   <para><command>-r rel-1-0</command> says that this branch should be
rooted at the revision that
corresponds to the tag <command>rel-1-0</command>.  It need not
be the most recent revision - it's often useful to
split a branch off an old revision (for example, when
fixing a bug in a past release otherwise known to be
stable).
   </para>
   <para>
As with <command>tag</command>, the <command>-b</command> flag tells
<command>rtag</command> to create a branch (rather than just a
symbolic revision name).  Note that the numeric
revision number that matches <command>rel-1-0</command> will
probably be different from file to file.
   </para>
   <para>
So, the full effect of the command is to create a new
branch - named <command>rel-1-0-patches</command> - in module
<command>tc</command>, rooted in the revision tree at the point tagged
by <command>rel-1-0</command>.
   </para>
</sect1>
  <sect1 id="Accessing-branches">
   <title>Accessing branches
</title>
   <para><indexterm role="cp"><primary>Check out a branch</primary></indexterm><indexterm role="cp"><primary>Retrieve a branch</primary></indexterm><indexterm role="cp"><primary>Access a branch</primary></indexterm><indexterm role="cp"><primary>Identifying a branch</primary></indexterm><indexterm role="cp"><primary>Branch, check out</primary></indexterm><indexterm role="cp"><primary>Branch, retrieving</primary></indexterm><indexterm role="cp"><primary>Branch, accessing</primary></indexterm><indexterm role="cp"><primary>Branch, identifying</primary></indexterm>
You can retrieve a branch in one of two ways: by
checking it out fresh from the repository, or by
switching an existing working copy over to the branch.
   </para>

   <para>
To check out a branch from the repository, invoke
<command>checkout</command> with the <command>-r</command> flag, followed by
the tag name of the branch (<xref linkend="Creating-a-branch" />):
   </para>

   <para><screen>$ cvs checkout -r rel-1-0-patches tc
</screen>   </para>
   <para>
Or, if you already have a working copy, you can switch
it to a given branch with <command>update -r</command>:
   </para>
   <para><screen>
$ cvs update -r rel-1-0-patches tc
</screen>      </para>
   <para>
or equivalently:
   </para>
   <para><screen>
$ cd tc
$ cvs update -r rel-1-0-patches
</screen>      </para>
   <para>
It does not matter if the working copy was originally
on the main trunk or on some other branch - the above
command will switch it to the named branch.  And
similarly to a regular <command>update</command> command,
<command>update -r</command> merges any changes you have made,
notifying you of conflicts where they occur.
   </para>
   <para>
Once you have a working copy tied to a particular
branch, it remains there until you tell it otherwise.
This means that changes checked in from the working
copy will add new revisions on that branch, while
leaving the main trunk and other branches unaffected.
   </para>
   <para><indexterm role="cp"><primary>Branches, sticky</primary></indexterm>To find out what branch a working copy is on, you can
use the <command>status</command> command.  In its output, look for
the field named <command>Sticky tag</command> (<xref linkend="Sticky-tags" />)
- that's cvsnt's way of telling you the branch, if
any, of the current working files:
   </para>
   <para><screen>
$ cvs status -v driver.c backend.c
===================================================================
File: driver.c          Status: Up-to-date

    Version:            1.7     Sat Dec  5 18:25:54 1992
    rcs Version:        1.7     /u/cvsroot/yoyodyne/tc/driver.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-1-0-patches             (branch: 1.7.2)
        rel-1-0                     (revision: 1.7)

===================================================================
File: backend.c         Status: Up-to-date

    Version:            1.4     Tue Dec  1 14:39:01 1992
    rcs Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
    Sticky Tag:         rel-1-0-patches (branch: 1.4.2)
    Sticky Date:        (none)
    Sticky Options:     (none)

    Existing Tags:
        rel-1-0-patches             (branch: 1.4.2)
        rel-1-0                     (revision: 1.4)
        rel-0-4                     (revision: 1.4)

</screen>      </para>
   <para>
Don't be confused by the fact that the branch numbers
for each file are different (<command>1.7.2</command> and
<command>1.4.2</command> respectively).  The branch tag is the
same, <command>rel-1-0-patches</command>, and the files are
indeed on the same branch.  The numbers simply reflect
the point in each file's revision history at which the
branch was made.  In the above example, one can deduce
that <command>driver.c</command> had been through more changes than
<command>backend.c</command> before this branch was created.
   </para>
   <para>
See <xref linkend="Branches-and-revisions" /> for details about how
branch numbers are constructed.
   </para>
</sect1>
  <sect1 id="Branches-and-revisions">
   <title>Branches and revisions
</title>
   <para><indexterm role="cp"><primary>Branch number</primary></indexterm><indexterm role="cp"><primary>Number, branch</primary></indexterm><indexterm role="cp"><primary>Revision numbers (branches)</primary></indexterm>
Ordinarily, a file's revision history is a linear
series of increments (<xref linkend="Revision-numbers" />):
   </para>

   <para><screen>       +-----+    +-----+    +-----+    +-----+    +-----+
       ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
       +-----+    +-----+    +-----+    +-----+    +-----+
</screen>   </para>
   <para>
However, cvsnt is not limited to linear development.  The
<firstterm>revision tree</firstterm> can be split into <firstterm>branches</firstterm>,
where each branch is a self-maintained line of
development.  Changes made on one branch can easily be
moved back to the main trunk.
   </para>
   <para>
Each branch has a <firstterm>branch number</firstterm>, consisting of an
odd number of period-separated decimal integers.  The
branch number is created by appending an integer to the
revision number where the corresponding branch forked
off.  Having branch numbers allows more than one branch
to be forked off from a certain revision.
   </para>
   <para>
All revisions on a branch have revision numbers formed
by appending an ordinal number to the branch number.
The following figure illustrates branching with an
example.
   </para>
   <para><screen>
                                                      +-------------+
                           Branch 1.2.2.3.2 -&gt;        ! 1.2.2.3.2.1 !
                                                    / +-------------+
                                                   /
                                                  /
                 +---------+    +---------+    +---------+
Branch 1.2.2 -&gt; _! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
               / +---------+    +---------+    +---------+
              /
             /
+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !  &lt;- The main trunk
+-----+    +-----+    +-----+    +-----+    +-----+
                !
                !
                !   +---------+    +---------+    +---------+
Branch 1.2.4 -&gt; +---! 1.2.4.1 !----! 1.2.4.2 !----! 1.2.4.3 !
                    +---------+    +---------+    +---------+

     </screen>   </para>
   <para>
The exact details of how the branch number is
constructed is not something you normally need to be
concerned about, but here is how it works: When
cvsnt creates a branch number it picks the first
unused even integer, starting with 2.  So when you want
to create a branch from revision 6.4 it will be
numbered 6.4.2.  All branch numbers ending in a zero
(such as 6.4.0) are used internally by cvsnt
(<xref linkend="Magic-branch-numbers" />).  The branch 1.1.1 has a
special meaning.  <xref linkend="Tracking-sources" />.
   </para>
</sect1>
  <sect1 id="Magic-branch-numbers">
   <title>Magic branch numbers
</title>


   <para>
This section describes a cvsnt feature called
<firstterm>magic branches</firstterm>.  For most purposes, you need not
worry about magic branches; cvsnt handles them for
you.  However, they are visible to you in certain
circumstances, so it may be useful to have some idea of
how it works.
   </para>

   <para>
Externally, branch numbers consist of an odd number of
dot-separated decimal integers.  <xref linkend="Revision-numbers" />.  That is not the whole truth, however.  For
efficiency reasons cvsnt sometimes inserts an extra 0
in the second rightmost position (1.2.4 becomes
1.2.0.4, 8.9.10.11.12 becomes 8.9.10.11.0.12 and so
on).
   </para>

   <para>
cvsnt does a pretty good job at hiding these so
called magic branches, but in a few places the hiding
is incomplete:
   </para>

   <itemizedlist mark="bullet">
    <listitem>
     <para>
The magic branch number appears in the output from
<command>cvs log</command>.
     </para>
</listitem>
    <listitem>
     <para>
You cannot specify a symbolic branch name to <command>cvs
admin</command>.
     </para>
</listitem></itemizedlist>
   <para>
You can use the <command>admin</command> command to reassign a
symbolic name to a branch the way rcs expects it
to be.  If <command>R4patches</command> is assigned to the branch
1.4.2 (magic branch number 1.4.0.2) in file
<command>numbers.c</command> you can do this:
   </para>
   <para><screen>
$ cvs admin -NR4patches:1.4.2 numbers.c
</screen>      </para>
   <para>
It only works if at least one revision is already
committed on the branch.  Be very careful so that you
do not assign the tag to the wrong number.  (There is
no way to see how the tag was assigned yesterday).
   </para>
</sect1>
  <sect1 id="Merging-a-branch">
   <title>Merging an entire branch
</title>
   <para><indexterm role="cp"><primary>Merging a branch</primary></indexterm><indexterm role="cp"><primary>-j (merging branches)</primary></indexterm>
You can merge changes made on a branch into your working copy by giving
the <command>-j <varname>branchname</varname></command> flag to the <command>update</command> subcommand.  With one
<command>-j <varname>branchname</varname></command> option it merges the changes made between the
point where the branch was last merged and newest revision on that branch (into
your working copy).
   </para>

   <para>
If you wish to revert to the older CVS behaviour of merging from the point the branch
forked, specify the <command>-b</command> option.
   </para>

   <para>
If you are updating from an Unix CVS server of older cvsnt server that doesn't support
merge points, then the merge will always be done from the branch point.
   </para>

   <para><indexterm role="cp"><primary>Join</primary></indexterm>The <command>-j</command> stands for "join".
   </para>

   <para><indexterm role="cp"><primary>Branch merge example</primary></indexterm><indexterm role="cp"><primary>Example, branch merge</primary></indexterm><indexterm role="cp"><primary>Merge, branch example</primary></indexterm>Consider this revision tree:
   </para>

   <para><screen>+-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !      &lt;- The main trunk
+-----+    +-----+    +-----+    +-----+
                !
                !
                !   +---------+    +---------+
Branch R1fix -&gt; +---! 1.2.2.1 !----! 1.2.2.2 !
                    +---------+    +---------+
</screen>   </para>

   <para>
The branch 1.2.2 has been given the tag (symbolic name) <command>R1fix</command>.  The
following example assumes that the module <command>mod</command> contains only one
file, <command>m.c</command>.
   </para>

   <para><screen>
$ cvs checkout mod               # Retrieve the latest revision, 1.4

$ cvs update -j R1fix m.c        # Merge all changes made on the branch,
                                 # i.e. the changes between revision 1.2
                                 # and 1.2.2.2, into your working copy
                                 # of the file.

$ cvs commit -m "Included R1fix" # Create revision 1.5.
</screen>   </para>
   <para>
A conflict can result from a merge operation.  If that
happens, you should resolve it before committing the
new revision.  <xref linkend="Conflicts-example" />.
   </para>
   <para>
If your source files contain keywords (<xref linkend="Keyword-substitution" />),
you might be getting more conflicts than strictly necessary.  See
<xref linkend="Merging-and-keywords" />, for information on how to avoid this.
   </para>
   <para>
The <command>checkout</command> command also supports the <command>-j <varname>branchname</varname></command> flag.  The
same effect as above could be achieved with this:
   </para>
   <para><screen>
$ cvs checkout -j R1fix mod
$ cvs commit -m "Included R1fix"
</screen>      </para>
   <para>
It should be noted that <command>update -j <varname>tagname</varname></command> will also work but may
not produce the desired result.  <xref linkend="Merging-adds-and-removals" />, for more.
   </para>
</sect1>
  <sect1 id="Merging-more-than-once">
   <title>Merging from a branch several times
</title>

   <para>
Continuing our example, the revision tree now looks
like this:
   </para>

   <para><screen>+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   &lt;- The main trunk
+-----+    +-----+    +-----+    +-----+    +-----+
                !                           *
                !                          *
                !   +---------+    +---------+
Branch R1fix -&gt; +---! 1.2.2.1 !----! 1.2.2.2 !
                    +---------+    +---------+
</screen>   </para>
   <para>
where the starred line represents the merge from the
<command>R1fix</command> branch to the main trunk, as just
discussed.
   </para>
   <para>
Now suppose that development continues on the
<command>R1fix</command> branch:
   </para>
   <para><screen>
+-----+    +-----+    +-----+    +-----+    +-----+
! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   &lt;- The main trunk
+-----+    +-----+    +-----+    +-----+    +-----+
                !                           *
                !                          *
                !   +---------+    +---------+    +---------+
Branch R1fix -&gt; +---! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                    +---------+    +---------+    +---------+
</screen>      </para>
   <para>
and then you want to merge those new changes onto the
main trunk.  If you just use the <command>cvs update -j
R1fix m.c</command> command again, cvsnt will attempt to
merge again the changes which you have already merged,
which can have undesirable side effects.
   </para>
   <para>
So instead you need to specify that you only want to
merge the changes on the branch which have not yet been
merged into the trunk.  To do that you specify two
<command>-j</command> options, and cvsnt merges the changes from
the first revision to the second revision.  For
example, in this case the simplest way would be
   </para>
   <para><screen>
cvs update -j 1.2.2.2 -j R1fix m.c    # Merge changes from 1.2.2.2 to the
                                      # head of the R1fix branch
</screen>      </para>
   <para>
The problem with this is that you need to specify the
1.2.2.2 revision manually.  A slightly better approach
might be to use the date the last merge was done:
   </para>
   <para><screen>
cvs update -j R1fix:yesterday -j R1fix m.c
</screen>      </para>
   <para>
Better yet, tag the R1fix branch after every merge into
the trunk, and then use that tag for subsequent merges:
   </para>
   <para><screen>
cvs update -j merged_from_R1fix_to_trunk -j R1fix m.c
</screen>      </para>
</sect1>
  <sect1 id="Merging-two-revisions">
   <title>Merging differences between any two revisions
</title>
   <para><indexterm role="cp"><primary>Merging two revisions</primary></indexterm><indexterm role="cp"><primary>Revisions, merging differences between</primary></indexterm><indexterm role="cp"><primary>Differences, merging</primary></indexterm>
With two <command>-j <varname>revision</varname></command> flags, the <command>update</command>
(and <command>checkout</command>) command can merge the differences
between any two revisions into your working file.
   </para>

   <para><indexterm role="cp"><primary>Undoing a change</primary></indexterm><indexterm role="cp"><primary>Removing a change</primary></indexterm><screen>$ cvs update -j 1.5 -j 1.3 backend.c
</screen>   </para>

   <para>
will undo all changes made between revision
1.3 and 1.5.  Note the order of the revisions!
   </para>

   <para>
If you try to use this option when operating on
multiple files, remember that the numeric revisions will
probably be very different between the various files.
You almost always use symbolic
tags rather than revision numbers when operating on
multiple files.
   </para>

   <para><indexterm role="cp"><primary>Restoring old version of removed file</primary></indexterm><indexterm role="cp"><primary>Resurrecting old version of dead file</primary></indexterm>Specifying two <command>-j</command> options can also undo file
removals or additions.  For example, suppose you have
a file
named <command>file1</command> which existed as revision 1.1, and
you then removed it (thus adding a dead revision 1.2).
Now suppose you want to add it again, with the same
contents it had previously.  Here is how to do it:
   </para>

   <para><screen>
$ cvs update -j 1.2 -j 1.1 file1
U file1
$ cvs commit -m test
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  &lt;--  file1
new revision: 1.3; previous revision: 1.2
done
$
</screen>   </para>
</sect1>
  <sect1 id="Merging-adds-and-removals">
   <title>Merging can add or remove files
</title>

   <para>
If the changes which you are merging involve removing
or adding some files, <command>update -j</command> will reflect
such additions or removals.
   </para>

   <para>
For example:
<screen>cvs update -A
touch a b c
cvs add a b c ; cvs ci -m "added" a b c
cvs tag -b branchtag
cvs update -r branchtag
touch d ; cvs add d
rm a ; cvs rm a
cvs ci -m "added d, removed a"
cvs update -A
cvs update -jbranchtag
</screen>   </para>
   <para>
After these commands are executed and a <command>cvs commit</command> is done,
file <command>a</command> will be removed and file <command>d</command> added in the main branch.
   </para>
   <para>
Note that using a single static tag (<command>-j <varname>tagname</varname></command>)
rather than a dynamic tag (<command>-j <varname>branchname</varname></command>) to merge
changes from a branch will usually not remove files which were removed on the
branch since cvsnt does not automatically add static tags to dead revisions.
The exception to this rule occurs when
a static tag has been attached to a dead revision manually.  Use the branch tag
to merge all changes from the branch or use two static tags as merge endpoints
to be sure that all intended changes are propogated in the merge.
   </para>
</sect1>
  <sect1 id="Merging-and-keywords">
   <title>Merging and keywords
</title>
   <para><indexterm role="cp"><primary>Merging, and keyword substitution</primary></indexterm><indexterm role="cp"><primary>Keyword substitution, and merging</primary></indexterm><indexterm role="cp"><primary>-j (merging branches), and keyword substitution</primary></indexterm>
If you merge files containing keywords (<xref linkend="Keyword-substitution" />), you will normally get numerous
conflicts during the merge, because the keywords are
expanded differently in the revisions which you are
merging.
   </para>

</sect1></chapter>
 <chapter id="Recursive-behavior">
  <title>Recursive behavior
</title>
  <para><indexterm role="cp"><primary>Recursive (directory descending)</primary></indexterm><indexterm role="cp"><primary>Directory, descending</primary></indexterm><indexterm role="cp"><primary>Descending directories</primary></indexterm><indexterm role="cp"><primary>Subdirectories</primary></indexterm>
Almost all of the subcommands of cvsnt work
recursively when you specify a directory as an
argument.  For instance, consider this directory
structure:
  </para>

  <para><screen>      <command>$HOME</command>
        |
        +--<wordasword>tc</wordasword>
        |   |
            +--<wordasword>CVS</wordasword>
            |      (internal cvsnt files)
            +--<wordasword>Makefile</wordasword>
            +--<wordasword>backend.c</wordasword>
            +--<wordasword>driver.c</wordasword>
            +--<wordasword>frontend.c</wordasword>
            +--<wordasword>parser.c</wordasword>
            +--<wordasword>man</wordasword>
            |    |
            |    +--<wordasword>CVS</wordasword>
            |    |  (internal cvsnt files)
            |    +--<wordasword>tc.1</wordasword>
            |
            +--<wordasword>testing</wordasword>
                 |
                 +--<wordasword>CVS</wordasword>
                 |  (internal cvsnt files)
                 +--<wordasword>testpgm.t</wordasword>
                 +--<wordasword>test2.t</wordasword>
</screen>  </para>

  <para>
If <command>tc</command> is the current working directory, the
following is true:
  </para>

  <itemizedlist mark="bullet">
   <listitem>
    <para><command>cvs update testing</command> is equivalent to
    </para>

    <para><screen>cvs update testing/testpgm.t testing/test2.t
</screen>         </para>
</listitem>
   <listitem>
    <para><command>cvs update testing man</command> updates all files in the
subdirectories
    </para>
</listitem>
   <listitem>
    <para><command>cvs update .</command> or just <command>cvs update</command> updates
all files in the <command>tc</command> directory
    </para></listitem></itemizedlist>

  <para>
If no arguments are given to <command>update</command> it will
update all files in the current working directory and
all its subdirectories.  In other words, <command>.</command> is a
default argument to <command>update</command>.  This is also true
for most of the cvsnt subcommands, not only the
<command>update</command> command.
  </para>

  <para>
The recursive behavior of the cvsnt subcommands can be
turned off with the <command>-l</command> option.
Conversely, the <command>-R</command> option can be used to force recursion if
<command>-l</command> is specified in <command>~/.cvsrc</command> (<xref linkend="cvsrc" />).
  </para>

  <para><screen>
$ cvs update -l         # Don't update files in subdirectories
</screen>  </para>
</chapter>
 <chapter id="Adding-and-removing">
  <title>Adding, removing, and renaming files and directories
</title>

  <para>
In the course of a project, one will often add new
files.  Likewise with removing or renaming, or with
directories.  The general concept to keep in mind in
all these cases is that instead of making an
irreversible change you want cvsnt to record the
fact that a change has taken place, just as with
modifying an existing file.  The exact mechanisms to do
this in cvsnt vary depending on the situation.
  </para>

  <sect1 id="Adding-files">
   <title>Adding files to a directory
</title>
   <para><indexterm role="cp"><primary>Adding files</primary></indexterm>
To add a new file to a directory, follow these steps.
   </para>

   <itemizedlist mark="bullet">
    <listitem>
     <para>
You must have a working copy of the directory.
<xref linkend="Getting-the-source" />.
     </para>
</listitem>
    <listitem>
     <para>
Create the new file inside your working copy of the directory.
     </para>
</listitem>
    <listitem>
     <para>
Use <command>cvs add <varname>filename</varname></command> to tell cvsnt that you
want to version control the file.  If the file contains
binary data, specify <command>-kb</command> (<xref linkend="Binary-files" />).
     </para>
</listitem>
    <listitem>
     <para>
Use <command>cvs commit <varname>filename</varname></command> to actually check
in the file into the repository.  Other developers
cannot see the file until you perform this step.
     </para></listitem></itemizedlist>
   <para>
You can also use the <command>add</command> command to add a new
directory.
   </para>
   <para>
Unlike most other commands, the <command>add</command> command is
not recursive.  You cannot even type <command>cvs add
foo/bar</command>!  Instead, you have to
   </para>
   <para><screen>
$ cd foo
$ cvs add bar
</screen>      </para>
   <para><indexterm role="cp"><primary>add (subcommand)</primary></indexterm>
<function>cvs add</function> [<command>-k</command> kflag] [<command>-m</command> message] files &hellip;
<indexterm role="fn"><primary>cvs add</primary></indexterm>
Schedule <varname>files</varname> to be added to the repository.
The files or directories specified with <command>add</command> must
already exist in the current directory.  To add a whole
new directory hierarchy to the source repository (for
example, files received from a third-party vendor), use
the <command>import</command> command instead.  <xref linkend="import" />.
   </para>

   <para>
The added files are not placed in the source repository
until you use <command>commit</command> to make the change
permanent.  Doing an <command>add</command> on a file that was
removed with the <command>remove</command> command will undo the
effect of the <command>remove</command>, unless a <command>commit</command>
command intervened.  <xref linkend="Removing-files" />, for an
example.
   </para>

   <para>
The <command>-k</command> option specifies the default way that
this file will be checked out; for more information see
<xref linkend="Substitution-modes" />.
   </para>

   <para>
The <command>-m</command> option specifies a description for the
file.  This description appears in the history log (if
it is enabled, <xref linkend="history-file" />).  It will also be
saved in the version history inside the repository when
the file is committed.  The <command>log</command> command displays
this description.  The description can be changed using
<command>admin -t</command>.  <xref linkend="admin" />.  If you omit the
<command>-m <varname>description</varname></command> flag, an empty string will
be used.  You will not be prompted for a description.
      </para>
   <para>
For example, the following commands add the file
<command>backend.c</command> to the repository:
   </para>
   <para><screen>
$ cvs add backend.c
$ cvs commit -m "Early version. Not yet compilable." backend.c
</screen>      </para>
   <para>
When you add a file it is added only on the branch
which you are working on (<xref linkend="Branching-and-merging" />).  You can
later merge the additions to another branch if you want
(<xref linkend="Merging-adds-and-removals" />).
   </para>
</sect1>
  <sect1 id="Removing-files">
   <title>Removing files
</title>
   <para><indexterm role="cp"><primary>Removing files</primary></indexterm><indexterm role="cp"><primary>Deleting files</primary></indexterm>
Directories change.  New files are added, and old files
disappear.  Still, you want to be able to retrieve an
exact copy of old releases.
   </para>

   <para>
Here is what you can do to remove a file,
but remain able to retrieve old revisions:
   </para>

   <itemizedlist mark="bullet">
    <listitem>
     <para>
Make sure that you have not made any uncommitted
modifications to the file.  <xref linkend="Viewing-differences" />,
for one way to do that.  You can also use the
<command>status</command> or <command>update</command> command.  If you remove
the file without committing your changes, you will of
course not be able to retrieve the file as it was
immediately before you deleted it.
     </para>
</listitem>
    <listitem>
     <para>
Remove the file from your working copy of the directory.
You can for instance use <command>rm</command>.
     </para>
</listitem>
    <listitem>
     <para>
Use <command>cvs remove <varname>filename</varname></command> to tell cvsnt that
you really want to delete the file.
     </para>
</listitem>
    <listitem>
     <para>
Use <command>cvs commit <varname>filename</varname></command> to actually
perform the removal of the file from the repository.
     </para></listitem></itemizedlist>
   <para>
When you commit the removal of the file, cvsnt
records the fact that the file no longer exists.  It is
possible for a file to exist on only some branches and
not on others, or to re-add another file with the same
name later.  cvsnt will correctly create or not create
the file, based on the <command>-r</command> and <command>-D</command> options
specified to <command>checkout</command> or <command>update</command>.
   </para>
   <para><indexterm role="cp"><primary>Remove (subcommand)</primary></indexterm>
<function>cvs remove</function> [options] files &hellip;
<indexterm role="fn"><primary>cvs remove</primary></indexterm>
Schedule file(s) to be removed from the repository
(files which have not already been removed from the
working directory are not processed).  This command
does not actually remove the file from the repository
until you commit the removal.  For a full list of
options, see <xref linkend="Invoking-CVS" />.
      </para>
   <para>
Here is an example of removing several files:
   </para>
   <para><screen>
$ cd test
$ rm *.c
$ cvs remove
cvs remove: Removing .
cvs remove: scheduling a.c for removal
cvs remove: scheduling b.c for removal
cvs remove: use 'cvs commit' to remove these files permanently
$ cvs ci -m "Removed unneeded files"
cvs commit: Examining .
cvs commit: Committing .
</screen>      </para>
   <para>
As a convenience you can remove the file and <command>cvs
remove</command> it in one step, by specifying the <command>-f</command>
option.  For example, the above example could also be
done like this:
   </para>
   <para><screen>
$ cd test
$ cvs remove -f *.c
cvs remove: scheduling a.c for removal
cvs remove: scheduling b.c for removal
cvs remove: use 'cvs commit' to remove these files permanently
$ cvs ci -m "Removed unneeded files"
cvs commit: Examining .
cvs commit: Committing .
</screen>      </para>
   <para>
If you execute <command>remove</command> for a file, and then
change your mind before you commit, you can undo the
<command>remove</command> with an <command>add</command> command.
   </para>
   <para><screen>
$ ls
CVS   ja.h  oj.c
$ rm oj.c
$ cvs remove oj.c
cvs remove: scheduling oj.c for removal
cvs remove: use 'cvs commit' to remove this file permanently
$ cvs add oj.c
U oj.c
cvs add: oj.c, version 1.1.1.1, resurrected
</screen>      </para>
   <para>
If you realize your mistake before you run the
<command>remove</command> command you can use <command>update</command> to
resurrect the file:
   </para>
   <para><screen>
$ rm oj.c
$ cvs update oj.c
cvs update: warning: oj.c was lost
U oj.c
</screen>      </para>
   <para>
If you realize your mistake after running the <command>commit</command>
command you can use <command>add</command> followed by <command>update</command> to
resurrect the file:
   </para>
   <para><screen>
$ cvs remove foo.c
cvs remove: scheduling foo.c for removal
cvs remove: use 'cvs commit' to remove these files permanently
$ cvs ci -m "Removed unneeded files"
cvs commit: Examining .
cvs commit: Committing .
$ cvs add foo.c
cvs add: re-adding file test (in place of dead revision 1.6)
cvs add: use 'cvs commit' to add this file permanently
$ cvs update foo.c
cvs update: resurrecting deleted file test
U test
$cvs ci -m "Oops shouldn't have deleted that..."
cvs commit: Examining .
cvs commit: Committing .
</screen>      </para>
   <para>
When you remove a file it is removed only on the branch
which you are working on (<xref linkend="Branching-and-merging" />).  You can
later merge the removals to another branch if you want
(<xref linkend="Merging-adds-and-removals" />).
   </para>
</sect1>
  <sect1 id="Removing-directories">
   <title>Removing directories
</title>
   <para><indexterm role="cp"><primary>Removing directories</primary></indexterm><indexterm role="cp"><primary>Directories, removing</primary></indexterm>
In concept removing directories is somewhat similar to
removing files--you want the directory to not exist in
your current working directories, but you also want to
be able to retrieve old releases in which the directory
existed.
   </para>

   <para>
The way that you remove a directory is to remove all
the files in it.  You don't remove the directory
itself; there is no way to do that.
Instead you specify the <command>-P</command> option to
<command>cvs update</command> or <command>cvs checkout</command>,
which will cause cvsnt to remove empty
directories from working directories.
(Note that <command>cvs export</command> always removes empty directories.)
Probably the
best way to do this is to always specify <command>-P</command>; if
you want an empty directory then put a dummy file (for
example <command>.keepme</command>) in it to prevent <command>-P</command> from
removing it.
   </para>

   <para>
Note that <command>-P</command> is implied by the <command>-r</command> or <command>-D</command>
options of <command>checkout</command>.  This way
cvsnt will be able to correctly create the directory
or not depending on whether the particular version you
are checking out contains any files in that directory.
   </para>

</sect1>
  <sect1 id="Moving-files">
   <title>Moving and renaming files
</title>
   <para><indexterm role="cp"><primary>Moving files</primary></indexterm><indexterm role="cp"><primary>Renaming files</primary></indexterm><indexterm role="cp"><primary>Files, moving</primary></indexterm>
Moving files to a different directory or renaming them
is not difficult, but some of the ways in which this
works may be non-obvious.  (Moving or renaming a
directory is even harder.  <xref linkend="Moving-directories" />.).
   </para>

   <para>
The examples below assume that the file <varname>old</varname> is renamed to
<varname>new</varname>.
   </para>

   <sect2 id="Outside">
    <title>The Normal way to Rename
</title>


    <para>
The normal way to move a file is to copy <varname>old</varname> to
<varname>new</varname>, and then issue the normal cvsnt commands
to remove <varname>old</varname> from the repository, and add
<varname>new</varname> to it.
    </para>

    <para><screen>$ mv <varname>old</varname> <varname>new</varname>
$ cvs remove <varname>old</varname>
$ cvs add <varname>new</varname>
$ cvs commit -m "Renamed <varname>old</varname> to <varname>new</varname>" <varname>old</varname> <varname>new</varname>
</screen>    </para>
    <para>
This is the simplest way to move a file, it is not
error-prone, and it preserves the history of what was
done.  Note that to access the history of the file you
must specify the old or the new name, depending on what
portion of the history you are accessing.  For example,
<command>cvs log <varname>old</varname></command> will give the log up until the
time of the rename.
    </para>
    <para>
When <varname>new</varname> is committed its revision numbers will
start again, usually at 1.1, so if that bothers you,
use the <command>-r rev</command> option to commit.  For more
information see <xref linkend="Assigning-revisions" />.
    </para>
</sect2>
   <sect2 id="Inside">
    <title>Moving the history file
</title>

    <para>
This method is more dangerous, since it involves moving
files inside the repository.  Read this entire section
before trying it out!
    </para>

    <para><screen>$ cd $CVSROOT/<varname>dir</varname>
$ mv <varname>old</varname>,v <varname>new</varname>,v
</screen>    </para>

    <para>
Advantages:
    </para>

    <itemizedlist mark="bullet">
     <listitem>
      <para>
The log of changes is maintained intact.
      </para>
</listitem>
     <listitem>
      <para>
The revision numbers are not affected.
      </para></listitem></itemizedlist>

    <para>
Disadvantages:
    </para>

    <itemizedlist mark="bullet">
     <listitem>
      <para>
Old releases cannot easily be fetched from the
repository.  (The file will show up as <varname>new</varname> even
in revisions from the time before it was renamed).
      </para>
</listitem>
     <listitem>
      <para>
There is no log information of when the file was renamed.
      </para>
</listitem>
     <listitem>
      <para>
Nasty things might happen if someone accesses the history file
while you are moving it.  Make sure no one else runs any of the cvsnt
commands while you move it.
      </para></listitem></itemizedlist>
</sect2>
   <sect2 id="Rename-by-copying">
    <title>Copying the history file
</title>

    <para>
This way also involves direct modifications to the
repository.  It is safe, but not without drawbacks.
    </para>

    <para><screen># Copy the rcs file inside the repository
$ cd $CVSROOT/<varname>dir</varname>
$ cp <varname>old</varname>,v <varname>new</varname>,v
# Remove the old file
$ cd ~/<varname>dir</varname>
$ rm <varname>old</varname>
$ cvs remove <varname>old</varname>
$ cvs commit <varname>old</varname>
# Remove all tags from <varname>new</varname>
$ cvs update <varname>new</varname>
$ cvs log <varname>new</varname>             # Remember the non-branch tag names
$ cvs tag -d <varname>tag1</varname> <varname>new</varname>
$ cvs tag -d <varname>tag2</varname> <varname>new</varname>
&hellip;
</screen>    </para>
    <para>
By removing the tags you will be able to check out old
revisions.
    </para>

    <para>
Advantages:
    </para>

    <itemizedlist mark="bullet">
     <listitem>
      <para>
Checking out old revisions works correctly, as long as
you use <command>-r<varname>tag</varname></command> and not <command>-D<varname>date</varname></command>
to retrieve the revisions.
      </para>
</listitem>
     <listitem>
      <para>
The log of changes is maintained intact.
      </para>
</listitem>
     <listitem>
      <para>
The revision numbers are not affected.
      </para></listitem></itemizedlist>

    <para>
Disadvantages:
    </para>

    <itemizedlist mark="bullet">
     <listitem>
      <para>
You cannot easily see the history of the file across the rename.
      </para>
</listitem></itemizedlist>
</sect2></sect1>
  <sect1 id="Moving-directories">
   <title>Moving and renaming directories
</title>
   <para><indexterm role="cp"><primary>Moving directories</primary></indexterm><indexterm role="cp"><primary>Renaming directories</primary></indexterm><indexterm role="cp"><primary>Directories, moving</primary></indexterm>
The normal way to rename or move a directory is to
rename or move each file within it as described in
<xref linkend="Outside" />.  Then check out with the <command>-P</command>
option, as described in <xref linkend="Removing-directories" />.
   </para>

   <para>
If you really want to hack the repository to rename or
delete a directory in the repository, you can do it
like this:
   </para>

   <orderedlist numeration="arabic">
    <listitem>
     <para>
Inform everyone who has a checked out copy of the directory that the
directory will be renamed.  They should commit all
their changes, and remove their working copies,
before you take the steps below.
     </para>
</listitem>
    <listitem>
     <para>
Rename the directory inside the repository.
     </para>

     <para><screen>$ cd $CVSROOT/<varname>parent-dir</varname>
$ mv <varname>old-dir</varname> <varname>new-dir</varname>
</screen>          </para>
</listitem>
    <listitem>
     <para>
Fix the cvsnt administrative files, if necessary (for
instance if you renamed an entire module).
     </para>
</listitem>
    <listitem>
     <para>
Tell everyone that they can check out again and continue
working.
     </para>
</listitem></orderedlist>

   <para>
If someone had a working copy the cvsnt commands will
cease to work for him, until he removes the directory
that disappeared inside the repository.
   </para>

   <para>
It is almost always better to move the files in the
directory instead of moving the directory.  If you move the
directory you are unlikely to be able to retrieve old
releases correctly, since they probably depend on the
name of the directories.
   </para>

</sect1></chapter>
 <chapter id="History-browsing">
  <title>History browsing
</title>
  <para><indexterm role="cp"><primary>History browsing</primary></indexterm><indexterm role="cp"><primary>Traceability</primary></indexterm><indexterm role="cp"><primary>Isolation</primary></indexterm>
  </para>

  <para>
Once you have used cvsnt to store a version control
history--what files have changed when, how, and by
whom, there are a variety of mechanisms for looking
through the history.
  </para>

  <sect1 id="log-messages">
   <title>Log messages
</title>

   <para>
Whenever you commit a file you specify a log message.
   </para>

   <para>
To look through the log messages which have been
specified for every revision which has been committed,
use the <command>cvs log</command> command (<xref linkend="log" />).
   </para>

</sect1>
  <sect1 id="history-database">
   <title>The history database
</title>

   <para>
You can use the history file (<xref linkend="history-file" />) to
log various cvsnt actions.  To retrieve the
information from the history file, use the <command>cvs
history</command> command (<xref linkend="history" />).
   </para>

   <para>
Note: you can control what is logged to this file by using the
<command>LogHistory</command> keyword in the <command>CVSROOT/config</command> file
(<xref linkend="config" />).
   </para>


</sect1>
  <sect1 id="user-defined-logging">
   <title>User-defined logging
</title>

   <para>
You can customize cvsnt to log various kinds of
actions, in whatever manner you choose.  These
mechanisms operate by executing a script at various
times.  The script might append a message to a file
listing the information and the programmer who created
it, or send mail to a group of developers, or, perhaps,
post a message to a particular newsgroup.  To log
commits, use the <command>loginfo</command> file (<xref linkend="loginfo" />).
To log commits, checkouts, exports, and tags,
respectively, you can also use the <command>-i</command>,
<command>-o</command>, <command>-e</command>, and <command>-t</command> options in the
modules file.  For a more flexible way of giving
notifications to various users, which requires less in
the way of keeping centralized scripts up to date, use
the <command>cvs watch add</command> command (<xref linkend="Getting-Notified" />); this command is useful even if you are not
using <command>cvs watch on</command>.
   </para>

   <para><indexterm role="cp"><primary>taginfo</primary></indexterm><indexterm role="cp"><primary>Exit status, of taginfo</primary></indexterm>The <command>taginfo</command> file defines programs to execute
when someone executes a <command>tag</command> or <command>rtag</command>
command.  The <command>taginfo</command> file has the standard form
for administrative files (<xref linkend="Administrative-files" />), where each line is a regular expression
followed by a command to execute.  The arguments passed
to the command are, in order, the <varname>tagname</varname>,
<varname>operation</varname> (<command>add</command> for <command>tag</command>,
<command>mov</command> for <command>tag -F</command>, and <command>del</command> for
<command>tag -d</command>), <varname>repository</varname>.  The standard input contains
pairs of <varname>filename</varname> <varname>revision</varname>.  A non-zero
exit of the filter program will cause the tag to be
aborted.
   </para>

   <para>
Here is an example of using taginfo to log tag and rtag
commands.  In the taginfo file put:
   </para>

   <para><screen>ALL /usr/local/cvsroot/CVSROOT/loggit
</screen>   </para>
   <para>
Where <command>/usr/local/cvsroot/CVSROOT/loggit</command> contains the
following script:
   </para>
   <para><screen>
#!/bin/sh
echo "$@" &gt;&gt;/home/kingdon/cvsroot/CVSROOT/taglog
</screen>      </para>
</sect1>
  <sect1 id="annotate">
   <title>Annotate command
</title>
   <para><indexterm role="cp"><primary>annotate (subcommand)</primary></indexterm>
<function>cvs annotate</function> [<command>-flR</command>] [<command>-r rev</command>|<command>-D date</command>] files &hellip;
<indexterm role="fn"><primary>cvs annotate</primary></indexterm>
For each file in <varname>files</varname>, print the head revision
of the trunk, together with information on the last
modification for each line.  For example:
   </para>

   <para><screen>$ cvs annotate ssfile
Annotations for ssfile
***************
1.1          (mary     27-Mar-96): ssfile line 1
1.2          (joe      28-Mar-96): ssfile line 2
</screen>        </para>

   <para>
The file <command>ssfile</command> currently contains two lines.
The <command>ssfile line 1</command> line was checked in by
<command>mary</command> on March 27.  Then, on March 28, <command>joe</command>
added a line <command>ssfile line 2</command>, without modifying
the <command>ssfile line 1</command> line.  This report doesn't
tell you anything about lines which have been deleted
or replaced; you need to use <command>cvs diff</command> for that
(<xref linkend="diff" />).
   </para>


   <para>
The options to <command>cvs annotate</command> are listed in
<xref linkend="Invoking-CVS" />, and can be used to select the files
and revisions to annotate.  The options are described
in more detail in <xref linkend="Common-options" />.
   </para>

</sect1></chapter>
 <chapter id="Binary-files">
  <title>Handling binary files
</title>
  <para><indexterm role="cp"><primary>Binary files</primary></indexterm>
The most common use for cvsnt is to store text
files.  With text files, cvsnt can merge revisions,
display the differences between revisions in a
human-visible fashion, and other such operations.
However, if you are willing to give up a few of these
abilities, cvsnt can store binary files.  For
example, one might store a web site in cvsnt
including both text files and binary images.
  </para>

  <sect1 id="Binary-why">
   <title>The issues with binary files
</title>

   <para>
While the need to manage binary files may seem obvious
if the files that you customarily work with are binary,
putting them into version control does present some
additional issues.
   </para>

   <para>
One basic function of version control is to show the
differences between two revisions.  For example, if
someone else checked in a new version of a file, you
may wish to look at what they changed and determine
whether their changes are good.  For text files,
cvsnt provides this functionality via the <command>cvs
diff</command> command.  For binary files, it may be possible to
extract the two revisions and then compare them with a
tool external to cvsnt (for example, word processing
software often has such a feature).  If there is no
such tool, one must track changes via other mechanisms,
such as urging people to write good log messages, and
hoping that the changes they actually made were the
changes that they intended to make.
   </para>

   <para>
Another ability of a version control system is the
ability to merge two revisions.  For cvsnt this
happens in two contexts.  The first is when users make
changes in separate working directories
(<xref linkend="Multiple-developers" />).  The second is when one
merges explicitly with the <command>update -j</command> command
(<xref linkend="Branching-and-merging" />).
   </para>

   <para>
In the case of text
files, cvsnt can merge changes made independently,
and signal a conflict if the changes conflict.  With
binary files, the best that cvsnt can do is present
the two different copies of the file, and leave it to
the user to resolve the conflict.  The user may choose
one copy or the other, or may run an external merge
tool which knows about that particular file format, if
one exists.
Note that having the user merge relies primarily on the
user to not accidentally omit some changes, and thus is
potentially error prone.
   </para>

   <para>
If this process is thought to be undesirable, the best
choice may be to avoid merging.  To avoid the merges
that result from separate working directories, see the
discussion of reserved checkouts (file locking) in
<xref linkend="Multiple-developers" />.  To avoid the merges
resulting from branches, restrict use of branches.
   </para>

</sect1>
  <sect1 id="Binary-howto">
   <title>How to store binary files
</title>

   <para>
There are two issues with using cvsnt to store
binary files.  The first is that cvsnt by default
converts line endings between the canonical form in
which they are stored in the repository (linefeed
only), and the form appropriate to the operating system
in use on the client (for example, carriage return
followed by line feed for Windows NT).
   </para>

   <para>
The second is that a binary file might happen to
contain data which looks like a keyword (<xref linkend="Keyword-substitution" />), so keyword expansion must be turned
off.
   </para>

<para>
The third is that storing differences (deltas) between binary files can
be very inneficient.
</para>

   <para>
The <command>-kb</command> option available with some cvsnt
commands insures that neither line ending conversion
nor keyword expansion will be done.
   </para>

   <para>
Here is an example of how you can create a new file
using the <command>-kb</command> flag:
   </para>

   <para><screen>$ echo '&dollar;Id&dollar;' &gt; kotest
$ cvs add -kb -m"A test file" kotest
$ cvs ci -m"First checkin; contains a keyword" kotest
</screen>   </para>
   <para>
If a file accidentally gets added without <command>-kb</command>,
one can use the <command>cvs admin</command> command to recover.
For example:
   </para>
   <para><screen>
$ echo '&dollar;Id&dollar;' &gt; kotest
$ cvs add -m"A test file" kotest
$ cvs ci -m"First checkin; contains a keyword" kotest
$ cvs admin -kb kotest
$ cvs update -A kotest
# For non-unix systems:
# Copy in a good copy of the file from outside CVS
$ cvs commit -m "make it binary" kotest
</screen>      </para>
   <para>
When you check in the file <command>kotest</command> the file is
not preserved as a binary file, because you did not
check it in as a binary file.  The <command>cvs
admin -kb</command> command sets the default keyword
substitution method for this file, but it does not
alter the working copy of the file that you have.  If you need to
cope with line endings (that is, you are using
cvsnt on a non-unix system), then you need to
check in a new copy of the file, as shown by the
<command>cvs commit</command> command above.
On unix, the <command>cvs update -A</command> command suffices.
   </para>
   <para>
You can also set a default for whether <command>cvs add</command>
and <command>cvs import</command> treat a file as binary based on
its name; for example you could say that files who
names end in <command>.exe</command> are binary.  <xref linkend="Wrappers" />.
There is currently no way to have cvsnt detect
whether a file is binary based on its contents.  The
main difficulty with designing such a feature is that
it is not clear how to distinguish between binary and
non-binary files, and the rules to apply would vary
considerably with the operating system.
   </para>
   <para>
   The <command>-kB</command> available in some versions of CVSNT solves the inneficiency
   problem by using a special binary delta algorithm to store the files.  The function
   is similar to <command>-kb</command> except it is more efficient, and some functions
   that rely on text deltas, such as <command>cvs annotate</command> do not work with it.
</para>
<para>
   Normaly CVS assumes that every file (whether binary or not) is a text file of some sort. This makes sense for most files that you would normally use
   during development, and the storage of such files is higly efficient.
</para>
<para>
   However, if you are storing pure binary files (libraries, or perhaps Word documents) it is very inneficient to treat them as text files. CVSNT solves this problem
with the -kB option. This tells CVSNT to switch to an alternate algorithm to store such files.
   </para>
</sect1></chapter>
 <chapter id="Multiple-developers">
  <title>Multiple developers
</title>
  <para><indexterm role="cp"><primary>Multiple developers</primary></indexterm><indexterm role="cp"><primary>Team of developers</primary></indexterm><indexterm role="cp"><primary>File locking</primary></indexterm><indexterm role="cp"><primary>Locking files</primary></indexterm><indexterm role="cp"><primary>Working copy</primary></indexterm><indexterm role="cp"><primary>Reserved checkouts</primary></indexterm><indexterm role="cp"><primary>Unreserved checkouts</primary></indexterm><indexterm role="cp"><primary>rcs-style locking</primary></indexterm>
When more than one person works on a software project
things often get complicated.  Often, two people try to
edit the same file simultaneously.  One solution, known
as <firstterm>file locking</firstterm> or <firstterm>reserved checkouts</firstterm>, is
to allow only one person to edit each file at a time.
This is the only solution with some version control
systems, including rcs and sccs.  Currently
the usual way to get reserved checkouts with cvsnt
is the <command>cvs admin -l</command> command (<xref linkend="admin-options" />).  This is not as nicely integrated into
cvsnt as the watch features, described below, but it
seems that most people with a need for reserved
checkouts find it adequate.
It also may be possible to use the watches
features described below, together with suitable
procedures (not enforced by software), to avoid having
two people edit at the same time.
  </para>

  <para>
The default model with cvsnt is known as
<firstterm>unreserved checkouts</firstterm>.  In this model, developers
can edit their own <firstterm>working copy</firstterm> of a file
simultaneously.  The first person that commits his
changes has no automatic way of knowing that another
has started to edit it.  Others will get an error
message when they try to commit the file.  They must
then use cvsnt commands to bring their working copy
up to date with the repository revision.  This process
is almost automatic.
  </para>

  <para>
cvsnt also supports mechanisms which facilitate
various kinds of communication, without actually
enforcing rules like reserved checkouts do.
  </para>

  <para>
The rest of this chapter describes how these various
models work, and some of the issues involved in
choosing between them.
  </para>

  <sect1 id="File-status">
   <title>File status
</title>
   <para><indexterm role="cp"><primary>File status</primary></indexterm><indexterm role="cp"><primary>Status of a file</primary></indexterm>
Based on what operations you have performed on a
checked out file, and what operations others have
performed to that file in the repository, one can
classify a file in a number of states.  The states, as
reported by the <command>status</command> command, are:
   </para>

   <variablelist>
    <title><indexterm role="cp"><primary>Up-to-date</primary></indexterm></title>
    <varlistentry>
     <term>Up-to-date</term>
     <listitem>
      <para>
The file is identical with the latest revision in the
repository for the branch in use.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>Locally Modified</term>
     <listitem>
      <para><indexterm role="cp"><primary>Locally Modified</primary></indexterm>You have edited the file, and not yet committed your changes.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>Locally Added</term>
     <listitem>
      <para><indexterm role="cp"><primary>Locally Added</primary></indexterm>You have added the file with <command>add</command>, and not yet
committed your changes.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>Locally Removed</term>
     <listitem>
      <para><indexterm role="cp"><primary>Locally Removed</primary></indexterm>You have removed the file with <command>remove</command>, and not yet
committed your changes.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>Needs Checkout</term>
     <listitem>
      <para><indexterm role="cp"><primary>Needs Checkout</primary></indexterm>Someone else has committed a newer revision to the
repository.  The name is slightly misleading; you will
ordinarily use <command>update</command> rather than
<command>checkout</command> to get that newer revision.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>Needs Patch</term>
     <listitem>
      <para><indexterm role="cp"><primary>Needs Patch</primary></indexterm>Like Needs Checkout, but the cvsnt server will send
a patch rather than the entire file.  Sending a patch or
sending an entire file accomplishes the same thing.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>Needs Merge</term>
     <listitem>
      <para><indexterm role="cp"><primary>Needs Merge</primary></indexterm>Someone else has committed a newer revision to the repository, and you
have also made modifications to the file.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>File had conflicts on merge</term>
     <listitem>
      <para><indexterm role="cp"><primary>File had conflicts on merge</primary></indexterm>This is like Locally Modified, except that a previous
<command>update</command> command gave a conflict.  If you have not
already done so, you need to
resolve the conflict as described in <xref linkend="Conflicts-example" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term>Unknown</term>
     <listitem>
      <para><indexterm role="cp"><primary>Unknown</primary></indexterm>cvsnt doesn't know anything about this file.  For
example, you have created a new file and have not run
<command>add</command>.
      </para>
</listitem></varlistentry></variablelist>
   <para>
To help clarify the file status, <command>status</command> also
reports the <command>Working revision</command> which is the
revision that the file in the working directory derives
from, and the <command>Repository revision</command> which is the
latest revision in the repository for the branch in
use.
   </para>
   <para>
The options to <command>status</command> are listed in
<xref linkend="Invoking-CVS" />.  For information on its <command>Sticky tag</command>
and <command>Sticky date</command> output, see <xref linkend="Sticky-tags" />.
For information on its <command>Sticky options</command> output,
see the <command>-k</command> option in <xref linkend="update-options" />.
   </para>
   <para>
You can think of the <command>status</command> and <command>update</command>
commands as somewhat complementary.  You use
<command>update</command> to bring your files up to date, and you
can use <command>status</command> to give you some idea of what an
<command>update</command> would do (of course, the state of the
repository might change before you actually run
<command>update</command>).  In fact, if you want a command to
display file status in a more brief format than is
displayed by the <command>status</command> command, you can invoke
   </para>
   <para><indexterm role="cp"><primary>update, to display file status</primary></indexterm><screen>
$ cvs -n -q update
</screen>      </para>
   <para>
The <command>-n</command> option means to not actually do the
update, but merely to display statuses; the <command>-q</command>
option avoids printing the name of each directory.  For
more information on the <command>update</command> command, and
these options, see <xref linkend="Invoking-CVS" />.
   </para>
</sect1>
  <sect1 id="Updating-a-file">
   <title>Bringing a file up to date
</title>
   <para><indexterm role="cp"><primary>Bringing a file up to date</primary></indexterm><indexterm role="cp"><primary>Updating a file</primary></indexterm><indexterm role="cp"><primary>Merging a file</primary></indexterm><indexterm role="cp"><primary>Update, introduction</primary></indexterm>
When you want to update or merge a file, use the <command>update</command>
command.  For files that are not up to date this is roughly equivalent
to a <command>checkout</command> command: the newest revision of the file is
extracted from the repository and put in your working directory.
   </para>

   <para>
Your modifications to a file are never lost when you
use <command>update</command>.  If no newer revision exists,
running <command>update</command> has no effect.  If you have
edited the file, and a newer revision is available,
cvsnt will merge all changes into your working copy.
   </para>

   <para>
For instance, imagine that you checked out revision 1.4 and started
editing it.  In the meantime someone else committed revision 1.5, and
shortly after that revision 1.6.  If you run <command>update</command> on the file
now, cvsnt will incorporate all changes between revision 1.4 and 1.6 into
your file.
   </para>

   <para><indexterm role="cp"><primary>Overlap</primary></indexterm>If any of the changes between 1.4 and 1.6 were made too
close to any of the changes you have made, an
<firstterm>overlap</firstterm> occurs.  In such cases a warning is
printed, and the resulting file includes both
versions of the lines that overlap, delimited by
special markers.
<xref linkend="update" />, for a complete description of the
<command>update</command> command.
   </para>

</sect1>
  <sect1 id="Conflicts-example">
   <title>Conflicts example
</title>
   <para><indexterm role="cp"><primary>Merge, an example</primary></indexterm><indexterm role="cp"><primary>Example of merge</primary></indexterm><indexterm role="cp"><primary>driver.c (merge example)</primary></indexterm>
Suppose revision 1.4 of <command>driver.c</command> contains this:
   </para>

   <para><screen>#include &lt;stdio.h&gt;

void main()
{
    parse();
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? 0 : 1);
}
</screen>   </para>

   <para>
Revision 1.6 of <command>driver.c</command> contains this:
   </para>

   <para><screen>
#include &lt;stdio.h&gt;

int main(int argc,
         char **argv)
{
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(!!nerr);
}
</screen>   </para>

   <para>
Your working copy of <command>driver.c</command>, based on revision
1.4, contains this before you run <command>cvs update</command>:
   </para>

   <para><screen>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void main()
{
    init_scanner();
    parse();
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
</screen>   </para>

   <para>
You run <command>cvs update</command>:
   </para>

   <para><screen>
$ cvs update driver.c
rcs file: /usr/local/cvsroot/yoyodyne/tc/driver.c,v
retrieving revision 1.4
retrieving revision 1.6
Merging differences between 1.4 and 1.6 into driver.c
rcsmerge warning: overlaps during merge
cvs update: conflicts found in driver.c
C driver.c
</screen>   </para>

   <para><indexterm role="cp"><primary>Conflicts (merge example)</primary></indexterm>cvsnt tells you that there were some conflicts.
Your original working file is saved unmodified in
<command>.#driver.c.1.4</command>.  The new version of
<command>driver.c</command> contains this:
   </para>

   <para><screen>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc,
         char **argv)
{
    init_scanner();
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
&lt;&lt;&lt;&lt;&lt;&lt;&lt; driver.c
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
=======
    exit(!!nerr);
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.6
}
</screen>   </para>

   <para><indexterm role="cp"><primary>Markers, conflict</primary></indexterm><indexterm role="cp"><primary>Conflict markers</primary></indexterm><indexterm role="cp"><primary>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</primary></indexterm><indexterm role="cp"><primary>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</primary></indexterm><indexterm role="cp"><primary>=======</primary></indexterm>
Note how all non-overlapping modifications are incorporated in your working
copy, and that the overlapping section is clearly marked with
<command>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</command>, <command>=======</command> and <command>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</command>.
   </para>

   <para><indexterm role="cp"><primary>Resolving a conflict</primary></indexterm><indexterm role="cp"><primary>Conflict resolution</primary></indexterm>You resolve the conflict by editing the file, removing the markers and
the erroneous line.  Suppose you end up with this file:
<screen>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc,
         char **argv)
{
    init_scanner();
    parse();
    if (argc != 1)
    {
        fprintf(stderr, "tc: No args expected.\n");
        exit(1);
    }
    if (nerr == 0)
        gencode();
    else
        fprintf(stderr, "No code generated.\n");
    exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
</screen>   </para>

   <para>
You can now go ahead and commit this as revision 1.7.
   </para>

   <para><screen>
$ cvs commit -m "Initialize scanner. Use symbolic exit values." driver.c
Checking in driver.c;
/usr/local/cvsroot/yoyodyne/tc/driver.c,v  &lt;--  driver.c
new revision: 1.7; previous revision: 1.6
done
</screen>   </para>
   <para>
For your protection, cvsnt will refuse to check in a
file if a conflict occurred and you have not resolved
the conflict.  Currently to resolve a conflict, you
must change the timestamp on the file.  In previous
versions of cvsnt, you also needed to
insure that the file contains no conflict markers.
Because
your file may legitimately contain conflict markers (that
is, occurrences of <command>&gt;&gt;&gt;&gt;&gt;&gt;&gt; </command> at the start of a
line that don't mark a conflict), the current
version of cvsnt will print a warning and proceed to
check in the file.
   </para>
   <para><indexterm role="cp"><primary>emerge</primary></indexterm>If you use release 1.04 or later of pcl-cvs (a gnu
Emacs front-end for cvsnt) you can use an Emacs
package called emerge to help you resolve conflicts.
See the documentation for pcl-cvs.
   </para>
</sect1>
  <sect1 id="Informing-others">
   <title>Informing others about commits
</title>
   <para><indexterm role="cp"><primary>Informing others</primary></indexterm><indexterm role="cp"><primary>Spreading information</primary></indexterm><indexterm role="cp"><primary>Mail, automatic mail on commit</primary></indexterm>
It is often useful to inform others when you commit a
new revision of a file.  The <command>-i</command> option of the
<command>modules</command> file, or the <command>loginfo</command> file, can be
used to automate this process.  <xref linkend="modules" />.
<xref linkend="loginfo" />.  You can use these features of cvsnt
to, for instance, instruct cvsnt to mail a
message to all developers, or post a message to a local
newsgroup.
   </para>

</sect1>
  <sect1 id="Concurrency">
   <title>Several developers simultaneously attempting to run CVS
</title>

   <para><indexterm role="cp"><primary>Locks, cvs, introduction</primary></indexterm>If several developers try to run cvsnt at the same
time, one may get the following message:
   </para>

   <para><screen>[11:43:23] waiting for bach's lock in /usr/local/cvsroot/foo
</screen>   </para>
   <para><indexterm role="cp"><primary>#cvs.rfl, removing</primary></indexterm><indexterm role="cp"><primary>#cvs.wfl, removing</primary></indexterm><indexterm role="cp"><primary>#cvs.lock, removing</primary></indexterm>cvsnt will try again every second, and either
continue with the operation or print the message again,
if it still needs to wait.  If a lock seems to stick
around for an undue amount of time, find the person
holding the lock and ask them about the cvs command
they are running.  If they aren't running a cvs
command, and you are not running the lockserver (see <xref linkend="Lockserver" />, look in the
repository directory mentioned in
the message and remove files which they own whose names
start with <command>#cvs.rfl</command>,
<command>#cvs.wfl</command>, or <command>#cvs.lock</command>.
   </para>
   <para>
Note that these locks are to protect cvsnt's
internal data structures and have no relationship to
the word <firstterm>lock</firstterm> in the sense used by
rcs--which refers to reserved checkouts
(<xref linkend="Multiple-developers" />).
   </para>
   <para>
Any number of people can be reading from a given
repository at a time; only when someone is writing a file do
the locks prevent other people from reading or writing.
   </para>
   <para><indexterm role="cp"><primary>Atomic transactions</primary></indexterm><indexterm role="cp"><primary>Atomicity</primary></indexterm>
   Checkouts on cvsnt are atomic which means:
   </para>
   <para><screen>
If someone commits some changes in one cvs command,
then an update by someone else will either get all the
changes, or none of them.
</screen>      </para>
   <para>
By default atomic checkouts occur across an entire checkout, (provided the lockserver is running), but
atomic commits are only atomic at the file level. For example, given the files
   </para>
   <para><screen>
a/one.c
a/two.c
b/three.c
b/four.c
</screen>      </para>
   <para>
if someone runs
   </para>
   <para><screen>
cvs ci a/two.c b/three.c
</screen>      </para>
   <para>
and someone else runs <command>cvs update</command> at the same
time, the person running <command>update</command> will either get all of the changes, or none of them. If however, the person
running <command>cvs commit</command> suffers a power failure in the middle of the commit, it is possible that only one of the files will be updated.
   </para>
</sect1>
  <sect1 id="Watches">
   <title>Mechanisms to track who is editing files
</title>
   <para><indexterm role="cp"><primary>Watches</primary></indexterm>
For many groups, use of cvsnt in its default mode is
perfectly satisfactory.  Users may sometimes go to
check in a modification only to find that another
modification has intervened, but they deal with it and
proceed with their check in.  Other groups prefer to be
able to know who is editing what files, so that if two
people try to edit the same file they can choose to
talk about who is doing what when rather than be
surprised at check in time.  The features in this
section allow such coordination, while retaining the
ability of two developers to edit the same file at the
same time.
   </para>

   <para>
For maximum benefit developers should use <command>cvs
edit</command> (not <command>chmod</command>) to make files read-write to
edit them, and <command>cvs release</command> (not <command>rm</command>) to
discard a working directory which is no longer in use,
but cvsnt is not able to enforce this behavior.
   </para>

   <sect2 id="Setting-a-watch">
    <title>Telling CVS to watch certain files
</title>

    <para>
To enable the watch features, you first specify that
certain files are to be watched.
    </para>

    <para><indexterm role="cp"><primary>watch on (subcommand)</primary></indexterm><function>cvs watch on</function> [<command>-lR</command>] files &hellip;
<indexterm role="fn"><primary>cvs watch on</primary></indexterm>
<indexterm role="cp"><primary>Read-only files, and watches</primary></indexterm>Specify that developers should run <command>cvs edit</command>
before editing <varname>files</varname>.  cvsnt will create working
copies of <varname>files</varname> read-only, to remind developers
to run the <command>cvs edit</command> command before working on
them.
    </para>

    <para>
If <varname>files</varname> includes the name of a directory, cvsnt
arranges to watch all files added to the corresponding
repository directory, and sets a default for files
added in the future; this allows the user to set
notification policies on a per-directory basis.  The
contents of the directory are processed recursively,
unless the <command>-l</command> option is given.
The <command>-R</command> option can be used to force recursion if the <command>-l</command>
option is set in <command>~/.cvsrc</command> (<xref linkend="cvsrc" />).
    </para>

    <para>
If <varname>files</varname> is omitted, it defaults to the current directory.
    </para>

    <para><indexterm role="cp"><primary>watch off (subcommand)</primary></indexterm>
<function>cvs watch off</function> [<command>-lR</command>] files &hellip;
<indexterm role="fn"><primary>cvs watch off</primary></indexterm>
Do not create <varname>files</varname> read-only on checkout; thus,
developers will not be reminded to use <command>cvs edit</command>
and <command>cvs unedit</command>.
    </para>

    <para>
The <varname>files</varname> and options are processed as for <command>cvs
watch on</command>.
    </para>
</sect2>
   <sect2 id="Getting-Notified">
    <title>Telling CVS to notify you
</title>

    <para>
You can tell cvsnt that you want to receive
notifications about various actions taken on a file.
You can do this without using <command>cvs watch on</command> for
the file, but generally you will want to use <command>cvs
watch on</command>, so that developers use the <command>cvs edit</command>
command.
    </para>

    <para><indexterm role="cp"><primary>watch add (subcommand)</primary></indexterm><function>cvs watch add</function> [<command>-a</command> action] [<command>-lR</command>] files &hellip;
<indexterm role="fn"><primary>cvs watch add</primary></indexterm>
Add the current user to the list of people to receive notification of
work done on <varname>files</varname>.
    </para>

    <para>
The <command>-a</command> option specifies what kinds of events cvsnt should notify
the user about.  <varname>action</varname> is one of the following:
    </para>

    <variablelist>

     <varlistentry>
      <term><command>edit</command></term>
      <listitem>
       <para>
Another user has applied the <command>cvs edit</command> command (described
below) to a file.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>unedit</command></term>
      <listitem>
       <para>
Another user has applied the <command>cvs unedit</command> command (described
below) or the <command>cvs release</command> command to a file, or has deleted
the file and allowed <command>cvs update</command> to recreate it.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>commit</command></term>
      <listitem>
       <para>
Another user has committed changes to a file.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>all</command></term>
      <listitem>
       <para>
All of the above.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>none</command></term>
      <listitem>
       <para>
None of the above.  (This is useful with <command>cvs edit</command>,
described below.)
       </para>
</listitem></varlistentry></variablelist>     

    <para>
The <command>-a</command> option may appear more than once, or not at all.  If
omitted, the action defaults to <command>all</command>.
    </para>

    <para>
The <varname>files</varname> and options are processed as for the
<command>cvs watch</command> commands.
    </para>



    <para><indexterm role="cp"><primary>watch remove (subcommand)</primary></indexterm>
<function>cvs watch remove</function> [<command>-a</command> action] [<command>-lR</command>] files &hellip;
<indexterm role="fn"><primary>cvs watch remove</primary></indexterm>
Remove a notification request established using <command>cvs watch add</command>;
the arguments are the same.  If the <command>-a</command> option is present, only
watches for the specified actions are removed.
    </para>

    <para><indexterm role="cp"><primary>notify (admin file)</primary></indexterm>When the conditions exist for notification, cvsnt
calls the <command>notify</command> administrative file.  Edit
<command>notify</command> as one edits the other administrative
files (<xref linkend="Intro-administrative-files" />).  This
file follows the usual conventions for administrative
files (<xref linkend="syntax" />), where each line is a regular
expression followed by a command to execute.  The
command should contain a single occurrence of <command>%s</command>
which will be replaced by the user to notify; the rest
of the information regarding the notification will be
supplied to the command on standard input.  The
standard thing to put in the <command>notify</command> file is the
single line:
    </para>
    <para><screen>
ALL mail %s -s "CVS notification"
</screen>       </para>
    <para>
This causes users to be notified by electronic mail.
    </para>
    <para><indexterm role="cp"><primary>users (admin file)</primary></indexterm>Note that if you set this up in the straightforward
way, users receive notifications on the server machine.
One could of course write a <command>notify</command> script which
directed notifications elsewhere, but to make this
easy, cvsnt allows you to associate a notification
address for each user.  To do so create a file
<command>users</command> in <command>CVSROOT</command> with a line for each
user in the format <varname>user</varname>:<varname>value</varname>.  Then
instead of passing the name of the user to be notified
to <command>notify</command>, cvsnt will pass the <varname>value</varname>
(normally an email address on some other machine).
    </para>
    <para>
cvsnt does not notify you for your own changes.
Currently this check is done based on whether the user
name of the person taking the action which triggers
notification matches the user name of the person
getting notification.  In fact, in general, the watches
features only track one edit by each user.  It probably
would be more useful if watches tracked each working
directory separately, so this behavior might be worth
changing.
    </para>
</sect2>
   <sect2 id="Editing-files">
    <title>How to edit a file which is being watched
</title>

    <para><indexterm role="cp"><primary>Checkout, as term for getting ready to edit</primary></indexterm>Since a file which is being watched is checked out
read-only, you cannot simply edit it.  To make it
read-write, and inform others that you are planning to
edit it, use the <command>cvs edit</command> command.  Some systems
call this a <firstterm>checkout</firstterm>, but cvsnt uses that term
for obtaining a copy of the sources (<xref linkend="Getting-the-source" />), an operation which those systems call a
<firstterm>get</firstterm> or a <firstterm>fetch</firstterm>.
    </para>

    <para><indexterm role="cp"><primary>edit (subcommand)</primary></indexterm><function>cvs edit</function> [options] files &hellip;
<indexterm role="fn"><primary>cvs edit</primary></indexterm>
Prepare to edit the working files <varname>files</varname>.  cvsnt makes the
<varname>files</varname> read-write, and notifies users who have requested
<command>edit</command> notification for any of <varname>files</varname>.
    </para>

    <para>
The <command>cvs edit</command> command accepts the same <varname>options</varname> as the
<command>cvs watch add</command> command, and establishes a temporary watch for the
user on <varname>files</varname>; cvsnt will remove the watch when <varname>files</varname> are
<command>unedit</command>ed or <command>commit</command>ted.  If the user does not wish to
receive notifications, she should specify <command>-a none</command>.
    </para>

    <para>
The <varname>files</varname> and options are processed as for the <command>cvs
watch</command> commands.
    </para>

    <para>
If the <command>-c</command> option is given, then the file is checked for existing editors
before the edit can proceed.  In this way a reasonable facsimile of 'reserved edits'
can be achieved (note however this is a suboptimal way to use cvsnt).
    </para>

<para>
The <command>-z</command> option stores the edited base revision in a compressed form. This is useful if you are using an IDE which tends to pick up the base revisions while searhing files. Its also saves quite a bit of disk space on large edits.
</para>
    <para>
Normally when you are done with a set of changes, you
use the <command>cvs commit</command> command, which checks in your
changes and returns the watched files to their usual
read-only state.  But if you instead decide to abandon
your changes, or not to make any changes, you can use
the <command>cvs unedit</command> command.
    </para>
    <para><indexterm role="cp"><primary>unedit (subcommand)</primary></indexterm><indexterm role="cp"><primary>Abandoning work</primary></indexterm><indexterm role="cp"><primary>Reverting to repository version</primary></indexterm>
<function>cvs unedit</function> [<command>-lR</command>] files &hellip;
<indexterm role="fn"><primary>cvs unedit</primary></indexterm>
Abandon work on the working files <varname>files</varname>, and revert them to the
repository versions on which they are based.  cvsnt makes those
<varname>files</varname> read-only for which users have requested notification using
<command>cvs watch on</command>.  cvsnt notifies users who have requested <command>unedit</command>
notification for any of <varname>files</varname>.
    </para>

    <para>
The <varname>files</varname> and options are processed as for the
<command>cvs watch</command> commands.
    </para>

    <para>
If watches are not in use, the <command>unedit</command> command
probably does not work, and the way to revert to the
repository version is to remove the file and then use
<command>cvs update</command> to get a new copy.  The meaning is
not precisely the same; removing and updating may also
bring in some changes which have been made in the
repository since the last time you updated.
       </para>
    <para>
Repository administrators can use the 'unedit others' option <command>-u</command>.
Only use this as a last resort as it only does the server side
of the unedit.
    </para>
</sect2>
   <sect2 id="Watch-information">
    <title>Information about who is watching and editing
</title>

    <para><indexterm role="cp"><primary>watchers (subcommand)</primary></indexterm><function>cvs watchers</function> [<command>-lR</command>] files &hellip;
<indexterm role="fn"><primary>cvs watchers</primary></indexterm>
List the users currently watching changes to <varname>files</varname>.  The report
includes the files being watched, and the mail address of each watcher.
    </para>

    <para>
The <varname>files</varname> and options are processed as for the
<command>cvs watch</command> commands.
    </para>

    <para><indexterm role="cp"><primary>editors (subcommand)</primary></indexterm>
<function>cvs editors</function> [<command>-lR</command>] files &hellip;
<indexterm role="fn"><primary>cvs editors</primary></indexterm>
List the users currently working on <varname>files</varname>.  The report
includes the mail address of each user, the time when the user began
working with the file, and the host and path of the working directory
containing the file.
    </para>

    <para>
The <varname>files</varname> and options are processed as for the
<command>cvs watch</command> commands.
    </para>
</sect2>
   <sect2 id="Watches-Compatibility">
    <title>Using watches with old versions of CVS
</title>

    <para><indexterm role="cp"><primary>CVS 1.6, and watches</primary></indexterm>If you use the watch features on a repository, it
creates <command>CVS</command> directories in the repository and
stores the information about watches in that directory.
If you attempt to use cvsnt 1.6 or earlier with the
repository, you get an error message such as the
following (all on one line):
    </para>

    <para><screen>cvs update: cannot open CVS/Entries for reading:
No such file or directory
</screen>    </para>
    <para>
and your operation will likely be aborted.  To use the
watch features, you must upgrade all copies of cvsnt
which use that repository in local or server mode.  If
you cannot upgrade, use the <command>watch off</command> and
<command>watch remove</command> commands to remove all watches, and
that will restore the repository to a state which
cvsnt 1.6 can cope with.
    </para>
</sect2></sect1>
  <sect1 id="Choosing-a-model">
   <title>Choosing between reserved or unreserved checkouts
</title>
   <para><indexterm role="cp"><primary>Choosing, reserved or unreserved checkouts</primary></indexterm>
Reserved and unreserved checkouts each have pros and
cons.  Let it be said that a lot of this is a matter of
opinion or what works given different groups' working
styles, but here is a brief description of some of the
issues.  There are many ways to organize a team of
developers.  cvsnt does not try to enforce a certain
organization.  It is a tool that can be used in several
ways.
   </para>

   <para>
Reserved checkouts can be very counter-productive.  If
two persons want to edit different parts of a file,
there may be no reason to prevent either of them from
doing so.  Also, it is common for someone to take out a
lock on a file, because they are planning to edit it,
but then forget to release the lock.
   </para>

   <para>
People, especially people who are familiar with
reserved checkouts, often wonder how often conflicts
occur if unreserved checkouts are used, and how
difficult they are to resolve.  The experience with
many groups is that they occur rarely and usually are
relatively straightforward to resolve.
   </para>

   <para>
The rarity of serious conflicts may be surprising, until one realizes
that they occur only when two developers disagree on the proper design
for a given section of code; such a disagreement suggests that the
team has not been communicating properly in the first place.  In order
to collaborate under <emphasis>any</emphasis> source management regimen, developers
must agree on the general design of the system; given this agreement,
overlapping changes are usually straightforward to merge.
   </para>

   <para>
In some cases unreserved checkouts are clearly
inappropriate.  If no merge tool exists for the kind of
file you are managing (for example word processor files
or files edited by Computer Aided Design programs), and
it is not desirable to change to a program which uses a
mergeable data format, then resolving conflicts is
going to be unpleasant enough that you generally will
be better off to simply avoid the conflicts instead, by
using reserved checkouts.
   </para>

   <para>
The watches features described above in <xref linkend="Watches" />
can be considered to be an intermediate model between
reserved checkouts and unreserved checkouts.  When you
go to edit a file, it is possible to find out who else
is editing it.  And rather than having the system
simply forbid both people editing the file, it can tell
you what the situation is and let you figure out
whether it is a problem in that particular case or not.
Therefore, for some groups it can be considered the
best of both the reserved checkout and unreserved
checkout worlds.
   </para>

</sect1></chapter>
 <chapter id="Revision-management">
  <title>Revision management
</title>
  <para><indexterm role="cp"><primary>Revision management</primary></indexterm>
  </para>

  <para>
If you have read this far, you probably have a pretty
good grasp on what cvsnt can do for you.  This
chapter talks a little about things that you still have
to decide.
  </para>

  <para>
If you are doing development on your own using cvsnt
you could probably skip this chapter.  The questions
this chapter takes up become more important when more
than one person is working in a repository.
  </para>

  <sect1 id="When-to-commit">
   <title>When to commit?
</title>
   <para><indexterm role="cp"><primary>When to commit</primary></indexterm><indexterm role="cp"><primary>Commit, when to</primary></indexterm><indexterm role="cp"><primary>Policy</primary></indexterm>
Your group should decide which policy to use regarding
commits.  Several policies are possible, and as your
experience with cvsnt grows you will probably find
out what works for you.
   </para>

   <para>
If you commit files too quickly you might commit files
that do not even compile.  If your partner updates his
working sources to include your buggy file, he will be
unable to compile the code.  On the other hand, other
persons will not be able to benefit from the
improvements you make to the code if you commit very
seldom, and conflicts will probably be more common.
   </para>

   <para>
It is common to only commit files after making sure
that they can be compiled.  Some sites require that the
files pass a test suite.  Policies like this can be
enforced using the commitinfo file
(<xref linkend="commitinfo" />), but you should think twice before
you enforce such a convention.  By making the
development environment too controlled it might become
too regimented and thus counter-productive to the real
goal, which is to get software written.
   </para>

</sect1></chapter>
 <chapter id="Keyword-substitution">
  <title>Keyword substitution
</title>
  <para><indexterm role="cp"><primary>Keyword substitution</primary></indexterm><indexterm role="cp"><primary>Keyword expansion</primary></indexterm><indexterm role="cp"><primary>Identifying files</primary></indexterm>
  </para>

  <para>
As long as you edit source files inside a working
directory you can always find out the state of
your files via <command>cvs status</command> and <command>cvs log</command>.
But as soon as you export the files from your
development environment it becomes harder to identify
which revisions they are.
  </para>

  <para>
cvsnt can use a mechanism known as <firstterm>keyword
substitution</firstterm> (or <firstterm>keyword expansion</firstterm>) to help
identifying the files.  Embedded strings of the form
<command>$<varname>keyword</varname>$</command> and
<command>$<varname>keyword</varname>:&hellip;$</command> in a file are replaced
with strings of the form
<command>$<varname>keyword</varname>:<varname>value</varname>$</command> whenever you obtain
a new revision of the file.
  </para>

  <sect1 id="Keyword-list">
   <title>Keyword List
</title>
   <para><indexterm role="cp"><primary>Keyword List</primary></indexterm>
   </para>

   <para>
This is a list of the keywords:
   </para>

   <variablelist>
    <title><indexterm role="cp"><primary>Author keyword</primary></indexterm></title>
    <varlistentry>
     <term><command>&dollar;Author&dollar;</command></term>
     <listitem>
      <para>
The login name of the user who checked in the revision.
      </para>

      <para><indexterm role="cp"><primary>Date keyword</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>&dollar;Date&dollar;</command></term>
     <listitem>
      <para>
The date and time (UTC) the revision was checked in.
      </para>

      <para><indexterm role="cp"><primary>Header keyword</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>&dollar;Header&dollar;</command></term>
     <listitem>
      <para>
A standard header containing the full pathname of the
rcs file, the revision number, the date (UTC), the
author, the state, and the locker (if locked).  Files
will normally never be locked when you use cvsnt.
      </para>

      <para><indexterm role="cp"><primary>Id keyword</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>&dollar;Id&dollar;</command></term>
     <listitem>
      <para>
Same as <command>&dollar;Header&dollar;</command>, except that the rcs
filename is without a path.
      </para>

      <para><indexterm role="cp"><primary>Name keyword</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>&dollar;Name&dollar;</command></term>
     <listitem>
      <para>
Tag name used to check out this file.  The keyword is
expanded only if one checks out with an explicit tag
name.  For example, when running the command <command>cvs
co -r first</command>, the keyword expands to <command>Name: first</command>.
      </para>

      <para><indexterm role="cp"><primary>Locker keyword</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>&dollar;Locker:&dollar;</command></term>
     <listitem>
      <para>
The login name of the user who locked the revision
(empty if not locked, which is the normal case unless
<command>cvs admin -l</command> is in use).
      </para>

      <para><indexterm role="cp"><primary>Log keyword</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>&dollar;Log&dollar;</command></term>
     <listitem>
      <para>
The log message supplied during commit, preceded by a
header containing the rcs filename, the revision
number, the author, and the date (UTC).  Existing log
messages are <emphasis>not</emphasis> replaced.  Instead, the new log
message is inserted after <command>&dollar;Log&dollar;</command>.
Each new line is prefixed with the same string which
precedes the <command>$Log</command> keyword.  For example, if the
file contains
      </para>

      <para><screen>  /* Here is what people have been up to:
   *
   * &dollar;Log: foo.txt,v &dollar;
   * Revision 1.1  1997/01/03 14:23:51  joe
   * Add the superfrobnicate option
   *
   */
</screen>           </para>


      <para>
then additional lines which are added when expanding
the <command>$Log</command> keyword will be preceded by <command>   * </command>.
Unlike previous versions of cvsnt and rcs, the
<firstterm>comment leader</firstterm> from the rcs file is not used.
The <command>$Log</command> keyword is useful for
accumulating a complete change log in a source file,
but for several reasons it can be problematic.
<xref linkend="Log-keyword" />.
      </para>

      <para><indexterm role="cp"><primary>rcsfile keyword</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>&dollar;rcsfile&dollar;</command></term>
     <listitem>
      <para>
The name of the rcs file without a path.
      </para>

      <para><indexterm role="cp"><primary>Revision keyword</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>&dollar;Revision&dollar;</command></term>
     <listitem>
      <para>
The revision number assigned to the revision.
      </para>

      <para><indexterm role="cp"><primary>Source keyword</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>&dollar;Source&dollar;</command></term>
     <listitem>
      <para>
The full pathname of the rcs file.
      </para>

      <para><indexterm role="cp"><primary>State keyword</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>&dollar;State&dollar;</command></term>
     <listitem>
      <para>
The state assigned to the revision.  States can be
assigned with <command>cvs admin -s</command>--see <xref linkend="admin-options" />.
      </para>
</listitem></varlistentry></variablelist>

</sect1>
  <sect1 id="Using-keywords">
   <title>Using keywords
</title>

   <para>
To include a keyword string you simply include the
relevant text string, such as <command>&dollar;Id&dollar;</command>, inside the
file, and commit the file.  cvsnt will automatically
expand the string as part of the commit operation.
   </para>

   <para>
It is common to embed the <command>&dollar;Id&dollar;</command> string in
the source files so that it gets passed through to
generated files.  For example, if you are managing
computer program source code, you might include a
variable which is initialized to contain that string.
Or some C compilers may provide a <command>#pragma ident</command>
directive.  Or a document management system might
provide a way to pass a string through to generated
files.
   </para>


   <para><indexterm role="cp"><primary>Ident (shell command)</primary></indexterm>The <command>ident</command> command (which is part of the rcs
package) can be used to extract keywords and their
values from a file.  This can be handy for text files,
but it is even more useful for extracting keywords from
binary files.
   </para>

   <para><screen>$ ident samp.c
samp.c:
     &dollar;Id&dollar;
$ gcc samp.c
$ ident a.out
a.out:
     &dollar;Id: cvs.dbk,v 1.1.2.1 2004/04/16 14:14:42 tmh Exp &dollar;
</screen>   </para>
   <para><indexterm role="cp"><primary>What (shell command)</primary></indexterm>Sccs is another popular revision control system.
It has a command, <command>what</command>, which is very similar to
<command>ident</command> and used for the same purpose.  Many sites
without rcs have sccs.  Since <command>what</command>
looks for the character sequence <command>@(#)</command> it is
easy to include keywords that are detected by either
command.  Simply prefix the keyword with the
magic sccs phrase, like this:
   </para>
   <para><screen>
static char *id="@(#) &dollar;Id&dollar;";
</screen>      </para>
</sect1>
  <sect1 id="Avoiding-substitution">
   <title>Avoiding substitution
</title>

   <para>
Keyword substitution has its disadvantages.  Sometimes
you might want the literal text string
<command>&dollar;Author&dollar;</command> to appear inside a file without
cvsnt interpreting it as a keyword and expanding it
into something like <command>&dollar;Author&dollar;</command>.
   </para>

   <para>
There is unfortunately no way to selectively turn off
keyword substitution.  You can use <command>-ko</command>
(<xref linkend="Substitution-modes" />) to turn off keyword
substitution entirely.
   </para>

   <para>
In many cases you can avoid using keywords in
the source, even though they appear in the final
product.  For example, the source for this manual
contains <command>$@asis{}Author$</command> whenever the text
<command>&dollar;Author&dollar;</command> should appear.  In <command>nroff</command>
and <command>troff</command> you can embed the null-character
<command>\&amp;</command> inside the keyword for a similar effect.
   </para>

</sect1>
  <sect1 id="Substitution-modes">
   <title>Substitution modes
</title>
   <para><indexterm role="cp"><primary>Keyword substitution, changing modes</primary></indexterm><indexterm role="cp"><primary>-k (keyword substitution)</primary></indexterm><indexterm role="cp"><primary>Kflag</primary></indexterm>
Each file has a stored default substitution mode, and
each working directory copy of a file also has a
substitution mode.  The former is set by the <command>-k</command>
option to <command>cvs add</command> and <command>cvs admin</command>; the
latter is set by the <command>-k</command> or <command>-A</command> options to <command>cvs
checkout</command> or <command>cvs update</command>.  <command>cvs diff</command> also
has a <command>-k</command> option.  For some examples,
see <xref linkend="Binary-files" />, and <xref linkend="Merging-and-keywords" />.
   </para>

   <para>
The modes available are defined by combining an optional
encoding with a series of options.
   </para>

   <para>
Some combinations were not available on older CVS versions
so be careful if you want to access your repository from
older clients.  The cvsnt server will automatically downgrade
some of these options if an older client fetches a file.
   </para>

   <para>
Encodings:
   </para>

   <variablelist>
    <varlistentry>
     <term><command>t</command></term>
     <listitem>
      <para>
Treat the file as a text file.  This is the default setting if no
encoding is specified.
      </para>

      <para>
MBCS character sets that don't change the behaviour of CR/LF and NULL
should also work in this mode.  eg. Shift-JIS and EUC.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>b</command></term>
     <listitem>
      <para>
Treat the file as binary.  No interpretation is done of the contents
and they are stored verbatim.  Be default no keyword expansion is done.
Binary files are considered non-mergable by CVS.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>B</command></term>
     <listitem>
      <para>
Treat the file as binary.  No interpretation is done of the contents
and they are stored verbatim.  Be default no keyword expansion is done.
Binary files are considered non-mergable by CVS.  In addition, an alternate
storage algorithm is used that is optimised for storage of binary files.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>u</command></term>
     <listitem>
      <para>
Treat the file as Unicode.  The file will be checked in/out in UCS-2 (or
UTF-16) encoding and internally stored as UTF-8 by the server.
      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>{...}</command></term>
     <listitem>
      <para>
      Use an extended encoding.  Currently supported encodings are:
      </para>
      <variablelist>
      <varlistentry>
      <term><command>ucs2le</command></term>
      <term><command>utf16le</command></term>
      <listitem>
      <para>
      Little-endian UCS-2 without BOM.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term><command>ucs2be</command></term>
      <term><command>utf16be</command></term>
      <listitem>
      <para>
      Big-endian UCS-2 without BOM.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term><command>ucs2le_bom</command></term>
      <term><command>utf16le_bom</command></term>
      <listitem>
      <para>
      Little-endian UCS-2 with BOM.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term><command>ucs2be_bom</command></term>
      <term><command>utf16be_bom</command></term>
      <listitem>
      <para>
      Big-endian UCS-2 with BOM.
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </listitem></varlistentry></variablelist>
   <para>
Flags:
   </para>

   <variablelist>
    <varlistentry>
     <term><command>k</command></term>
     <listitem>
      <para>
Preserve the keyword string (default).  When combined
with the v flag this generates results using the default
form, e.g.
<command>&dollar;Revision&dollar;</command> for the <command>Revision</command>
keyword.  On its own it produces output with no keywords
expanded.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>v</command></term>
     <listitem>
      <para>
Generate keyword values for keyword strings.  Normally paired
with the k option.  If it is used on its own the effect is to
strip keywords from the output - for
example, for the <command>Revision</command> keyword, generate the string
<command>5.7</command> instead of <command>&dollar;Revision: 1.1.2.1&dollar;</command>.
This can help generate files in programming languages
where it is hard to strip keyword delimiters like
<command>&dollar;Revision&dollar;</command> from a string.  However,
further keyword substitution cannot be performed once
the keyword names are removed, so this option should be
used with care.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>l</command></term>
     <listitem>
      <para>
Insert the lockers name if the given revision is currently locked.
The locker's name is only relevant if <command>cvs admin
-l</command> is in use.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>o</command></term>
     <listitem>
      <para>
Generate the old keyword string, present in the working
file just before it was checked in.  For example, for
the <command>Revision</command> keyword, generate the string
<command>&dollar;Revision: 1.1.2.1;&dollar;</command> instead of
<command>&dollar;Revision&dollar;</command> if that is how the
string appeared when the file was checked in.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>L</command></term>
     <listitem>
      <para>
When checking out, always create a file with Unix line
endings no matter what the native line ending format is.
      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>z</command></term>
     <listitem>
      <para>
      Compress the files and deltas when they are stored.  This sacrifices speed for
      disk space - only use if disk space is at a premium.
      </para></listitem></varlistentry></variablelist>
</sect1>
  <sect1 id="Log-keyword">
   <title>&dollar;Log&dollar;</title>
   <para>
The <command>&dollar;Log&dollar;</command> keyword is somewhat
controversial.  As long as you are working on your
development system the information is easily accessible
even if you do not use the <command>&dollar;Log&dollar;</command>
keyword--just do a <command>cvs log</command>.  Once you export
the file the history information might be useless
anyhow.
   </para>

   <para>
A more serious concern is that cvsnt is not good at
handling <command>&dollar;Log&dollar;</command> entries when a branch is
merged onto the main trunk.  Conflicts often result
from the merging operation.
   </para>

   <para>
People also tend to "fix" the log entries in the file
(correcting spelling mistakes and maybe even factual
errors).  If that is done the information from
<command>cvs log</command> will not be consistent with the
information inside the file.  This may or may not be a
problem in real life.
   </para>

   <para>
It has been suggested that the <command>&dollar;Log&dollar;</command>
keyword should be inserted <emphasis>last</emphasis> in the file, and
not in the files header, if it is to be used at all.
That way the long list of change messages will not
interfere with everyday source file browsing.
   </para>

</sect1></chapter>
 <chapter id="Tracking-sources">
  <title>Tracking third-party sources
</title>
  <para><indexterm role="cp"><primary>Third-party sources</primary></indexterm><indexterm role="cp"><primary>Tracking sources</primary></indexterm>
If you modify a program to better fit your site, you
probably want to include your modifications when the next
release of the program arrives.  cvsnt can help you with
this task.
  </para>

  <para><indexterm role="cp"><primary>Vendor</primary></indexterm><indexterm role="cp"><primary>Vendor branch</primary></indexterm><indexterm role="cp"><primary>Branch, vendor-</primary></indexterm>In the terminology used in cvsnt, the supplier of the
program is called a <firstterm>vendor</firstterm>.  The unmodified
distribution from the vendor is checked in on its own
branch, the <firstterm>vendor branch</firstterm>.  cvsnt reserves branch
1.1.1 for this use.
  </para>

  <para>
When you modify the source and commit it, your revision
will end up on the main trunk.  When a new release is
made by the vendor, you commit it on the vendor branch
and copy the modifications onto the main trunk.
  </para>

  <para>
Use the <command>import</command> command to create and update
the vendor branch.  When you import a new file,
the vendor branch is made the `head' revision, so
anyone that checks out a copy of the file gets that
revision.  When a local modification is committed it is
placed on the main trunk, and made the `head'
revision.
  </para>

  <sect1 id="First-import">
   <title>Importing for the first time
</title>
   <para><indexterm role="cp"><primary>Importing modules</primary></indexterm>
Use the <command>import</command> command to check in the sources
for the first time.  When you use the <command>import</command>
command to track third-party sources, the <firstterm>vendor
tag</firstterm> and <firstterm>release tags</firstterm> are useful.  The
<firstterm>vendor tag</firstterm> is a symbolic name for the branch
(which is always 1.1.1, unless you use the <command>-b
<varname>branch</varname></command> flag--see <xref linkend="Multiple-vendor-branches" />.).  The
<firstterm>release tags</firstterm> are symbolic names for a particular
release, such as <command>FSF_0_04</command>.
   </para>

   <para>
Note that <command>import</command> does <emphasis>not</emphasis> change the
directory in which you invoke it.  In particular, it
does not set up that directory as a cvsnt working
directory; if you want to work with the sources import
them first and then check them out into a different
directory (<xref linkend="Getting-the-source" />).
   </para>

   <para><indexterm role="cp"><primary>wdiff (import example)</primary></indexterm>Suppose you have the sources to a program called
<command>wdiff</command> in a directory <command>wdiff-0.04</command>,
and are going to make private modifications that you
want to be able to use even when new releases are made
in the future.  You start by importing the source to
your repository:
   </para>

   <para><screen>$ cd wdiff-0.04
$ cvs import -m "Import of FSF v. 0.04" fsf/wdiff FSF_DIST WDIFF_0_04
</screen>   </para>
   <para>
The vendor tag is named <command>FSF_DIST</command> in the above
example, and the only release tag assigned is
<command>WDIFF_0_04</command>.
   </para>
</sect1>
  <sect1 id="Update-imports">
   <title>Updating with the import command
</title>

   <para>
When a new release of the source arrives, you import it into the
repository with the same <command>import</command> command that you used to set up
the repository in the first place.  The only difference is that you
specify a different release tag this time.
   </para>

   <para><screen>$ tar xfz wdiff-0.05.tar.gz
$ cd wdiff-0.05
$ cvs import -m "Import of FSF v. 0.05" fsf/wdiff FSF_DIST WDIFF_0_05
</screen>   </para>
   <para>
For files that have not been modified locally, the newly created
revision becomes the head revision.  If you have made local
changes, <command>import</command> will warn you that you must merge the changes
into the main trunk, and tell you to use <command>checkout -j</command> to do so.
   </para>
   <para><screen>
$ cvs checkout -jFSF_DIST:yesterday -jFSF_DIST wdiff
</screen>      </para>

   <para>
The above command will check out the latest revision of
<command>wdiff</command>, merging the changes made on the vendor branch <command>FSF_DIST</command>
since yesterday into the working copy.  If any conflicts arise during
the merge they should be resolved in the normal way (<xref linkend="Conflicts-example" />).  Then, the modified files may be committed.
   </para>

   <para>
Using a date, as suggested above, assumes that you do
not import more than one release of a product per
day. If you do, you can always use something like this
instead:
   </para>

   <para><screen>
$ cvs checkout -jWDIFF_0_04 -jWDIFF_0_05 wdiff
</screen>   </para>

   <para>
In this case, the two above commands are equivalent.
   </para>

</sect1>
  <sect1 id="Reverting-local-changes">
   <title>Reverting to the latest vendor release
</title>

   <para>
You can also revert local changes completely and return
to the latest vendor release by changing the `head'
revision back to the vendor branch on all files.  For
example, if you have a checked-out copy of the sources
in <command>~/work.d/wdiff</command>, and you want to revert to the
vendor's version for all the files in that directory,
you would type:
   </para>

   <para><screen>$ cd ~/work.d/wdiff
$ cvs admin -bWDIFF .
</screen>   </para>

   <para>
You must specify the <command>-bWDIFF</command> without any space
after the <command>-b</command>.  <xref linkend="admin-options" />.
   </para>

</sect1>
  <sect1 id="Binary-files-in-imports">
   <title>How to handle binary files with cvs import
</title>

   <para>
Use the <command>-k</command> wrapper option to tell import which
files are binary.  <xref linkend="Wrappers" />.
   </para>

</sect1>
  <sect1 id="Keywords-in-imports">
   <title>How to handle keyword substitution with cvs import
</title>

   <para>
The sources which you are importing may contain
keywords (<xref linkend="Keyword-substitution" />).  For example,
the vendor may use cvsnt or some other system
which uses similar keyword expansion syntax.  If you
just import the files in the default fashion, then
the keyword expansions supplied by the vendor will
be replaced by keyword expansions supplied by your
own copy of cvsnt.  It may be more convenient to
maintain the expansions supplied by the vendor, so
that this information can supply information about
the sources that you imported from the vendor.
   </para>

   <para>
To maintain the keyword expansions supplied by the
vendor, supply the <command>-ko</command> option to <command>cvs
import</command> the first time you import the file.
This will turn off keyword expansion
for that file entirely, so if you want to be more
selective you'll have to think about what you want
and use the <command>-k</command> option to <command>cvs update</command> or
<command>cvs admin</command> as appropriate.
   </para>

</sect1>
  <sect1 id="Multiple-vendor-branches">
   <title>Multiple vendor branches
</title>

   <para>
All the examples so far assume that there is only one
vendor from which you are getting sources.  In some
situations you might get sources from a variety of
places.  For example, suppose that you are dealing with
a project where many different people and teams are
modifying the software.  There are a variety of ways to
handle this, but in some cases you have a bunch of
source trees lying around and what you want to do more
than anything else is just to all put them in cvsnt so
that you at least have them in one place.
   </para>

   <para>
For handling situations in which there may be more than
one vendor, you may specify the <command>-b</command> option to
<command>cvs import</command>.  It takes as an argument the vendor
branch to import to.  The default is <command>-b 1.1.1</command>.
   </para>

   <para>
For example, suppose that there are two teams, the red
team and the blue team, that are sending you sources.
You want to import the red team's efforts to branch
1.1.1 and use the vendor tag RED.  You want to import
the blue team's efforts to branch 1.1.3 and use the
vendor tag BLUE.  So the commands you might use are:
   </para>

   <para><screen>$ cvs import dir RED RED_1-0
$ cvs import -b 1.1.3 dir BLUE BLUE_1-5
</screen>   </para>
   <para>
Note that if your vendor tag does not match your
<command>-b</command> option, cvsnt will not detect this case!  For
example,
   </para>
   <para><screen>
$ cvs import -b 1.1.3 dir RED RED_1-0
</screen>      </para>

   <para>
Be careful; this kind of mismatch is sure to sow
confusion or worse.  I can't think of a useful purpose
for the ability to specify a mismatch here, but if you
discover such a use, don't.  cvsnt is likely to make this
an error in some future release.
   </para>

</sect1></chapter>
 <chapter id="Builds">
  <title>How your build system interacts with CVS
</title>
  <para><indexterm role="cp"><primary>Builds</primary></indexterm><indexterm role="cp"><primary>make</primary></indexterm>
As mentioned in the introduction, cvsnt does not
contain software for building your software from source
code.  This section describes how various aspects of
your build system might interact with cvsnt.
  </para>

  <para>
One common question, especially from people who are
accustomed to rcs, is how to make their build get
an up to date copy of the sources.  The answer to this
with cvsnt is two-fold.  First of all, since
cvsnt itself can recurse through directories, there
is no need to modify your <command>Makefile</command> (or whatever
configuration file your build tool uses) to make sure
each file is up to date.  Instead, just use two
commands, first <command>cvs -q update</command> and then
<command>make</command> or whatever the command is to invoke your
build tool.  Secondly, you do not necessarily
<emphasis>want</emphasis> to get a copy of a change someone else made
until you have finished your own work.  One suggested
approach is to first update your sources, then
implement, build and
test the change you were thinking of, and then commit
your sources (updating first if necessary).  By
periodically (in between changes, using the approach
just described) updating your entire tree, you ensure
that your sources are sufficiently up to date.
  </para>

  <para><indexterm role="cp"><primary>Bill of materials</primary></indexterm>One common need is to record which versions of which
source files went into a particular build.  This kind
of functionality is sometimes called <firstterm>bill of
materials</firstterm> or something similar.  The best way to do
this with cvsnt is to use the <command>tag</command> command to
record which versions went into a given build
(<xref linkend="Tags" />).
  </para>

  <para>
Using cvsnt in the most straightforward manner
possible, each developer will have a copy of the entire
source tree which is used in a particular build.  If
the source tree is small, or if developers are
geographically dispersed, this is the preferred
solution.  In fact one approach for larger projects is
to break a project down into smaller
separately-compiled subsystems, and arrange a way of
releasing them internally so that each developer need
check out only those subsystems which are they are
actively working on.
  </para>

  <para>
Another approach is to set up a structure which allows
developers to have their own copies of some files, and
for other files to access source files from a central
location.  Many people have come up with some such a
system using features such as the symbolic link feature
found in many operating systems, or the <command>VPATH</command>
feature found in many versions of <command>make</command>.  One build
tool which is designed to help with this kind of thing
is Odin (see
<command>ftp://ftp.cs.colorado.edu/pub/distribs/odin</command>).
  </para>

</chapter>
 <chapter id="Special-Files">
  <title>Special Files
</title>

  <para><indexterm role="cp"><primary>Special files</primary></indexterm><indexterm role="cp"><primary>Device nodes</primary></indexterm><indexterm role="cp"><primary>Ownership, saving in CVS</primary></indexterm><indexterm role="cp"><primary>Permissions, saving in CVS</primary></indexterm><indexterm role="cp"><primary>Hard links</primary></indexterm><indexterm role="cp"><primary>Symbolic links</primary></indexterm>
In normal circumstances, cvsnt works only with regular
files.  Every file in a project is assumed to be
persistent; it must be possible to open, read and close
them; and so on.  cvsnt also ignores file permissions and
ownerships, leaving such issues to be resolved by the
developer at installation time.  In other words, it is
not possible to "check in" a device into a repository;
if the device file cannot be opened, cvsnt will refuse to
handle it.  Files also lose their ownerships and
permissions during repository transactions.
  </para>


</chapter>
 <appendix id="CVS-commands">
  <title>Guide to CVS commands
</title>

  <para>
This appendix describes the overall structure of
cvsnt commands, and describes some commands in
detail (others are described elsewhere; for a quick
reference to cvsnt commands, <xref linkend="Invoking-CVS" />).
  </para>

  <sect1 id="Structure">
   <title>Overall structure of CVS commands
</title>
   <para><indexterm role="cp"><primary>Structure</primary></indexterm><indexterm role="cp"><primary>CVS command structure</primary></indexterm><indexterm role="cp"><primary>Command structure</primary></indexterm><indexterm role="cp"><primary>Format of CVS commands</primary></indexterm>
The overall format of all cvsnt commands is:
   </para>

   <para><screen>cvs [ cvs_options ] cvs_command [ command_options ] [ command_args ]
</screen>   </para>

   <variablelist>
    <varlistentry>
     <term><command>cvs</command></term>
     <listitem>
      <para>
The name of the cvsnt program.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs_options</command></term>
     <listitem>
      <para>
Some options that affect all sub-commands of cvsnt.  These are
described below.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs_command</command></term>
     <listitem>
      <para>
One of several different sub-commands.  Some of the commands have
aliases that can be used instead; those aliases are noted in the
reference manual for that command.  There are only two situations
where you may omit <command>cvs_command</command>: <command>cvs -H</command> elicits a
list of available commands, and <command>cvs -v</command> displays version
information on cvsnt itself.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>command_options</command></term>
     <listitem>
      <para>
Options that are specific for the command.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>command_args</command></term>
     <listitem>
      <para>
Arguments to the commands.
      </para></listitem></varlistentry></variablelist>   
   <para>
There is unfortunately some confusion between
<command>cvs_options</command> and <command>command_options</command>.
<command>-l</command>, when given as a <command>cvs_option</command>, only
affects some of the commands.  When it is given as a
<command>command_option</command> is has a different meaning, and
is accepted by more commands.  In other words, do not
take the above categorization too seriously.  Look at
the documentation instead.
   </para>
</sect1>
  <sect1 id="Exit-status">
   <title>CVS's exit status
</title>
   <para><indexterm role="cp"><primary>Exit status, of CVS</primary></indexterm>
cvsnt can indicate to the calling environment whether it
succeeded or failed by setting its <firstterm>exit status</firstterm>.
The exact way of testing the exit status will vary from
one operating system to another.  For example in a unix
shell script the <command>$?</command> variable will be 0 if the
last command returned a successful exit status, or
greater than 0 if the exit status indicated failure.
   </para>

   <para>
If cvsnt is successful, it returns a successful status;
if there is an error, it prints an error message and
returns a failure status.  The one exception to this is
the <command>cvs diff</command> command.  It will return a
successful status if it found no differences, or a
failure status if there were differences or if there
was an error.  Because this behavior provides no good
way to detect errors, in the future it is possible that
<command>cvs diff</command> will be changed to behave like the
other cvsnt commands.
   </para>

</sect1>
  <sect1 id="cvsrc">
   <title>Default options and the ~/.cvsrc and CVSROOT/cvsrc files
</title>
   <para><indexterm role="cp"><primary>.cvsrc file</primary></indexterm><indexterm role="cp"><primary>cvsrc file</primary></indexterm><indexterm role="cp"><primary>CVSROOT/cvsrc file</primary></indexterm><indexterm role="cp"><primary>Option defaults</primary></indexterm>
There are some <command>command_options</command> that are used so
often that you might have set up an alias or some other
means to make sure you always specify that option.  One
example (the one that drove the implementation of the
<command>.cvsrc</command> support, actually) is that many people find the
default output of the <command>diff</command> command to be very
hard to read, and that either context diffs or unidiffs
are much easier to understand.
   </para>

   <para>
The <command>~/.cvsrc</command> file is a way that you can add
default options to <command>cvs_commands</command> within cvs,
instead of relying on aliases or other shell scripts.
   </para>

   <para>
The format of the <command>~/.cvsrc</command> file is simple.  The
file is searched for a line that begins with the same
name as the <command>cvs_command</command> being executed.  If a
match is found, then the remainder of the line is split
up (at whitespace characters) into separate options and
added to the command arguments <emphasis>before</emphasis> any
options from the command line.
   </para>

   <para>
If a command has two names (e.g., <command>checkout</command> and
<command>co</command>), the official name, not necessarily the one
used on the command line, will be used to match against
the file.  So if this is the contents of the user's
<command>~/.cvsrc</command> file:
   </para>

   <para><screen>log -N
diff -u
update -P
checkout -P
</screen>   </para>

   <para>
the command <command>cvs checkout foo</command> would have the
<command>-P</command> option added to the arguments, as well as
<command>cvs co foo</command>.
   </para>

   <para>
With the example file above, the output from <command>cvs
diff foobar</command> will be in unidiff format.  <command>cvs diff
-c foobar</command> will provide context diffs, as usual.
Getting "old" format diffs would be slightly more
complicated, because <command>diff</command> doesn't have an option
to specify use of the "old" format, so you would need
<command>cvs -f diff foobar</command>.
   </para>

   <para>
In place of the command name you can use <command>cvsnt</command> to
specify global options (<xref linkend="Global-options" />).  For
example the following line in <command>.cvsrc</command>
   </para>

   <para><screen>
cvs -z6
</screen>   </para>
   <para>
causes cvsnt to use compression level 6.
   </para>
   <para>
The <command>CVSROOT/cvsrc</command> file on the server contains the default .cvsrc
file that is used by all compatible clients.  This is merged with the
local .cvsrc file and the result behaves as normal.
   </para>
   <para>
The CVSROOT/cvsrc file cannot contain global options (<xref linkend="Global-options" />)
as it is parsed after the server has started.
   </para>
   <para>
Older <command>cvsnt</command> clients and Unix cvs clients will not use the global cvsrc.
   </para>
</sect1>
  <sect1 id="Global-options">
   <title>Global options
</title>
   <para><indexterm role="cp"><primary>Options, global</primary></indexterm><indexterm role="cp"><primary>Global options</primary></indexterm><indexterm role="cp"><primary>Left-hand options</primary></indexterm>
The available <command>cvs_options</command> (that are given to the
left of <command>cvs_command</command>) are:
   </para>

   <variablelist>
    <varlistentry>
     <term><command>-allow-root=<varname>rootdir</varname></command></term>
     <listitem>
      <para>
Specify legal cvsroot directory.  See <xref linkend="Authentication-server" />.
      </para>

      <para><indexterm role="cp"><primary>Authentication, stream</primary></indexterm><indexterm role="cp"><primary>Stream authentication</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-a</command></term>
     <listitem>
      <para>
Authenticate all communication between the client and
the server.  Only has an effect on the cvsnt client.
As of this writing, this is only implemented when using
a GSSAPI connection (<xref linkend="GSSAPI-authenticated" />).
Authentication prevents certain sorts of attacks
involving hijacking the active tcp connection.
Enabling authentication does not enable encryption.
      </para>

      <para><indexterm role="cp"><primary>rcsBIN, overriding</primary></indexterm><indexterm role="cp"><primary>Overriding rcsBIN</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-b <varname>bindir</varname></command></term>
     <listitem>
      <para>
In CVS 1.9.18 and older, this specified that
rcs programs are in the <varname>bindir</varname> directory.
Current versions of cvsnt do not run rcs
programs; for compatibility this option is accepted,
but it does nothing.
      </para>

      <para><indexterm role="cp"><primary>TMPDIR, overriding</primary></indexterm><indexterm role="cp"><primary>Overriding TMPDIR</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-T <varname>tempdir</varname></command></term>
     <listitem>
      <para>
Use <varname>tempdir</varname> as the directory where temporary files are
located.  Overrides the setting of the <command>$TMPDIR</command> environment
variable and any precompiled directory.  This parameter should be
specified as an absolute pathname.
      </para>

      <para><indexterm role="cp"><primary>CVSROOT, overriding</primary></indexterm><indexterm role="cp"><primary>Overriding CVSROOT</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-d <varname>cvs_root_directory</varname></command></term>
     <listitem>
      <para>
Use <varname>cvs_root_directory</varname> as the root directory
pathname of the repository.  Overrides the setting of
the <command>$CVSROOT</command> environment variable.  <xref linkend="Repository" />.
      </para>

      <para><indexterm role="cp"><primary>EDITOR, overriding</primary></indexterm><indexterm role="cp"><primary>Overriding EDITOR</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-e <varname>editor</varname></command></term>
     <listitem>
      <para>
Use <varname>editor</varname> to enter revision log information.  Overrides the
setting of the <command>$CVSEDITOR</command> and <command>$EDITOR</command>
environment variables.  For more information, see
<xref linkend="Committing-your-changes" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-f</command></term>
     <listitem>
      <para>
Do not read the <command>~/.cvsrc</command> file.  This
option is most often used because of the
non-orthogonality of the cvsnt option set.  For
example, the <command>cvs log</command> option <command>-N</command> (turn off
display of tag names) does not have a corresponding
option to turn the display on.  So if you have
<command>-N</command> in the <command>~/.cvsrc</command> entry for <command>log</command>,
you may need to use <command>-f</command> to show the tag names.
      </para>
</listitem></varlistentry>
<varlistentry>
     <term><command>-F </command><varname>file</varname></term>
     <listitem>
      <para>
Read the contents of <varname>file</varname> and append it to the supplied
command line.  Arguments are separated by whitespace, and follow normal quoting
rules.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-H</command></term>
     <term><command>-help</command></term>
     <listitem>
      <para>
Display usage information about the specified <command>cvs_command</command>
(but do not actually execute the command).  If you don't specify
a command name, <command>cvs -H</command> displays overall help for
cvsnt, including a list of other help options.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-l</command></term>
     <listitem>
      <para>
Do not log the <command>cvs_command</command> in the command history (but execute it
anyway).  <xref linkend="history" />, for information on command history.
      </para>

      <para><indexterm role="cp"><primary>Read-only mode</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-n</command></term>
     <listitem>
      <para>
Do not change any files.  Attempt to execute the
<command>cvs_command</command>, but only to issue reports; do not remove,
update, or merge any existing files, or create any new files.
      </para>

      <para>
Note that cvsnt will not necessarily produce exactly
the same output as without <command>-n</command>.  In some cases
the output will be the same, but in other cases
cvsnt will skip some of the processing that would
have been required to produce the exact same output.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-N</command></term>
     <listitem>
      <para>
Enable :local: access to a network share.  Normally this is explicitly prohibited to discourage its
use.  It is recommended that you setup a proper server instead, as problems encountered using network
shares will not normally be supported.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-Q</command></term>
     <listitem>
      <para>
Cause the command to be really quiet; the command will only
generate output for serious problems.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-q</command></term>
     <listitem>
      <para>
Cause the command to be somewhat quiet; informational messages,
such as reports of recursion through subdirectories, are
suppressed.
      </para>

      <para><indexterm role="cp"><primary>Read-only files, and -r</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-r</command></term>
     <listitem>
      <para>
Make new working files read-only.  Same effect
as if the <command>$CVSREAD</command> environment variable is set
(<xref linkend="Environment-variables" />).  The default is to
make working files writable, unless watches are on
(<xref linkend="Watches" />).
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-s <varname>variable</varname>=<varname>value</varname></command></term>
     <listitem>
      <para>
Set a user variable (<xref linkend="Variables" />).
      </para>

      <para><indexterm role="cp"><primary>Trace</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-t</command></term>
     <listitem>
      <para>
Trace program execution; display messages showing the steps of
cvsnt activity.  Particularly useful with <command>-n</command> to explore the
potential impact of an unfamiliar command.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-v</command></term>
     <term><command>-version</command></term>
     <listitem>
      <para>
Display version and copyright information for cvsnt.
      </para>

      <para><indexterm role="cp"><primary>CVSREAD, overriding</primary></indexterm><indexterm role="cp"><primary>Overriding CVSREAD</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-w</command></term>
     <listitem>
      <para>
Make new working files read-write.  Overrides the
setting of the <command>$CVSREAD</command> environment variable.
Files are created read-write by default, unless <command>$CVSREAD</command> is
set or <command>-r</command> is given.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-x</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>Encryption</primary></indexterm>Encrypt all communication between the client and the
server.  Only has an effect on the cvsnt client.  As
of this writing, this is only implemented when using a
GSSAPI connection (<xref linkend="GSSAPI-authenticated" />).
Enabling encryption implies that message traffic is
also authenticated.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-z <varname>gzip-level</varname></command></term>
     <listitem>
      <para><indexterm role="cp"><primary>Compression</primary></indexterm><indexterm role="cp"><primary>Gzip</primary></indexterm>Set the compression level.
Valid levels are 1 (high speed, low compression) to
9 (low speed, high compression), or 0 to disable
compression (the default).
Only has an effect on the cvsnt client.
      </para>
</listitem></varlistentry></variablelist>
</sect1>
  <sect1 id="Common-options">
   <title>Common command options
</title>
   <para><indexterm role="cp"><primary>Common options</primary></indexterm><indexterm role="cp"><primary>Right-hand options</primary></indexterm>
This section describes the <command>command_options</command> that
are available across several cvsnt commands.  These
options are always given to the right of
<command>cvs_command</command>. Not all
commands support all of these options; each option is
only supported for commands where it makes sense.
However, when a command has one of these options you
can almost always count on the same behavior of the
option as in other commands.  (Other command options,
which are listed with the individual commands, may have
different behavior from one cvsnt command to the other).
   </para>

   <para><emphasis>Warning:</emphasis> the <command>history</command> command is an exception; it supports
many options that conflict even with these standard options.
   </para>

   <variablelist>
    <title><indexterm role="cp"><primary>Dates</primary></indexterm><indexterm role="cp"><primary>Time</primary></indexterm><indexterm role="cp"><primary>Specifying dates</primary></indexterm></title>
    <varlistentry>
     <term><command>-D <varname>date_spec</varname></command></term>
     <listitem>
      <para>
Use the most recent revision no later than <varname>date_spec</varname>.
<varname>date_spec</varname> is a single argument, a date description
specifying a date in the past.
      </para>

      <para>
The specification is <firstterm>sticky</firstterm> when you use it to make a
private copy of a source file; that is, when you get a working
file using <command>-D</command>, cvsnt records the date you specified, so that
further updates in the same directory will use the same date
(for more information on sticky tags/dates, <xref linkend="Sticky-tags" />).
      </para>

      <para><command>-D</command> is available with the <command>checkout</command>,
<command>diff</command>, <command>export</command>, <command>history</command>,
<command>rdiff</command>, <command>rtag</command>, and <command>update</command> commands.
(The <command>history</command> command uses this option in a
slightly different way; <xref linkend="history-options" />).
      </para>


      <para><indexterm role="cp"><primary>Timezone, in input</primary></indexterm><indexterm role="cp"><primary>Zone, time, in input</primary></indexterm>A wide variety of date formats are supported by
cvsnt.  The most standard ones are ISO8601 (from the
International Standards Organization) and the Internet
e-mail standard (specified in RFC822 as amended by
RFC1123).
      </para>

      <para>
ISO8601 dates have many variants but a few examples
are:
      </para>

      <para><screen>1972-09-24
1972-09-24 20:05
</screen>           </para>

      <para>
There are a lot more ISO8601 date formats, and cvsnt
accepts many of them, but you probably don't want to
hear the <emphasis>whole</emphasis> long story :-).
      </para>


      <para>
In addition to the dates allowed in Internet e-mail
itself, cvsnt also allows some of the fields to be
omitted.  For example:
      </para>

      <para><screen>
24 Sep 1972 20:05
24 Sep
</screen>           </para>

      <para>
The date is interpreted as being in the
local timezone, unless a specific timezone is
specified.
      </para>

      <para>
These two date formats are preferred.  However,
cvsnt currently accepts a wide variety of other date
formats.  They are intentionally not documented here in
any detail, and future versions of cvsnt might not
accept all of them.
      </para>

      <para>
One such format is
<command><varname>month</varname>/<varname>day</varname>/<varname>year</varname></command>.  This may
confuse people who are accustomed to having the month
and day in the other order; <command>1/4/96</command> is January 4,
not April 1.
      </para>

      <para>
Remember to quote the argument to the <command>-D</command>
flag so that your shell doesn't interpret spaces as
argument separators.  A command using the <command>-D</command>
flag can look like this:
      </para>

      <para><screen>
$ cvs diff -D "1 hour ago" cvs.texinfo
</screen>           </para>

      <para><indexterm role="cp"><primary>Forcing a tag match</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-f</command></term>
     <listitem>
      <para>
When you specify a particular date or tag to cvsnt commands, they
normally ignore files that do not contain the tag (or did not
exist prior to the date) that you specified.  Use the <command>-f</command> option
if you want files retrieved even when there is no match for the
tag or date.  (The most recent revision of the file
will be used).
      </para>

      <para>
Note that even with <command>-f</command>, a tag that you specify
must exist (that is, in some file, not necessary in
every file).  This is so that cvsnt will continue to
give an error if you mistype a tag name.
      </para>

      <para><command>-f</command> is available with these commands:
<command>annotate</command>, <command>checkout</command>, <command>export</command>,
<command>rdiff</command>, <command>rtag</command>, and <command>update</command>.
      </para>

      <para><emphasis>Warning:</emphasis>  The <command>commit</command> and <command>remove</command>
commands also have a
<command>-f</command> option, but it has a different behavior for
those commands.  See <xref linkend="commit-options" />, and
<xref linkend="Removing-files" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-k <varname>kflag</varname></command></term>
     <listitem>
      <para>
Alter the default processing of keywords.
<xref linkend="Keyword-substitution" />, for the meaning of
<varname>kflag</varname>.  Your <varname>kflag</varname> specification is
<firstterm>sticky</firstterm> when you use it to create a private copy
of a source file; that is, when you use this option
with the <command>checkout</command> or <command>update</command> commands,
cvsnt associates your selected <varname>kflag</varname> with the
file, and continues to use it with future update
commands on the same file until you specify otherwise.
      </para>

      <para>
The <command>-k</command> option is available with the <command>add</command>,
<command>checkout</command>, <command>diff</command>, <command>import</command> and
<command>update</command> commands.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-l</command></term>
     <listitem>
      <para>
Local; run only in current working directory, rather than
recursing through subdirectories.
      </para>

      <para><emphasis>Warning:</emphasis> this is not the same
as the overall <command>cvs -l</command> option, which you can specify to the
left of a cvs command!
      </para>

      <para>
Available with the following commands: <command>annotate</command>, <command>checkout</command>,
<command>commit</command>, <command>diff</command>, <command>edit</command>, <command>editors</command>, <command>export</command>,
<command>log</command>, <command>rdiff</command>, <command>remove</command>, <command>rtag</command>,
<command>status</command>, <command>tag</command>, <command>unedit</command>, <command>update</command>, <command>watch</command>,
and <command>watchers</command>.
      </para>

      <para><indexterm role="cp"><primary>Editor, avoiding invocation of</primary></indexterm><indexterm role="cp"><primary>Avoiding editor invocation</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>-m <varname>message</varname></command></term>
     <listitem>
      <para>
Use <varname>message</varname> as log information, instead of
invoking an editor.
      </para>

      <para>
Available with the following commands: <command>add</command>,
<command>commit</command> and <command>import</command>.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-n</command></term>
     <listitem>
      <para>
Do not run any checkout/commit/tag program.  (A program can be
specified to run on each of these activities, in the modules
database (<xref linkend="modules" />); this option bypasses it).
      </para>

      <para><emphasis>Warning:</emphasis> this is not the same as the overall <command>cvs -n</command>
option, which you can specify to the left of a cvs command!
      </para>

      <para>
Available with the <command>checkout</command>, <command>commit</command>, <command>export</command>,
and <command>rtag</command> commands.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-P</command></term>
     <listitem>
      <para>
Prune empty directories.  See <xref linkend="Removing-directories" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-p</command></term>
     <listitem>
      <para>
Pipe the files retrieved from the repository to standard output,
rather than writing them in the current directory.  Available
with the <command>checkout</command> and <command>update</command> commands.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-R</command></term>
     <listitem>
      <para>
Process directories recursively.  This is on by default.
      </para>

      <para>
Available with the following commands: <command>annotate</command>, <command>checkout</command>,
<command>commit</command>, <command>diff</command>, <command>edit</command>, <command>editors</command>, <command>export</command>,
<command>rdiff</command>, <command>remove</command>, <command>rtag</command>,
<command>status</command>, <command>tag</command>, <command>unedit</command>, <command>update</command>, <command>watch</command>,
and <command>watchers</command>.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-r <varname>tag</varname></command></term>
     <listitem>
      <para><indexterm role="cp"><primary>HEAD, special tag</primary></indexterm><indexterm role="cp"><primary>BASE, special tag</primary></indexterm>Use the revision specified by the <varname>tag</varname> argument instead of the
default <firstterm>head</firstterm> revision.  As well as arbitrary tags defined
with the <command>tag</command> or <command>rtag</command> command, two special tags are
always available: <command>HEAD</command> refers to the most recent version
available in the repository, and <command>BASE</command> refers to the
revision you last checked out into the current working directory.
      </para>


      <para>
The tag specification is sticky when you use this
with <command>checkout</command> or <command>update</command> to make your own
copy of a file: cvsnt remembers the tag and continues to use it on
future update commands, until you specify otherwise (for more information
on sticky tags/dates, <xref linkend="Sticky-tags" />).
      </para>

      <para>
The tag can be either a symbolic or numeric tag, as
described in <xref linkend="Tags" />, or the name of a branch, as
described in <xref linkend="Branching-and-merging" />.
      </para>

      <para>
Specifying the <command>-q</command> global option along with the
<command>-r</command> command option is often useful, to suppress
the warning messages when the rcs file
does not contain the specified tag.
      </para>

      <para><emphasis>Warning:</emphasis> this is not the same as the overall <command>cvs -r</command> option,
which you can specify to the left of a cvsnt command!
      </para>

      <para><command>-r</command> is available with the <command>checkout</command>, <command>commit</command>,
<command>diff</command>, <command>history</command>, <command>export</command>, <command>rdiff</command>,
<command>rtag</command>, and <command>update</command> commands.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>-W</command></term>
     <listitem>
      <para>
Specify file names that should be filtered.  You can
use this option repeatedly.  The spec can be a file
name pattern of the same type that you can specify in
the <command>.cvswrappers</command> file.
Available with the following commands: <command>import</command>,
and <command>update</command>.
      </para>
</listitem></varlistentry></variablelist>

</sect1>
  <sect1 id="admin">
   <title>admin--Administration
</title>
   <para><indexterm role="cp"><primary>Admin (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
Requires: repository, working directory.
     </para></listitem>
    <listitem>
     <para>
Changes: repository.
     </para></listitem>
    <listitem>
     <para>
Synonym: rcs
     </para></listitem></itemizedlist>
   <para>
This is the cvsnt interface to assorted
administrative facilities.  Some of them have
questionable usefulness for cvsnt but exist for
historical purposes.  Some of the questionable options
are likely to disappear in the future.  This command
<emphasis>does</emphasis> work recursively, so extreme care should be
used.
   </para>
   <para>
Do not use this command unless you know what
you are doing.  Some of the admin commands can have
unexpected consequences.
   </para>
   <para><indexterm role="cp"><primary>cvsadmin</primary></indexterm>On unix, if there is a group named <command>cvsadmin</command>,
only members of that group can run <command>cvs admin</command>
(except for the <command>cvs admin -k</command> command, which can
be run by anybody).  This group should exist on the
server, or any system running the non-client/server
cvsnt.  To disallow <command>cvs admin</command> for all users,
create a group with no users in it.  On NT, server
administrators are able to use the admin command.
   </para>
   <para>
See also .
   </para>


   <sect2 id="admin-options">
    <title>admin options
</title>

    <variablelist>
     <varlistentry>
      <term><command>-k<varname>subst</varname></command></term>
      <listitem>
       <para>
Set the default keyword
substitution to <varname>subst</varname>.  <xref linkend="Keyword-substitution" />.  Giving an explicit <command>-k</command> option to
<command>cvs update</command>, <command>cvs export</command>, or <command>cvs
checkout</command> overrides this default.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-l[<varname>rev</varname>]</command></term>
      <listitem>
       <para>
Lock the revision with number <varname>rev</varname>.  If a branch
is given, lock the latest revision on that branch.  If
<varname>rev</varname> is omitted, lock the latest revision on the
default branch.  There can be no space between
<command>-l</command> and its argument.
       </para>

       <para>
This command is depreciated in favour of the 'edit -c'
command, which gives pseudo reserved checkouts.
       </para>

       <para><indexterm role="cp"><primary>Changing a log message</primary></indexterm><indexterm role="cp"><primary>Replacing a log message</primary></indexterm><indexterm role="cp"><primary>Correcting a log message</primary></indexterm><indexterm role="cp"><primary>Fixing a log message</primary></indexterm><indexterm role="cp"><primary>Log message, correcting</primary></indexterm>       </para></listitem></varlistentry>
     <varlistentry>
      <term><command>-m<varname>rev</varname>:<varname>msg</varname></command></term>
      <listitem>
       <para>
Replace the log message of revision <varname>rev</varname> with
<varname>msg</varname>.
       </para>

       <para><indexterm role="cp"><primary>Deleting revisions</primary></indexterm><indexterm role="cp"><primary>Outdating revisions</primary></indexterm><indexterm role="cp"><primary>Saving space</primary></indexterm>       </para></listitem></varlistentry>
     <varlistentry>
      <term><command>-o<varname>range</varname></command></term>
      <listitem>
       <para>
Deletes (<firstterm>outdates</firstterm>) the revisions given by
<varname>range</varname>.
       </para>

       <para>
Note that this command can be quite dangerous unless
you know <emphasis>exactly</emphasis> what you are doing (for example
see the warnings below about how the
<varname>rev1</varname>:<varname>rev2</varname> syntax is confusing).
       </para>

       <para>
If you are short on disc this option might help you.
But think twice before using it--there is no way short
of restoring the latest backup to undo this command!
If you delete different revisions than you planned,
either due to carelessness or (heaven forbid) a cvsnt
bug, there is no opportunity to correct the error
before the revisions are deleted.  It probably would be
a good idea to experiment on a copy of the repository
first.
       </para>

       <para>
Specify <varname>range</varname> in one of the following ways:
       </para>

       <variablelist>
        <varlistentry>
         <term><command><varname>rev1</varname>::<varname>rev2</varname></command></term>
         <listitem>
          <para>
Collapse all revisions between rev1 and rev2, so that
cvsnt only stores the differences associated with going
from rev1 to rev2, not intermediate steps.  For
example, after <command>-o 1.3::1.5</command> one can retrieve
revision 1.3, revision 1.5, or the differences to get
from 1.3 to 1.5, but not the revision 1.4, or the
differences between 1.3 and 1.4.  Other examples:
<command>-o 1.3::1.4</command> and <command>-o 1.3::1.3</command> have no
effect, because there are no intermediate revisions to
remove.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command>::<varname>rev</varname></command></term>
         <listitem>
          <para>
Collapse revisions between the beginning of the branch
containing <varname>rev</varname> and <varname>rev</varname> itself.  The
branchpoint and <varname>rev</varname> are left intact.  For
example, <command>-o ::1.3.2.6</command> deletes revision 1.3.2.1,
revision 1.3.2.5, and everything in between, but leaves
1.3 and 1.3.2.6 intact.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>rev</varname>::</command></term>
         <listitem>
          <para>
Collapse revisions between <varname>rev</varname> and the end of the
branch containing <varname>rev</varname>.  Revision <varname>rev</varname> is
left intact but the head revision is deleted.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>rev</varname></command></term>
         <listitem>
          <para>
Delete the revision <varname>rev</varname>.  For example, <command>-o
1.3</command> is equivalent to <command>-o 1.2::1.4</command>.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>rev1</varname>:<varname>rev2</varname></command></term>
         <listitem>
          <para>
Delete the revisions from <varname>rev1</varname> to <varname>rev2</varname>,
inclusive, on the same branch.  One will not be able to
retrieve <varname>rev1</varname> or <varname>rev2</varname> or any of the
revisions in between.  For example, the command
<command>cvs admin -oR_1_01:R_1_02 .</command> is rarely useful.
It means to delete revisions up to, and including, the
tag R_1_02.  But beware!  If there are files that have not
changed between R_1_02 and R_1_03 the file will have
<emphasis>the same</emphasis> numerical revision number assigned to
the tags R_1_02 and R_1_03.  So not only will it be
impossible to retrieve R_1_02; R_1_03 will also have to
be restored from the tapes!  In most cases you want to
specify <varname>rev1</varname>::<varname>rev2</varname> instead.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command>:<varname>rev</varname></command></term>
         <listitem>
          <para>
Delete revisions from the beginning of the
branch containing <varname>rev</varname> up to and including
<varname>rev</varname>.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>rev</varname>:</command></term>
         <listitem>
          <para>
Delete revisions from revision <varname>rev</varname>, including
<varname>rev</varname> itself, to the end of the branch containing
<varname>rev</varname>.
          </para></listitem></varlistentry></variablelist>     

       <para>
None of the revisions to be deleted may have
branches or locks.
       </para>

       <para>
If any of the revisions to be deleted have symbolic
names, and one specifies one of the <command>::</command> syntaxes,
then cvsnt will give an error and not delete any
revisions.  If you really want to delete both the
symbolic names and the revisions, first delete the
symbolic names with <command>cvs tag -d</command>, then run
<command>cvs admin -o</command>.  If one specifies the
non-<command>::</command> syntaxes, then cvsnt will delete the
revisions but leave the symbolic names pointing to
nonexistent revisions.  This behavior is preserved for
compatibility with previous versions of cvsnt, but
because it isn't very useful, in the future it may
change to be like the <command>::</command> case.
       </para>

       <para>
Due to the way cvsnt handles branches <varname>rev</varname>
cannot be specified symbolically if it is a branch.
<xref linkend="Magic-branch-numbers" />, for an explanation.
       </para>

       <para>
Make sure that no-one has checked out a copy of the
revision you outdate.  Strange things will happen if he
starts to edit it and tries to check it back in.  For
this reason, this option is not a good way to take back
a bogus commit; commit a new revision undoing the bogus
change instead (<xref linkend="Merging-two-revisions" />).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-q</command></term>
      <listitem>
       <para>
Run quietly; do not print diagnostics.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-t[<varname>file</varname>]</command></term>
      <listitem>
       <para>
Useful with cvsnt.  Write descriptive text from the
contents of the named <varname>file</varname> into the rcs file,
deleting the existing text.  The <varname>file</varname> pathname
may not begin with <command>-</command>.  The descriptive text can be seen in the
output from <command>cvs log</command> (<xref linkend="log" />).
There can be no space between <command>-t</command> and its argument.
       </para>

       <para>
If <varname>file</varname> is omitted,
obtain the text from standard input, terminated by
end-of-file or by a line containing <command>.</command> by itself.
Prompt for the text if interaction is possible; see
<command>-I</command>.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-t-<varname>string</varname></command></term>
      <listitem>
       <para>
Similar to <command>-t<varname>file</varname></command>. Write descriptive text
from the <varname>string</varname> into the rcs file, deleting
the existing text.
There can be no space between <command>-t</command> and its argument.
       </para></listitem></varlistentry></variablelist>

</sect2></sect1>
  <sect1 id="checkout">
   <title>checkout--Check out sources for editing
</title>
   <para><indexterm role="cp"><primary>checkout (subcommand)</primary></indexterm><indexterm role="cp"><primary>co (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
Synopsis: checkout [options] modules&hellip;
     </para></listitem>
    <listitem>
     <para>
Requires: repository.
     </para></listitem>
    <listitem>
     <para>
Changes: working directory.
     </para></listitem>
    <listitem>
     <para>
Synonyms: co, get
     </para></listitem></itemizedlist>
   <para>
Create or update a working directory containing copies of the
source files specified by <varname>modules</varname>.  You must execute
<command>checkout</command> before using most of the other cvsnt
commands, since most of them operate on your working
directory.
   </para>
   <para>
The <varname>modules</varname> are either
symbolic names for some
collection of source directories and files, or paths to
directories or files in the repository.  The symbolic
names are defined in the <command>modules</command> file.
<xref linkend="modules" />.
   </para>
   <para>
Depending on the modules you specify, <command>checkout</command> may
recursively create directories and populate them with
the appropriate source files.  You can then edit these
source files at any time (regardless of whether other
software developers are editing their own copies of the
sources); update them to include new changes applied by
others to the source repository; or commit your work as
a permanent change to the source repository.
   </para>
   <para>
Note that <command>checkout</command> is used to create
directories.  The top-level directory created is always
added to the directory where <command>checkout</command> is
invoked, and usually has the same name as the specified
module.  In the case of a module alias, the created
sub-directory may have a different name, but you can be
sure that it will be a sub-directory, and that
<command>checkout</command> will show the relative path leading to
each file as it is extracted into your private work
area (unless you specify the <command>-Q</command> global option).
   </para>
   <para>
The files created by <command>checkout</command> are created
read-write, unless the <command>-r</command> option to cvsnt
(<xref linkend="Global-options" />) is specified, the
<command>CVSREAD</command> environment variable is specified
(<xref linkend="Environment-variables" />), or a watch is in
effect for that file (<xref linkend="Watches" />).
   </para>
   <para>
Note that running <command>checkout</command> on a directory that was already
built by a prior <command>checkout</command> is also permitted.
This is similar to specifying the <command>-d</command> option
to the <command>update</command> command in the sense that new
directories that have been created in the repository
will appear in your work area.
However, <command>checkout</command> takes a module name whereas
<command>update</command> takes a directory name.  Also
to use <command>checkout</command> this way it must be run from the
top level directory (where you originally ran
<command>checkout</command> from), so before you run
<command>checkout</command> to update an existing directory, don't
forget to change your directory to the top level
directory.
   </para>
   <para>
For the output produced by the <command>checkout</command> command
see <xref linkend="update-output" />.
   </para>


   <sect2 id="checkout-options">
    <title>checkout options
</title>

    <para>
These standard options are supported by <command>checkout</command>
(<xref linkend="Common-options" />, for a complete description of
them):
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-D <varname>date</varname></command></term>
      <listitem>
       <para>
Use the most recent revision no later than <varname>date</varname>.
This option is sticky, and implies <command>-P</command>.  See
<xref linkend="Sticky-tags" />, for more information on sticky tags/dates.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-f</command></term>
      <listitem>
       <para>
Only useful with the <command>-D <varname>date</varname></command> or <command>-r
<varname>tag</varname></command> flags.  If no matching revision is found,
retrieve the most recent revision (instead of ignoring
the file).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-k <varname>kflag</varname></command></term>
      <listitem>
       <para>
Process keywords according to <varname>kflag</varname>.  See
<xref linkend="Keyword-substitution" />.
This option is sticky; future updates of
this file in this working directory will use the same
<varname>kflag</varname>.  The <command>status</command> command can be viewed
to see the sticky options.  See <xref linkend="Invoking-CVS" />, for
more information on the <command>status</command> command.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-l</command></term>
      <listitem>
       <para>
Local; run only in current working directory.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-n</command></term>
      <listitem>
       <para>
Do not run any checkout program (as specified
with the <command>-o</command> option in the modules file;
<xref linkend="modules" />).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-P</command></term>
      <listitem>
       <para>
Prune empty directories.  See <xref linkend="Moving-directories" />.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-p</command></term>
      <listitem>
       <para>
Pipe files to the standard output.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-R</command></term>
      <listitem>
       <para>
Checkout directories recursively.  This option is on by default.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-r <varname>tag</varname></command></term>
      <listitem>
       <para>
Use revision <varname>tag</varname>.  This option is sticky, and implies <command>-P</command>.
See <xref linkend="Sticky-tags" />, for more information on sticky tags/dates.
       </para></listitem></varlistentry></variablelist>
    <para>
In addition to those, you can use these special command
options with <command>checkout</command>:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-A</command></term>
      <listitem>
       <para>
Reset any sticky tags, dates, or <command>-k</command> options.
See <xref linkend="Sticky-tags" />, for more information on sticky tags/dates.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-c</command></term>
      <listitem>
       <para>
Copy the module file, sorted, to the standard output,
instead of creating or modifying any files or
directories in your working directory.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-d <varname>dir</varname></command></term>
      <listitem>
       <para>
Create a directory called <varname>dir</varname> for the working
files, instead of using the module name.  In general,
using this flag is equivalent to using <command>mkdir
<varname>dir</varname>; cd <varname>dir</varname></command> followed by the checkout
command without the <command>-d</command> flag.
       </para>

       <para>
There is an important exception, however.  It is very
convenient when checking out a single item to have the
output appear in a directory that doesn't contain empty
intermediate directories.  In this case <emphasis>only</emphasis>,
cvsnt tries to "shorten" pathnames to avoid those empty
directories.
       </para>

       <para>
For example, given a module <command>foo</command> that contains
the file <command>bar.c</command>, the command <command>cvs co -d dir
foo</command> will create directory <command>dir</command> and place
<command>bar.c</command> inside.  Similarly, given a module
<command>bar</command> which has subdirectory <command>baz</command> wherein
there is a file <command>quux.c</command>, the command <command>cvs -d
dir co bar/baz</command> will create directory <command>dir</command> and
place <command>quux.c</command> inside.
       </para>

       <para>
Using the <command>-N</command> flag will defeat this behavior.
Given the same module definitions above, <command>cvs co
-N -d dir foo</command> will create directories <command>dir/foo</command>
and place <command>bar.c</command> inside, while <command>cvs co -N -d
dir bar/baz</command> will create directories <command>dir/bar/baz</command>
and place <command>quux.c</command> inside.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-j <varname>tag</varname></command></term>
      <listitem>
       <para>
With two <command>-j</command> options, merge changes from the
revision specified with the first <command>-j</command> option to
the revision specified with the second <command>j</command> option,
into the working directory.
       </para>

       <para>
With one <command>-j</command> option, merge changes from the
ancestor revision to the revision specified with the
<command>-j</command> option, into the working directory.  The
ancestor revision is the common ancestor of the
revision which the working directory is based on, and
the revision specified in the <command>-j</command> option.
       </para>

       <para>
In addition, each -j option can contain an optional
date specification which, when used with branches, can
limit the chosen revision to one within a specific
date.  An optional date is specified by adding a colon
(:) to the tag:
<command>-j<varname>Symbolic_Tag</varname>:<varname>Date_Specifier</varname></command>.
       </para>

       <para><xref linkend="Branching-and-merging" />.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-N</command></term>
      <listitem>
       <para>
Only useful together with <command>-d <varname>dir</varname></command>.  With
this option, cvsnt will not "shorten" module paths
in your working directory when you check out a single
module.  See the <command>-d</command> flag for examples and a
discussion.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-s</command></term>
      <listitem>
       <para>
Like <command>-c</command>, but include the status of all modules,
and sort it by the status string.  <xref linkend="modules" />, for
info about the <command>-s</command> option that is used inside the
modules file to set the module status.
       </para></listitem></varlistentry></variablelist>
</sect2>
   <sect2 id="checkout-examples">
    <title>checkout examples
</title>

    <para>
Get a copy of the module <command>tc</command>:
    </para>

    <para><screen>$ cvs checkout tc
</screen>    </para>
    <para>
Get a copy of the module <command>tc</command> as it looked one day
ago:
    </para>
    <para><screen>
$ cvs checkout -D yesterday tc
</screen>       </para>
</sect2></sect1>
  <sect1 id="commit">
   <title>commit--Check files into the repository
</title>
   <para><indexterm role="cp"><primary>commit (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
Synopsis: commit [-lnRf] [-m 'log_message' |
-F file] [-r revision] [files&hellip;]
     </para></listitem>
    <listitem>
     <para>
Requires: working directory, repository.
     </para></listitem>
    <listitem>
     <para>
Changes: repository.
     </para></listitem>
    <listitem>
     <para>
Synonym: ci
     </para></listitem></itemizedlist>
   <para>
Use <command>commit</command> when you want to incorporate changes
from your working source files into the source
repository.
   </para>
   <para>
If you don't specify particular files to commit, all of
the files in your working current directory are
examined.  <command>commit</command> is careful to change in the
repository only those files that you have really
changed.  By default (or if you explicitly specify the
<command>-R</command> option), files in subdirectories are also
examined and committed if they have changed; you can
use the <command>-l</command> option to limit <command>commit</command> to the
current directory only.
   </para>
   <para><command>commit</command> verifies that the selected files are up
to date with the current revisions in the source
repository; it will notify you, and exit without
committing, if any of the specified files must be made
current first with <command>update</command> (<xref linkend="update" />).
<command>commit</command> does not call the <command>update</command> command
for you, but rather leaves that for you to do when the
time is right.
   </para>
   <para>
When all is well, an editor is invoked to allow you to
enter a log message that will be written to one or more
logging programs (<xref linkend="modules" />, and <xref linkend="loginfo" />)
and placed in the rcs file inside the
repository.  This log message can be retrieved with the
<command>log</command> command; see <xref linkend="log" />.  You can specify the
log message on the command line with the <command>-m
<varname>message</varname></command> option, and thus avoid the editor invocation,
or use the <command>-F <varname>file</varname></command> option to specify
that the argument file contains the log message.
   </para>


   <sect2 id="commit-options">
    <title>commit options
</title>

    <para>
These standard options are supported by <command>commit</command>
(<xref linkend="Common-options" />, for a complete description of
them):
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-D</command></term>
      <listitem>
       <para>
Assume all datestamps are different and send all files to the server for checking.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-l</command></term>
      <listitem>
       <para>
Local; run only in current working directory.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-n</command></term>
      <listitem>
       <para>
Do not run any module program.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-R</command></term>
      <listitem>
       <para>
Commit directories recursively.  This is on by default.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-r <varname>revision</varname></command></term>
      <listitem>
       <para>
Commit to <varname>revision</varname>.  <varname>revision</varname> must be
either a branch, or a revision on the main trunk that
is higher than any existing revision number
(<xref linkend="Assigning-revisions" />).  You
cannot commit to a specific revision on a branch.
       </para></listitem></varlistentry></variablelist>
    <para><command>commit</command> also supports these options:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-F <varname>file</varname></command></term>
      <listitem>
       <para>
Read the log message from <varname>file</varname>, instead
of invoking an editor.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-f</command></term>
      <listitem>
       <para>
Note that this is not the standard behavior of
the <command>-f</command> option as defined in <xref linkend="Common-options" />.
       </para>

       <para>
Force cvsnt to commit a new revision even if you haven't
made any changes to the file.  If the current revision
of <varname>file</varname> is 1.7, then the following two commands
are equivalent:
       </para>

       <para><screen>$ cvs commit -f <varname>file</varname>
$ cvs commit -r 1.8 <varname>file</varname>
</screen>            </para>

       <para>
The <command>-f</command> option disables recursion (i.e., it
implies <command>-l</command>).  To force cvsnt to commit a new
revision for all files in all subdirectories, you must
use <command>-f -R</command>.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-m <varname>message</varname></command></term>
      <listitem>
       <para>
Use <varname>message</varname> as the log message, instead of
invoking an editor.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-c</command></term>
      <listitem>
       <para>
Check for a valid edit on the file before committing.  See 'cvs edit'.
       </para>
</listitem></varlistentry></variablelist>
</sect2>
   <sect2 id="commit-examples">
    <title>commit examples
</title>


    <sect3>
     <title>Committing to a branch
</title>

     <para>
You can commit to a branch revision (one that has an
even number of dots) with the <command>-r</command> option.  To
create a branch revision, use the <command>-b</command> option
of the <command>rtag</command> or <command>tag</command> commands
(<xref linkend="Branching-and-merging" />).  Then, either <command>checkout</command> or
<command>update</command> can be used to base your sources on the
newly created branch.  From that point on, all
<command>commit</command> changes made within these working sources
will be automatically added to a branch revision,
thereby not disturbing main-line development in any
way.  For example, if you had to create a patch to the
1.2 version of the product, even though the 2.0 version
is already under development, you might do:
     </para>

     <para><screen>$ cvs rtag -b -r FCS1_2 FCS1_2_Patch product_module
$ cvs checkout -r FCS1_2_Patch product_module
$ cd product_module
[[ hack away ]]
$ cvs commit
</screen>     </para>

     <para>
This works automatically since the <command>-r</command> option is
sticky.
     </para>
</sect3>
    <sect3>
     <title>Creating the branch after editing
</title>

     <para>
Say you have been working on some extremely
experimental software, based on whatever revision you
happened to checkout last week.  If others in your
group would like to work on this software with you, but
without disturbing main-line development, you could
commit your change to a new branch.  Others can then
checkout your experimental stuff and utilize the full
benefit of cvsnt conflict resolution.  The scenario might
look like:
     </para>

     <para><screen>
[[ hacked sources are present ]]
$ cvs tag -b EXPR1
$ cvs update -r EXPR1
$ cvs commit
</screen>     </para>
     <para>
The <command>update</command> command will make the <command>-r
EXPR1</command> option sticky on all files.  Note that your
changes to the files will never be removed by the
<command>update</command> command.  The <command>commit</command> will
automatically commit to the correct branch, because the
<command>-r</command> is sticky.  You could also do like this:
     </para>
     <para><screen>
[[ hacked sources are present ]]
$ cvs tag -b EXPR1
$ cvs commit -r EXPR1
</screen>        </para>

     <para>
but then, only those files that were changed by you
will have the <command>-r EXPR1</command> sticky flag.  If you hack
away, and commit without specifying the <command>-r EXPR1</command>
flag, some files may accidentally end up on the main
trunk.
     </para>

     <para>
To work with you on the experimental change, others
would simply do
     </para>

     <para><screen>
$ cvs checkout -r EXPR1 whatever_module
</screen>     </para>
</sect3></sect2></sect1>
  <sect1 id="diff">
   <title>diff--Show differences between revisions
</title>
   <para><indexterm role="cp"><primary>diff (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
Synopsis: diff [-lR] [format_options] [[-r rev1 | -D date1] [-r rev2 |  -D date2]] [files&hellip;]
     </para></listitem>
    <listitem>
     <para>
Requires: working directory, repository.
     </para></listitem>
    <listitem>
     <para>
Changes: nothing.
     </para></listitem></itemizedlist>
   <para>
The <command>diff</command> command is used to compare different
revisions of files.  The default action is to compare
your working files with the revisions they were based
on, and report any differences that are found.
   </para>
   <para>
If any file names are given, only those files are
compared.  If any directories are given, all files
under them will be compared.
   </para>
   <para>
The exit status for diff is different than for other
cvsnt commands; for details <xref linkend="Exit-status" />.
   </para>


   <sect2 id="diff-options">
    <title>diff options
</title>

    <para>
These standard options are supported by <command>diff</command>
(<xref linkend="Common-options" />, for a complete description of
them):
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-D <varname>date</varname></command></term>
      <listitem>
       <para>
Use the most recent revision no later than <varname>date</varname>.
See <command>-r</command> for how this affects the comparison.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-k <varname>kflag</varname></command></term>
      <listitem>
       <para>
Process keywords according to <varname>kflag</varname>.  See
<xref linkend="Keyword-substitution" />.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-l</command></term>
      <listitem>
       <para>
Local; run only in current working directory.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-R</command></term>
      <listitem>
       <para>
Examine directories recursively.  This option is on by
default.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-r <varname>tag</varname></command></term>
      <listitem>
       <para>
Compare with revision <varname>tag</varname>.  Zero, one or two
<command>-r</command> options can be present.  With no <command>-r</command>
option, the working file will be compared with the
revision it was based on.  With one <command>-r</command>, that
revision will be compared to your current working file.
With two <command>-r</command> options those two revisions will be
compared (and your working file will not affect the
outcome in any way).
       </para>

       <para>
One or both <command>-r</command> options can be replaced by a
<command>-D <varname>date</varname></command> option, described above.
       </para></listitem></varlistentry></variablelist>
    <para>
The following options specify the format of the
output.  They have the same meaning as in GNU diff.
    </para>
    <para><screen>
-0 -1 -2 -3 -4 -5 -6 -7 -8 -9
--binary
--brief
--changed-group-format=<varname>arg</varname>
-c
  -C <varname>nlines</varname>
  --context[=<varname>lines</varname>]
-e --ed
-t --expand-tabs
-f --forward-ed
--horizon-lines=<varname>arg</varname>
--ifdef=<varname>arg</varname>
-w --ignore-all-space
-B --ignore-blank-lines
-i --ignore-case
-I <varname>regexp</varname>
   --ignore-matching-lines=<varname>regexp</varname>
-h
-b --ignore-space-change
-T --initial-tab
-L <varname>label</varname>
  --label=<varname>label</varname>
--left-column
-d --minimal
-N --new-file
--new-line-format=<varname>arg</varname>
--old-line-format=<varname>arg</varname>
--paginate
-n --rcs
-s --report-identical-files
-p
--show-c-function
-y --side-by-side
-F <varname>regexp</varname>
--show-function-line=<varname>regexp</varname>
-H --speed-large-files
--suppress-common-lines
-a --text
--unchanged-group-format=<varname>arg</varname>
-u
  -U <varname>nlines</varname>
  --unified[=<varname>lines</varname>]
-V <varname>arg</varname>
-W <varname>columns</varname>
  --width=<varname>columns</varname>
</screen>       </para>
</sect2>
   <sect2 id="diff-examples">
    <title>diff examples
</title>

    <para>
The following line produces a Unidiff (<command>-u</command> flag)
between revision 1.14 and 1.19 of
<command>backend.c</command>.  Due to the <command>-kk</command> flag no
keywords are substituted, so differences that only depend
on keyword substitution are ignored.
    </para>

    <para><screen>$ cvs diff -kk -u -r 1.14 -r 1.19 backend.c
</screen>    </para>
    <para>
Suppose the experimental branch EXPR1 was based on a
set of files tagged RELEASE_1_0.  To see what has
happened on that branch, the following can be used:
    </para>
    <para><screen>
$ cvs diff -r RELEASE_1_0 -r EXPR1
</screen>       </para>
    <para>
A command like this can be used to produce a context
diff between two releases:
    </para>
    <para><screen>
$ cvs diff -c -r RELEASE_1_0 -r RELEASE_1_1 &gt; diffs
</screen>       </para>
    <para>
If you are maintaining ChangeLogs, a command like the following
just before you commit your changes may help you write
the ChangeLog entry.  All local modifications that have
not yet been committed will be printed.
    </para>
    <para><screen>
$ cvs diff -u | less
</screen>       </para>
</sect2></sect1>
  <sect1 id="adduser">
   <title>Add a user to the repository
</title>
   <para><indexterm role="cp"><primary>adduser (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
adduser username
     </para></listitem>
    <listitem>
     <para>
Requires: repository
     </para></listitem>
    <listitem>
     <para>
Changes: password file
     </para></listitem></itemizedlist>
   <para>
If invoked by the administrator, it adds a user.
   </para>
   <para>
This only works with remote pserver repositories.
   </para>
</sect1>
  <sect1 id="passwd">
   <title>Modify a user's password or create a user
</title>
   <para><indexterm role="cp"><primary>passwd (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
passwd [username]
     </para></listitem>
    <listitem>
     <para>
Requires: repository
     </para></listitem>
    <listitem>
     <para>
Changes: password file
     </para></listitem></itemizedlist>
   <para>
If invoked without a username, this will prompt the
user for a new password and change the password to the
new one specified by the user.
   </para>
   <para>
If invoked by the administrator with a username, it
allows another user's password to be modified.
   </para>
   <para>
This only works with remote pserver repositories.
   </para>
</sect1>
  <sect1 id="chacl">
   <title>Set a user's permissions for a directory
</title>
   <para><indexterm role="cp"><primary>chacl (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
chacl username:perm directory [directory ...]
     </para></listitem>
    <listitem>
     <para>
Requires: repository, directories
     </para></listitem>
    <listitem>
     <para>
Changes: directories' permission files
     </para></listitem></itemizedlist>
   <para>
Allows the owner of a directory to allow or disallow
access to a repository directory to other users of the
repository.
   </para>
   <para>
The <command>perm</command> field can only contain three
characters: c, r, and w.  These character mean:
   </para>
   <para><screen>
c - create - create and delete files and directories
r - read   - retrieve file and look at information
w - write  - modify files and change information
n - none   - no access
</screen>      </para>
</sect1>
  <sect1 id="chown">
   <title>Change a directory's owner
</title>
   <para><indexterm role="cp"><primary>chown (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
chown username directory [directory ...]
     </para></listitem>
    <listitem>
     <para>
Requires: repository, directories
     </para></listitem>
    <listitem>
     <para>
Changes: directories' owner files
     </para></listitem></itemizedlist>
   <para>
Allows the owner of a directory to assign a new owner
to directories.
   </para>
</sect1>
  <sect1 id="lsacl">
   <title>Show a directory's permissions
</title>
   <para><indexterm role="cp"><primary>lsacl (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
lsacl directory [directory ...]
     </para></listitem>
    <listitem>
     <para>
Requires: repository, directories
     </para></listitem></itemizedlist>
   <para>
Lists the owner and other users that have permissions
in the directory.
   </para>
</sect1>
  <sect1 id="export">
   <title>export--Export sources from CVS, similar to checkout
</title>
   <para><indexterm role="cp"><primary>export (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
Synopsis: export [-flNnR] [-r rev|-D date] [-k subst] [-d dir] module&hellip;
     </para></listitem>
    <listitem>
     <para>
Requires: repository.
     </para></listitem>
    <listitem>
     <para>
Changes: current directory.
     </para></listitem></itemizedlist>
   <para>
This command is a variant of <command>checkout</command>; use it
when you want a copy of the source for module without
the cvsnt administrative directories.  For example, you
might use <command>export</command> to prepare source for shipment
off-site.  This command requires that you specify a
date or tag (with <command>-D</command> or <command>-r</command>), so that you
can count on reproducing the source you ship to others
(and thus it always prunes empty directories).
   </para>
   <para>
One often would like to use <command>-kv</command> with <command>cvs
export</command>.  This causes any keywords to be
expanded such that an import done at some other site
will not lose the keyword revision information.  But be
aware that doesn't handle an export containing binary
files correctly.  Also be aware that after having used
<command>-kv</command>, one can no longer use the <command>ident</command>
command (which is part of the rcs suite--see
ident(1)) which looks for keyword strings.  If
you want to be able to use <command>ident</command> you must not
use <command>-kv</command>.
   </para>


   <sect2 id="export-options">
    <title>export options
</title>

    <para>
These standard options are supported by <command>export</command>
(<xref linkend="Common-options" />, for a complete description of
them):
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-D <varname>date</varname></command></term>
      <listitem>
       <para>
Use the most recent revision no later than <varname>date</varname>.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-f</command></term>
      <listitem>
       <para>
If no matching revision is found, retrieve the most
recent revision (instead of ignoring the file).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-l</command></term>
      <listitem>
       <para>
Local; run only in current working directory.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-n</command></term>
      <listitem>
       <para>
Do not run any checkout program.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-R</command></term>
      <listitem>
       <para>
Export directories recursively.  This is on by default.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-r <varname>tag</varname></command></term>
      <listitem>
       <para>
Use revision <varname>tag</varname>.
       </para></listitem></varlistentry></variablelist>
    <para>
In addition, these options (that are common to
<command>checkout</command> and <command>export</command>) are also supported:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-d <varname>dir</varname></command></term>
      <listitem>
       <para>
Create a directory called <varname>dir</varname> for the working
files, instead of using the module name.
<xref linkend="checkout-options" />, for complete details on how
cvsnt handles this flag.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-k <varname>subst</varname></command></term>
      <listitem>
       <para>
Set keyword expansion mode (<xref linkend="Substitution-modes" />).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-N</command></term>
      <listitem>
       <para>
Only useful together with <command>-d <varname>dir</varname></command>.
<xref linkend="checkout-options" />, for complete details on how
cvsnt handles this flag.
       </para></listitem></varlistentry></variablelist>
</sect2></sect1>
  <sect1 id="history">
   <title>history--Show status of files and users
</title>
   <para><indexterm role="cp"><primary>history (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
Synopsis:     history [-report] [-flags] [-options args] [files&hellip;]
     </para></listitem>
    <listitem>
     <para>
Requires: the file <command>$CVSROOT/CVSROOT/history</command>
     </para></listitem>
    <listitem>
     <para>
Changes: nothing.
     </para></listitem></itemizedlist>
   <para>
cvsnt can keep a history file that tracks each use of the
<command>checkout</command>, <command>commit</command>, <command>rtag</command>,
<command>update</command>, and <command>release</command> commands.  You can
use <command>history</command> to display this information in
various formats.
   </para>
   <para>
Logging must be enabled by creating the file
<command>$CVSROOT/CVSROOT/history</command>.
   </para>
   <para><emphasis>Warning:</emphasis> <command>history</command> uses <command>-f</command>, <command>-l</command>,
<command>-n</command>, and <command>-p</command> in ways that conflict with the
normal use inside cvsnt (<xref linkend="Common-options" />).
   </para>


   <sect2 id="history-options">
    <title>history options
</title>

    <para>
Several options (shown above as <command>-report</command>)  control  what
kind of report is generated:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-c</command></term>
      <listitem>
       <para>
Report on each time commit was used (i.e., each time
the repository was modified).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-e</command></term>
      <listitem>
       <para>
Everything (all record types).  Equivalent to
specifying <command>-x</command> with all record types.  Of course,
<command>-e</command> will also include record types which are
added in a future version of cvsnt; if you are
writing a script which can only handle certain record
types, you'll want to specify <command>-x</command>.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-m <varname>module</varname></command></term>
      <listitem>
       <para>
Report on a particular module.  (You can meaningfully
use <command>-m</command> more than once on the command line.)
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-o</command></term>
      <listitem>
       <para>
Report on checked-out modules.  This is the default report type.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-T</command></term>
      <listitem>
       <para>
Report on all tags.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-x <varname>type</varname></command></term>
      <listitem>
       <para>
Extract a particular set of record types <varname>type</varname> from the cvsnt
history.  The types are indicated by single letters,
which you may specify in combination.
       </para>

       <para>
Certain commands have a single record type:
       </para>

       <variablelist>
        <varlistentry>
         <term><command>F</command></term>
         <listitem>
          <para>
release
          </para></listitem></varlistentry>
        <varlistentry>
         <term><command>O</command></term>
         <listitem>
          <para>
checkout
          </para></listitem></varlistentry>
        <varlistentry>
         <term><command>E</command></term>
         <listitem>
          <para>
export
          </para></listitem></varlistentry>
        <varlistentry>
         <term><command>T</command></term>
         <listitem>
          <para>
rtag
          </para></listitem></varlistentry></variablelist>     


       <para>
One of four record types may result from an update:
       </para>

       <variablelist>
        <varlistentry>
         <term><command>C</command></term>
         <listitem>
          <para>
A merge was necessary but collisions were
detected (requiring manual merging).
          </para></listitem></varlistentry>
        <varlistentry>
         <term><command>G</command></term>
         <listitem>
          <para>
A merge was necessary and it succeeded.
          </para></listitem></varlistentry>
        <varlistentry>
         <term><command>U</command></term>
         <listitem>
          <para>
A working file was copied from the repository.
          </para></listitem></varlistentry>
        <varlistentry>
         <term><command>W</command></term>
         <listitem>
          <para>
The working copy of a file was deleted during
update (because it was gone from the repository).
          </para></listitem></varlistentry></variablelist>     


       <para>
One of three record types results from commit:
       </para>

       <variablelist>
        <varlistentry>
         <term><command>A</command></term>
         <listitem>
          <para>
A file was added for the first time.
          </para></listitem></varlistentry>
        <varlistentry>
         <term><command>M</command></term>
         <listitem>
          <para>
A file was modified.
          </para></listitem></varlistentry>
        <varlistentry>
         <term><command>R</command></term>
         <listitem>
          <para>
A file was removed.
          </para></listitem></varlistentry></variablelist>     </listitem></varlistentry></variablelist>

    <para>
The options shown as <command>-flags</command> constrain or expand
the report without requiring option arguments:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-a</command></term>
      <listitem>
       <para>
Show data for all users (the default is to show data
only for the user executing <command>history</command>).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-l</command></term>
      <listitem>
       <para>
Show last modification only.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-w</command></term>
      <listitem>
       <para>
Show only the records for modifications done from the
same working directory where <command>history</command> is
executing.
       </para></listitem></varlistentry></variablelist>
    <para>
The options shown as <command>-options <varname>args</varname></command> constrain the report
based on an argument:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-b <varname>str</varname></command></term>
      <listitem>
       <para>
Show data back to a record containing  the  string
<varname>str</varname>  in  either the module name, the file name, or
the repository path.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-D <varname>date</varname></command></term>
      <listitem>
       <para>
Show data since <varname>date</varname>.  This is slightly different
from the normal use of <command>-D <varname>date</varname></command>, which
selects the newest revision older than <varname>date</varname>.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-f <varname>file</varname></command></term>
      <listitem>
       <para>
Show data for a particular file
(you can specify several <command>-f</command> options on the same command line).
This is equivalent to specifying the file on the command line.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-n <varname>module</varname></command></term>
      <listitem>
       <para>
Show data for a particular module
(you can specify several <command>-n</command> options on the same command line).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-p <varname>repository</varname></command></term>
      <listitem>
       <para>
Show data for a particular source repository  (you
can specify several <command>-p</command> options on the same command
line).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-r <varname>rev</varname></command></term>
      <listitem>
       <para>
Show records referring to revisions since the revision
or tag named <varname>rev</varname> appears in individual rcs
files.  Each rcs file is searched for the revision or
tag.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-t <varname>tag</varname></command></term>
      <listitem>
       <para>
Show records since tag <varname>tag</varname> was last added to the
history file.  This differs from the <command>-r</command> flag
above in that it reads only the history file, not the
rcs files, and is much faster.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-u <varname>name</varname></command></term>
      <listitem>
       <para>
Show records for user <varname>name</varname>.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-z <varname>timezone</varname></command></term>
      <listitem>
       <para>
Show times in the selected records using the specified
time zone instead of UTC.
       </para></listitem></varlistentry></variablelist>
</sect2></sect1>
  <sect1 id="import">
   <title>import--Import sources into CVS, using vendor branches
</title>
   <para><indexterm role="cp"><primary>import (subcommand)</primary></indexterm>
   </para>

   <itemizedlist mark="bullet">
    <listitem>
     <para>
Synopsis: import [-options] repository vendortag releasetag&hellip;
     </para></listitem>
    <listitem>
     <para>
Requires: Repository, source distribution directory.
     </para></listitem>
    <listitem>
     <para>
Changes: repository.
     </para></listitem></itemizedlist>
   <para>
Use <command>import</command> to incorporate an entire source
distribution from an outside source (e.g., a source
vendor) into your source repository directory.  You can
use this command both for initial creation of a
repository, and for wholesale updates to the module
from the outside source.  <xref linkend="Tracking-sources" />, for
a discussion on this subject.
   </para>
   <para>
The <varname>repository</varname> argument gives a directory name
(or a path to a directory) under the cvsnt root directory
for repositories; if the directory did not exist,
import creates it.
   </para>
   <para>
When you use import for updates to source that has been
modified in your source repository (since a prior
import), it will notify you of any files that conflict
in the two branches of development; use <command>checkout
-j</command> to reconcile the differences, as import instructs
you to do.
   </para>
   <para>
If cvsnt decides a file should be ignored
(<xref linkend="cvsignore" />), it does not import it and prints
<command>I </command> followed by the filename (<xref linkend="import-output" />, for a
complete description of the output).
   </para>
   <para>
If the file <command>$CVSROOT/CVSROOT/cvswrappers</command> exists,
any file whose names match the specifications in that
file will be treated as packages and the appropriate
filtering will be performed on the file/directory
before being imported.  <xref linkend="Wrappers" />.
   </para>
   <para>
The outside source is saved in a first-level
branch, by default 1.1.1.  Updates are leaves of this
branch; for example, files from the first imported
collection of source will be revision 1.1.1.1, then
files from the first imported update will be revision
1.1.1.2, and so on.
   </para>
   <para>
At least three arguments are required.
<varname>repository</varname> is needed to identify the collection
of source.  <varname>vendortag</varname> is a tag for the entire
branch (e.g., for 1.1.1).  You must also specify at
least one <varname>releasetag</varname> to identify the files at
the leaves created each time you execute <command>import</command>.
   </para>
   <para>
Note that <command>import</command> does <emphasis>not</emphasis> change the
directory in which you invoke it.  In particular, it
does not set up that directory as a cvsnt working
directory; if you want to work with the sources import
them first and then check them out into a different
directory (<xref linkend="Getting-the-source" />).
   </para>


   <sect2 id="import-options">
    <title>import options
</title>

    <para>
This standard option is supported by <command>import</command>
(<xref linkend="Common-options" />, for a complete description):
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-m <varname>message</varname></command></term>
      <listitem>
       <para>
Use <varname>message</varname> as log information, instead of
invoking an editor.
       </para></listitem></varlistentry></variablelist>
    <para>
There are the following additional special options.
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-b <varname>branch</varname></command></term>
      <listitem>
       <para>
See <xref linkend="Multiple-vendor-branches" />.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-k <varname>subst</varname></command></term>
      <listitem>
       <para>
Indicate the keyword expansion mode desired.  This
setting will apply to all files created during the
import, but not to any files that previously existed in
the repository.  See <xref linkend="Substitution-modes" />, for a
list of valid <command>-k</command> settings.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-I <varname>name</varname></command></term>
      <listitem>
       <para>
Specify file names that should be ignored during
import.  You can use this option repeatedly.  To avoid
ignoring any files at all (even those ignored by
default), specify `-I !'.
       </para>

       <para><varname>name</varname> can be a file name pattern of the same type
that you can specify in the <command>.cvsignore</command> file.
<xref linkend="cvsignore" />.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-W <varname>spec</varname></command></term>
      <listitem>
       <para>
Specify file names that should be filtered during
import.  You can use this option repeatedly.
       </para>

       <para><varname>spec</varname> can be a file name pattern of the same type
that you can specify in the <command>.cvswrappers</command>
file. <xref linkend="Wrappers" />.
       </para></listitem></varlistentry></variablelist>
</sect2>
   <sect2 id="import-output">
    <title>import output
</title>

    <para><command>import</command> keeps you informed of its progress by printing a line
for each file, preceded by one character indicating the status of the file:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>U <varname>file</varname></command></term>
      <listitem>
       <para>
The file already exists in the repository and has not been locally
modified; a new revision has been created (if necessary).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>N <varname>file</varname></command></term>
      <listitem>
       <para>
The file is a new file which has been added to the repository.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>C <varname>file</varname></command></term>
      <listitem>
       <para>
The file already exists in the repository but has been locally modified;
you will have to merge the changes.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>I <varname>file</varname></command></term>
      <listitem>
       <para>
The file is being ignored (<xref linkend="cvsignore" />).
       </para>

       <para><indexterm role="cp"><primary>Symbolic link, importing</primary></indexterm><indexterm role="cp"><primary>Link, symbolic, importing</primary></indexterm>       </para></listitem></varlistentry>
     <varlistentry>
      <term><command>L <varname>file</varname></command></term>
      <listitem>
       <para>
The file is a symbolic link; <command>cvs import</command> ignores symbolic links.
People periodically suggest that this behavior should
be changed, but if there is a consensus on what it
should be changed to, it doesn't seem to be apparent.
(Various options in the <command>modules</command> file can be used
to recreate symbolic links on checkout, update, etc.;
<xref linkend="modules" />.)
       </para></listitem></varlistentry></variablelist>
</sect2>
   <sect2 id="import-examples">
    <title>import examples
</title>

    <para>
See <xref linkend="Tracking-sources" />, and <xref linkend="From-files" />.
    </para>

</sect2></sect1>
  <sect1 id="log">
   <title>log--Print out log information for files
</title>
   <para><indexterm role="cp"><primary>log (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
Synopsis: log [options] [files&hellip;]
     </para></listitem>
    <listitem>
     <para>
Requires: repository, working directory.
     </para></listitem>
    <listitem>
     <para>
Changes: nothing.
     </para></listitem></itemizedlist>
   <para>
Display log information for files.  <command>log</command> used to
call the rcs utility <command>rlog</command>.  Although this
is no longer true in the current sources, this history
determines the format of the output and the options,
which are not quite in the style of the other cvsnt
commands.
   </para>
   <para><indexterm role="cp"><primary>Timezone, in output</primary></indexterm><indexterm role="cp"><primary>Zone, time, in output</primary></indexterm>The output includes the location of the rcs file,
the <firstterm>head</firstterm> revision (the latest revision on the
trunk), all symbolic names (tags) and some other
things.  For each revision, the revision number, the
author, the number of lines added/deleted and the log
message are printed.  All times are displayed in
Coordinated Universal Time (UTC).  (Other parts of
cvsnt print times in the local timezone).
   </para>
   <para><emphasis>Warning:</emphasis> <command>log</command> uses <command>-R</command> in a way that conflicts
with the normal use inside cvsnt (<xref linkend="Common-options" />).
   </para>


   <sect2 id="log-options">
    <title>log options
</title>

    <para>
By default, <command>log</command> prints all information that is
available.  All other options restrict the output.
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-b</command></term>
      <listitem>
       <para>
Print information about the revisions on the default
branch, normally the highest branch on the trunk.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-d <varname>dates</varname></command></term>
      <listitem>
       <para>
Print information about revisions with a checkin
date/time in the range given by the
semicolon-separated list of dates.  The date formats
accepted are those accepted by the <command>-D</command> option to
many other cvsnt commands (<xref linkend="Common-options" />).
Dates can be combined into ranges as follows:
       </para>

       <variablelist>
        <varlistentry>
         <term><command><varname>d1</varname>&lt;<varname>d2</varname></command></term>
         <term><command><varname>d2</varname>&gt;<varname>d1</varname></command></term>
         <listitem>
          <para>
Select the revisions that were deposited between
<varname>d1</varname> and <varname>d2</varname>.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command>&lt;<varname>d</varname></command></term>
         <term><command><varname>d</varname>&gt;</command></term>
         <listitem>
          <para>
Select all revisions dated <varname>d</varname> or earlier.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>d</varname>&lt;</command></term>
         <term><command>&gt;<varname>d</varname></command></term>
         <listitem>
          <para>
Select all revisions dated <varname>d</varname> or later.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>d</varname></command></term>
         <listitem>
          <para>
Select the single, latest revision dated <varname>d</varname> or
earlier.
          </para></listitem></varlistentry></variablelist>     

       <para>
The <command>&gt;</command> or <command>&lt;</command> characters may be followed by
<command>=</command> to indicate an inclusive range rather than an
exclusive one.
       </para>

       <para>
Note that the separator is a semicolon (;).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-h</command></term>
      <listitem>
       <para>
Print only the name of the rcs file, name
of the file in the working directory, head,
default branch, access list, locks, symbolic names, and
suffix.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-l</command></term>
      <listitem>
       <para>
Local; run only in current working directory.  (Default
is to run recursively).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-N</command></term>
      <listitem>
       <para>
Do not print the list of tags for this file.  This
option can be very useful when your site uses a lot of
tags, so rather than "more"'ing over 3 pages of tag
information, the log information is presented without
tags at all.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-R</command></term>
      <listitem>
       <para>
Print only the name of the rcs file.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-r<varname>revisions</varname></command></term>
      <listitem>
       <para>
Print information about revisions given in the
comma-separated list <varname>revisions</varname> of revisions and
ranges.  The following table explains the available
range formats:
       </para>

       <variablelist>
        <varlistentry>
         <term><command><varname>rev1</varname>:<varname>rev2</varname></command></term>
         <listitem>
          <para>
Revisions <varname>rev1</varname> to <varname>rev2</varname> (which must be on
the same branch).
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>rev1</varname>::<varname>rev2</varname></command></term>
         <listitem>
          <para>
Revisions between, but not including, <varname>rev1</varname> and <varname>rev2</varname>.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command>:<varname>rev</varname></command></term>
         <listitem>
          <para>
Revisions from the beginning of the branch up to
and including <varname>rev</varname>.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command>::<varname>rev</varname></command></term>
         <listitem>
          <para>
Revisions from the beginning of the branch up to,
but not including, <varname>rev</varname>.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>rev</varname>:</command></term>
         <listitem>
          <para>
Revisions starting with <varname>rev</varname> to the end of the
branch containing <varname>rev</varname>.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>rev</varname>:</command></term>
         <listitem>
          <para>
Revisions starting just after <varname>rev</varname> to the end of the
branch containing <varname>rev</varname>.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>branch</varname></command></term>
         <listitem>
          <para>
An argument that is a branch means all revisions on
that branch.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>branch1</varname>:<varname>branch2</varname></command></term>
         <term><command><varname>branch1</varname>::<varname>branch2</varname></command></term>
         <listitem>
          <para>
A range of branches means all revisions
on the branches in that range.
          </para>
</listitem></varlistentry>
        <varlistentry>
         <term><command><varname>branch</varname>.</command></term>
         <listitem>
          <para>
The latest revision in <varname>branch</varname>.
          </para></listitem></varlistentry></variablelist>     

       <para>
A bare <command>-r</command> with no revisions means the latest
revision on the default branch, normally the trunk.
There can be no space between the <command>-r</command> option and
its argument.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-s <varname>states</varname></command></term>
      <listitem>
       <para>
Print information about revisions whose state
attributes match one of the states given in the
comma-separated list <varname>states</varname>.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-t</command></term>
      <listitem>
       <para>
Print the same as <command>-h</command>, plus the descriptive text.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-w<varname>logins</varname></command></term>
      <listitem>
       <para>
Print information about revisions checked in by users
with login names appearing in the comma-separated list
<varname>logins</varname>.  If <varname>logins</varname> is omitted, the user's
login is assumed.  There can be no space between the
<command>-w</command> option and its argument.
       </para></listitem></varlistentry></variablelist>

    <para><command>log</command> prints the intersection of the revisions
selected with the options <command>-d</command>, <command>-s</command>, and
<command>-w</command>, intersected with the union of the revisions
selected by <command>-b</command> and <command>-r</command>.
    </para>

</sect2>
   <sect2 id="log-examples">
    <title>log examples
</title>

    <para>
Contributed examples are gratefully accepted.
    </para>

</sect2></sect1>
  <sect1 id="rdiff">
   <title>rdiff--'patch' format diffs between releases
</title>
   <para><indexterm role="cp"><primary>rdiff (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
rdiff [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] modules&hellip;
     </para></listitem>
    <listitem>
     <para>
Requires: repository.
     </para></listitem>
    <listitem>
     <para>
Changes: nothing.
     </para></listitem>
    <listitem>
     <para>
Synonym: patch
     </para></listitem></itemizedlist>
   <para>
Builds a Larry Wall format patch(1) file between two
releases, that can be fed directly into the <command>patch</command>
program to bring an old release up-to-date with the new
release.  (This is one of the few cvsnt commands that
operates directly from the repository, and doesn't
require a prior checkout.) The diff output is sent to
the standard output device.
   </para>
   <para>
You can specify (using the standard <command>-r</command> and
<command>-D</command> options) any combination of one or two
revisions or dates.  If only one revision or date is
specified, the patch file reflects differences between
that revision or date and the current head revisions in
the rcs file.
   </para>
   <para>
Note that if the software release affected is contained
in more than one directory, then it may be necessary to
specify the <command>-p</command> option to the <command>patch</command> command when
patching the old sources, so that <command>patch</command> is able to find
the files that are located in other directories.
   </para>


   <sect2 id="rdiff-options">
    <title>rdiff options
</title>

    <para>
These standard options are supported by <command>rdiff</command>
(<xref linkend="Common-options" />, for a complete description of
them):
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-D <varname>date</varname></command></term>
      <listitem>
       <para>
Use the most recent revision no later than <varname>date</varname>.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-f</command></term>
      <listitem>
       <para>
If no matching revision is found, retrieve the most
recent revision (instead of ignoring the file).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-l</command></term>
      <listitem>
       <para>
Local; don't descend subdirectories.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-R</command></term>
      <listitem>
       <para>
Examine directories recursively.  This option is on by default.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-r <varname>tag</varname></command></term>
      <listitem>
       <para>
Use revision <varname>tag</varname>.
       </para></listitem></varlistentry></variablelist>
    <para>
In addition to the above, these options are available:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-c</command></term>
      <listitem>
       <para>
Use the context diff format.  This is the default format.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-s</command></term>
      <listitem>
       <para>
Create a summary change report instead of a patch.  The
summary includes information about files that were
changed or added between the releases.  It is sent to
the standard output device.  This is useful for finding
out, for example, which files have changed between two
dates or revisions.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-t</command></term>
      <listitem>
       <para>
A diff of the top two revisions is sent to the standard
output device.  This is most useful for seeing what the
last change to a file was.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-u</command></term>
      <listitem>
       <para>
Use the unidiff format for the context diffs.
Remember that old versions
of the <command>patch</command> program can't handle the unidiff
format, so if you plan to post this patch to the net
you should probably not use <command>-u</command>.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-V <varname>vn</varname></command></term>
      <listitem>
       <para>
Expand keywords according to the rules current in
rcs version <varname>vn</varname> (the expansion format changed with
rcs version 5).  Note that this option is no
longer accepted.  cvsnt will always expand keywords the
way that rcs version 5 does.
       </para></listitem></varlistentry></variablelist>
</sect2>
   <sect2 id="rdiff-examples">
    <title>rdiff examples
</title>

    <para>
Suppose you receive mail from <wordasword>foo@example.net</wordasword> asking for an
update from release 1.2 to 1.4 of the tc compiler.  You
have no such patches on hand, but with cvsnt that can
easily be fixed with a command such as this:
    </para>

    <para><screen>$ cvs rdiff -c -r FOO1_2 -r FOO1_4 tc | \
$$ Mail -s 'The patches you asked for' foo@example.net
</screen>    </para>
    <para>
Suppose you have made release 1.3, and forked a branch
called <command>R_1_3fix</command> for bugfixes.  <command>R_1_3_1</command>
corresponds to release 1.3.1, which was made some time
ago.  Now, you want to see how much development has been
done on the branch.  This command can be used:
    </para>
    <para><screen>
$ cvs patch -s -r R_1_3_1 -r R_1_3fix module-name
cvs rdiff: Diffing module-name
File ChangeLog,v changed from revision 1.52.2.5 to 1.52.2.6
File foo.c,v changed from revision 1.52.2.3 to 1.52.2.4
File bar.h,v changed from revision 1.29.2.1 to 1.2
</screen>       </para>
</sect2></sect1>
  <sect1 id="release">
   <title>release--Indicate that a Module is no longer in use
</title>
   <para><indexterm role="cp"><primary>release (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
release [-d [-f]] [-e] directories&hellip;
     </para></listitem>
    <listitem>
     <para>
Requires: Working directory.
     </para></listitem>
    <listitem>
     <para>
Changes: Working directory, history log.
     </para></listitem></itemizedlist>
   <para>
This command is meant to safely cancel the effect of
<command>cvs checkout</command>.  Since cvsnt doesn't lock files, it
isn't strictly necessary to use this command.  You can
always simply delete your working directory, if you
like; but you risk losing changes you may have
forgotten, and you leave no trace in the cvsnt history
file (<xref linkend="history-file" />) that you've abandoned your
checkout.
   </para>
   <para>
Use <command>cvs release</command> to avoid these problems.  This
command checks that no uncommitted changes are
present; that you are executing it from immediately
above a cvsnt working directory; and that the repository
recorded for your files is the same as the repository
defined in the module database.
   </para>
   <para>
If all these conditions are true, <command>cvs release</command>
leaves a record of its execution (attesting to your
intentionally abandoning your checkout) in the cvsnt
history log.
   </para>


   <sect2 id="release-options">
    <title>release options
</title>

    <para>
The <command>release</command> command supports the following command options:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-d</command></term>
      <listitem>
       <para>
Delete your working copy of the file if the release
succeeds.  If this flag is not given your files will
remain in your working directory.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-f</command></term>
      <listitem>
       <para>
Must be specified with -f, above.  Force the the deletion
of the directory even if non-cvs files are present.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-e</command></term>
      <listitem>
       <para>
Don't delete any files, just delete the cvsnt administrative
directories.  The directory is then left in a state as if it had
just been <command>export</command>ed.
       </para></listitem></varlistentry></variablelist>
</sect2>
   <sect2 id="release-output">
    <title>release output
</title>

    <para>
Before <command>release</command> releases your sources it will
print a one-line message if any file that is not
up-to-date.
    </para>

</sect2>
   <sect2 id="release-examples">
    <title>release examples
</title>

    <para>
Release the <command>tc</command> directory, and delete your local working copy
of the files.
    </para>

    <para><screen>$ cd ..         # You must stand immediately above the
                # sources when you issue <command>cvs release</command>.
$ cvs release -d tc
You have [5] altered files in this repository.
Are you sure you want to release (and delete) directory `tc': y
$
</screen>    </para>
</sect2></sect1>
  <sect1 id="update">
   <title>update--Bring work tree in sync with repository
</title>
   <para><indexterm role="cp"><primary>update (subcommand)</primary></indexterm>
   </para>
   <itemizedlist mark="bullet">
    <listitem>
     <para>
update [-AdflPpR] [-d] [-r tag|-D date] files&hellip;
     </para></listitem>
    <listitem>
     <para>
Requires: repository, working directory.
     </para></listitem>
    <listitem>
     <para>
Changes: working directory.
     </para></listitem></itemizedlist>
   <para>
After you've run checkout to create your private copy
of source from the common repository, other developers
will continue changing the central source.  From time
to time, when it is convenient in your development
process, you can use the <command>update</command> command from
within your working directory to reconcile your work
with any revisions applied to the source repository
since your last checkout or update.
   </para>


   <sect2 id="update-options">
    <title>update options
</title>

    <para>
These standard options are available with <command>update</command>
(<xref linkend="Common-options" />, for a complete description of
them):
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-D date</command></term>
      <listitem>
       <para>
Use the most recent revision no later than <varname>date</varname>.
This option is sticky, and implies <command>-P</command>.
See <xref linkend="Sticky-tags" />, for more information on sticky tags/dates.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-f</command></term>
      <listitem>
       <para>
Only useful with the <command>-D <varname>date</varname></command> or <command>-r
<varname>tag</varname></command> flags.  If no matching revision is found,
retrieve the most recent revision (instead of ignoring
the file).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-k <varname>kflag</varname></command></term>
      <listitem>
       <para>
Process keywords according to <varname>kflag</varname>.  See
<xref linkend="Keyword-substitution" />.
This option is sticky; future updates of
this file in this working directory will use the same
<varname>kflag</varname>.  The <command>status</command> command can be viewed
to see the sticky options.  See <xref linkend="Invoking-CVS" />, for
more information on the <command>status</command> command.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-l</command></term>
      <listitem>
       <para>
Local; run only in current working directory.  <xref linkend="Recursive-behavior" />.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-P</command></term>
      <listitem>
       <para>
Prune empty directories.  See <xref linkend="Moving-directories" />.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-p</command></term>
      <listitem>
       <para>
Pipe files to the standard output.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-R</command></term>
      <listitem>
       <para>
Update directories recursively (default).  <xref linkend="Recursive-behavior" />.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-r rev</command></term>
      <listitem>
       <para>
Retrieve revision/tag <varname>rev</varname>.  This option is sticky,
and implies <command>-P</command>.
See <xref linkend="Sticky-tags" />, for more information on sticky tags/dates.
       </para></listitem></varlistentry></variablelist>
    <para>
These special options are also available with
<command>update</command>.
    </para>

    <variablelist>
     <varlistentry>
      <term><command>-A</command></term>
      <listitem>
       <para>
Reset any sticky tags, dates, or <command>-k</command> options.
See <xref linkend="Sticky-tags" />, for more information on sticky tags/dates.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-C</command></term>
      <listitem>
       <para>
Overwrite locally modified files with clean copies from
the repository (the modified file is saved in
<command>.#<varname>file</varname>.<varname>revision</varname></command>, however).
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-d</command></term>
      <listitem>
       <para>
Create any directories that exist in the repository if
they're missing from the working directory.  Normally,
<command>update</command> acts only on directories and files that
were already enrolled in your working directory.
       </para>

       <para>
This is useful for updating directories that were
created in the repository since the initial checkout;
but it has an unfortunate side effect.  If you
deliberately avoided certain directories in the
repository when you created your working directory
(either through use of a module name or by listing
explicitly the files and directories you wanted on the
command line), then updating with <command>-d</command> will create
those directories, which may not be what you want.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-I <varname>name</varname></command></term>
      <listitem>
       <para>
Ignore files whose names match <varname>name</varname> (in your
working directory) during the update.  You can specify
<command>-I</command> more than once on the command line to specify
several files to ignore.  Use <command>-I !</command> to avoid
ignoring any files at all.  <xref linkend="cvsignore" />, for other
ways to make cvsnt ignore some files.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-W<varname>spec</varname></command></term>
      <listitem>
       <para>
Specify file names that should be filtered during
update.  You can use this option repeatedly.
       </para>

       <para><varname>spec</varname> can be a file name pattern of the same type
that you can specify in the <command>.cvswrappers</command>
file. <xref linkend="Wrappers" />.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>-j<varname>revision</varname></command></term>
      <listitem>
       <para>
With two <command>-j</command> options, merge changes from the
revision specified with the first <command>-j</command> option to
the revision specified with the second <command>j</command> option,
into the working directory.
       </para>

       <para>
With one <command>-j</command> option, merge changes from the
ancestor revision to the revision specified with the
<command>-j</command> option, into the working directory.  The
ancestor revision is the common ancestor of the
revision which the working directory is based on, and
the revision specified in the <command>-j</command> option.
       </para>

       <para>
Note that using a single <command>-j <varname>tagname</varname></command> option rather than
<command>-j <varname>branchname</varname></command> to merge changes from a branch will
often not remove files which were removed on the branch.
<xref linkend="Merging-adds-and-removals" />, for more.
       </para>

       <para>
In addition, each <command>-j</command> option can contain an optional
date specification which, when used with branches, can
limit the chosen revision to one within a specific
date.  An optional date is specified by adding a colon
(:) to the tag:
<command>-j<varname>Symbolic_Tag</varname>:<varname>Date_Specifier</varname></command>.
       </para>

       <para><xref linkend="Branching-and-merging" />.
       </para>
</listitem></varlistentry></variablelist>
</sect2>
   <sect2 id="update-output">
    <title>update output
</title>

    <para><command>update</command> and <command>checkout</command> keep you informed of
their progress by printing a line for each file, preceded
by one character indicating the status of the file:
    </para>

    <variablelist>
     <varlistentry>
      <term><command>U <varname>file</varname></command></term>
      <listitem>
       <para>
The file was brought up to date with respect to the
repository.  This is done for any file that exists in
the repository but not in your source, and for files
that you haven't changed but are not the most recent
versions available in the repository.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>P <varname>file</varname></command></term>
      <listitem>
       <para>
Like <command>U</command>, but the cvsnt server sends a patch
instead of an entire file.  These two things accomplish
the same thing.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>A <varname>file</varname></command></term>
      <listitem>
       <para>
The file has been added to your private copy of the
sources, and will be added to the source repository
when you run <command>commit</command> on the file.  This is a
reminder to you that the file needs to be committed.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>R <varname>file</varname></command></term>
      <listitem>
       <para>
The file has been removed from your private copy of the
sources, and will be removed from the source repository
when you run <command>commit</command> on the file.  This is a
reminder to you that the file needs to be committed.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>M <varname>file</varname></command></term>
      <listitem>
       <para>
The file is modified in  your  working  directory.
       </para>

       <para><command>M</command> can indicate one of two states for a file
you're working on: either there were no modifications
to the same file in the repository, so that your file
remains as you last saw it; or there were modifications
in the repository as well as in your copy, but they
were merged successfully, without conflict, in your
working directory.
       </para>

       <para>
cvsnt will print some messages if it merges your work,
and a backup copy of your working file (as it looked
before you ran <command>update</command>) will be made.  The exact
name of that file is printed while <command>update</command> runs.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>C <varname>file</varname></command></term>
      <listitem>
       <para><indexterm role="cp"><primary>.# files</primary></indexterm><indexterm role="cp"><primary>__ files (VMS)</primary></indexterm>A conflict was detected while trying to merge your
changes to <varname>file</varname> with changes from the source
repository.  <varname>file</varname> (the copy in your working
directory) is now the result of attempting to merge
the two revisions; an unmodified copy of your file
is also in your working directory, with the name
<command>.#<varname>file</varname>.<varname>revision</varname></command> where <varname>revision</varname>
is the revision that your modified file started
from.  Resolve the conflict as described in
<xref linkend="Conflicts-example" />.
(Note that some systems automatically purge
files that begin with <command>.#</command> if they have not been
accessed for a few days.  If you intend to keep a copy
of your original file, it is a very good idea to rename
it.)  Under vms, the file name starts with
<command>__</command> rather than <command>.#</command>.
       </para>
</listitem></varlistentry>
     <varlistentry>
      <term><command>? <varname>file</varname></command></term>
      <listitem>
       <para><varname>file</varname> is in your working directory, but does not
correspond to anything in the source repository, and is
not in the list of files for cvsnt to ignore (see the
description of the <command>-I</command> option, and
<xref linkend="cvsignore" />).
       </para></listitem></varlistentry></variablelist>
</sect2></sect1></appendix>
 <appendix id="Invoking-CVS">
  <title>Quick reference to CVS commands
</title>
  <para><indexterm role="cp"><primary>Command reference</primary></indexterm><indexterm role="cp"><primary>Reference, commands</primary></indexterm><indexterm role="cp"><primary>Invoking CVS</primary></indexterm>
This appendix describes how to invoke cvsnt, with
references to where each command or feature is
described in detail.  For other references run the
<command>cvs -help</command> command, or see <xref linkend="Index" />.
  </para>

  <para>
A cvsnt command looks like:
  </para>

  <para><screen>cvs [ <varname>global_options</varname> ] <varname>command</varname> [ <varname>command_options</varname> ] [ <varname>command_args</varname> ]
</screen>  </para>
  <para>
Global options:
  </para>

  <variablelist>
   <varlistentry>
    <term><command>-allow-root=<varname>rootdir</varname></command></term>
    <listitem>
     <para>
Specify legal cvsroot directory (server only) (not
in cvsnt 1.9 and older) .  See <xref linkend="Authentication-server" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-a</command></term>
    <listitem>
     <para>
Authenticate all communication (client only) (not in cvsnt
1.9 and older).  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-b</command></term>
    <listitem>
     <para>
Specify rcs location (cvsnt 1.9 and older).  See
<xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-d <varname>root</varname></command></term>
    <listitem>
     <para>
Specify the cvsroot.  See <xref linkend="Repository" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-e <varname>editor</varname></command></term>
    <listitem>
     <para>
Edit messages with <varname>editor</varname>.  See <xref linkend="Committing-your-changes" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-f</command></term>
    <listitem>
     <para>
Do not read the <command>~/.cvsrc</command> file.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-F</command></term>
    <listitem>
     <para>
Append contents of file to supplied arguments.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-H</command></term>
    <term><command>--help</command></term>
    <listitem>
     <para>
Print a help message.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-n</command></term>
    <listitem>
     <para>
Do not change any files.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-N</command></term>
    <listitem>
     <para>
Enable local access through network shares.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-Q</command></term>
    <listitem>
     <para>
Be really quiet.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-q</command></term>
    <listitem>
     <para>
Be somewhat quiet.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-r</command></term>
    <listitem>
     <para>
Make new working files read-only.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-s <varname>variable</varname>=<varname>value</varname></command></term>
    <listitem>
     <para>
Set a user variable.  See <xref linkend="Variables" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-T <varname>tempdir</varname></command></term>
    <listitem>
     <para>
Put temporary files in <varname>tempdir</varname>.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-t</command></term>
    <listitem>
     <para>
Trace cvsnt execution.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-v</command></term>
    <term><command>--version</command></term>
    <listitem>
     <para>
Display version and copyright information for cvsnt.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-w</command></term>
    <listitem>
     <para>
Make new working files read-write.  See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-x</command></term>
    <listitem>
     <para>
Encrypt all communication (client only).
See <xref linkend="Global-options" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>-z <varname>gzip-level</varname></command></term>
    <listitem>
     <para><indexterm role="cp"><primary>Compression</primary></indexterm><indexterm role="cp"><primary>Gzip</primary></indexterm>Set the compression level (client only).
See <xref linkend="Global-options" />.
     </para></listitem></varlistentry></variablelist>   
  <para>
Keyword expansion modes (<xref linkend="Substitution-modes" />):
  </para>
  <para><screen>
-kkv  &dollar;Id: file1,v 1.1 1993/12/09 03:21:13 joe Exp $
-kkvl &dollar;Id: file1,v 1.1 1993/12/09 03:21:13 joe Exp harry $
-kk   &dollar;Id$
-kv   file1,v 1.1 1993/12/09 03:21:13 joe Exp
-ko   <wordasword>no expansion</wordasword>
-kb   <wordasword>no expansion, file is binary</wordasword>
-kB   <wordasword>no expansion, file is binary</wordasword>
-ku   <wordasword>File is expanded to unicode on checkout</wordasword>
-kL   <wordasword>Win32 CR/LF pairs are not expanded by the client</wordasword>
</screen>     </para>
  <para>
Keywords (<xref linkend="Keyword-list" />):
  </para>
  <para><screen>
&dollar;Author: joe $
&dollar;Date: 1993/12/09 03:21:13 $
&dollar;Header: /home/files/file1,v 1.1 1993/12/09 03:21:13 joe Exp harry $
&dollar;Id: file1,v 1.1 1993/12/09 03:21:13 joe Exp harry $
&dollar;Locker: harry $
&dollar;Name: snapshot_1_14 $
&dollar;RCSfile: file1,v $
&dollar;Revision: 1.1 $
&dollar;Source: /home/files/file1,v $
&dollar;State: Exp $
&dollar;Log: file1,v $
  Revision 1.1  1993/12/09 03:30:17  joe
  Initial revision
</screen>     </para>
  <para>
Commands, command options, and command arguments:
  </para>

  <variablelist>
   <varlistentry>
    <term><command>add [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Add a new file/directory.  See <xref linkend="Adding-files" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-k <varname>kflag</varname></command></term>
       <listitem>
        <para>
Set keyword expansion.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-m <varname>msg</varname></command></term>
       <listitem>
        <para>
Set file description.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>admin [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Administration of history files in the repository.  See
<xref linkend="admin" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-b[<varname>rev</varname>]</command></term>
       <listitem>
        <para>
Set default branch.  See <xref linkend="Reverting-local-changes" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-c<varname>string</varname></command></term>
       <listitem>
        <para>
Set comment leader.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-k<varname>subst</varname></command></term>
       <listitem>
        <para>
Set keyword substitution.  See <xref linkend="Keyword-substitution" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l[<varname>rev</varname>]</command></term>
       <listitem>
        <para>
Lock revision <varname>rev</varname>, or latest revision.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-m<varname>rev</varname>:<varname>msg</varname></command></term>
       <listitem>
        <para>
Replace the log message of revision <varname>rev</varname> with
<varname>msg</varname>.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-o<varname>range</varname></command></term>
       <listitem>
        <para>
Delete revisions from the repository.  See
<xref linkend="admin-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-q</command></term>
       <listitem>
        <para>
Run quietly; do not print diagnostics.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-s<varname>state</varname>[:<varname>rev</varname>]</command></term>
       <listitem>
        <para>
Set the state.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-t</command></term>
       <listitem>
        <para>
Set file description from standard input.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-t<varname>file</varname></command></term>
       <listitem>
        <para>
Set file description from <varname>file</varname>.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-t-<varname>string</varname></command></term>
       <listitem>
        <para>
Set file description to <varname>string</varname>.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-u[<varname>rev</varname>]</command></term>
       <listitem>
        <para>
Unlock revision <varname>rev</varname>, or latest revision.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>annotate [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Show last revision where each line was modified.  See
<xref linkend="annotate" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-D <varname>date</varname></command></term>
       <listitem>
        <para>
Annotate the most recent revision no later than
<varname>date</varname>.  See <xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-f</command></term>
       <listitem>
        <para>
Use head revision if tag/date not found.  See
<xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>tag</varname></command></term>
       <listitem>
        <para>
Annotate revision <varname>tag</varname>.  See <xref linkend="Common-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>checkout [<varname>options</varname>] <varname>modules</varname>&hellip;</command></term>
    <listitem>
     <para>
Get a copy of the sources.  See <xref linkend="checkout" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-A</command></term>
       <listitem>
        <para>
Reset any sticky tags/date/options.  See <xref linkend="Sticky-tags" /> and <xref linkend="Keyword-substitution" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-c</command></term>
       <listitem>
        <para>
Output the module database.  See <xref linkend="checkout-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-D <varname>date</varname></command></term>
       <listitem>
        <para>
Check out revisions as of <varname>date</varname> (is sticky).  See
<xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-d <varname>dir</varname></command></term>
       <listitem>
        <para>
Check out into <varname>dir</varname>.  See <xref linkend="checkout-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-f</command></term>
       <listitem>
        <para>
Use head revision if tag/date not found.  See
<xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-j <varname>rev</varname></command></term>
       <listitem>
        <para>
Merge in changes.  See <xref linkend="checkout-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-k <varname>kflag</varname></command></term>
       <listitem>
        <para>
Use <varname>kflag</varname> keyword expansion.  See
<xref linkend="Substitution-modes" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-N</command></term>
       <listitem>
        <para>
Don't "shorten" module paths if -d specified.  See
<xref linkend="checkout-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-n</command></term>
       <listitem>
        <para>
Do not run module program (if any).  See <xref linkend="checkout-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-P</command></term>
       <listitem>
        <para>
Prune empty directories.  See <xref linkend="Moving-directories" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-p</command></term>
       <listitem>
        <para>
Check out files to standard output (avoids
stickiness).  See <xref linkend="checkout-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>tag</varname></command></term>
       <listitem>
        <para>
Checkout revision <varname>tag</varname> (is sticky).  See <xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-s</command></term>
       <listitem>
        <para>
Like -c, but include module status.  See <xref linkend="checkout-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>commit [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Check changes into the repository.  See <xref linkend="commit" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-F <varname>file</varname></command></term>
       <listitem>
        <para>
Read log message from <varname>file</varname>.  See <xref linkend="commit-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-f</command></term>
       <listitem>
        <para>
Force the file to be committed; disables recursion.
See <xref linkend="commit-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-m <varname>msg</varname></command></term>
       <listitem>
        <para>
Use <varname>msg</varname> as log message.  See <xref linkend="commit-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-n</command></term>
       <listitem>
        <para>
Do not run module program (if any).  See <xref linkend="commit-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>rev</varname></command></term>
       <listitem>
        <para>
Commit to <varname>rev</varname>.  See <xref linkend="commit-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>diff [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Show differences between revisions.  See <xref linkend="diff" />.
In addition to the options shown below, accepts a wide
variety of options to control output style, for example
<command>-c</command> for context diffs.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-D <varname>date1</varname></command></term>
       <listitem>
        <para>
Diff revision for date against working file.  See
<xref linkend="diff-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-D <varname>date2</varname></command></term>
       <listitem>
        <para>
Diff <varname>rev1</varname>/<varname>date1</varname> against <varname>date2</varname>.  See
<xref linkend="diff-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-N</command></term>
       <listitem>
        <para>
Include diffs for added and removed files.  See
<xref linkend="diff-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>rev1</varname></command></term>
       <listitem>
        <para>
Diff revision for <varname>rev1</varname> against working file.  See
<xref linkend="diff-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>rev2</varname></command></term>
       <listitem>
        <para>
Diff <varname>rev1</varname>/<varname>date1</varname> against <varname>rev2</varname>.  See <xref linkend="diff-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>edit [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Get ready to edit a watched file.  See <xref linkend="Editing-files" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-a <varname>actions</varname></command></term>
       <listitem>
        <para>
Specify actions for temporary watch, where
<varname>actions</varname> is <command>edit</command>, <command>unedit</command>,
<command>commit</command>, <command>all</command>, or <command>none</command>.  See
<xref linkend="Editing-files" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>editors [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
See who is editing a watched file.  See <xref linkend="Watch-information" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>export [<varname>options</varname>] <varname>modules</varname>&hellip;</command></term>
    <listitem>
     <para>
Export files from cvsnt.  See <xref linkend="export" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-D <varname>date</varname></command></term>
       <listitem>
        <para>
Check out revisions as of <varname>date</varname>.  See
<xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-d <varname>dir</varname></command></term>
       <listitem>
        <para>
Check out into <varname>dir</varname>.  See <xref linkend="export-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-f</command></term>
       <listitem>
        <para>
Use head revision if tag/date not found.  See
<xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-k <varname>kflag</varname></command></term>
       <listitem>
        <para>
Use <varname>kflag</varname> keyword expansion.  See
<xref linkend="Substitution-modes" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-N</command></term>
       <listitem>
        <para>
Don't "shorten" module paths if -d specified.  See
<xref linkend="export-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-n</command></term>
       <listitem>
        <para>
Do not run module program (if any).  See <xref linkend="export-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-P</command></term>
       <listitem>
        <para>
Prune empty directories.  See <xref linkend="Moving-directories" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>tag</varname></command></term>
       <listitem>
        <para>
Checkout revision <varname>tag</varname>.  See <xref linkend="Common-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>history [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Show repository access history.  See <xref linkend="history" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-a</command></term>
       <listitem>
        <para>
All users (default is self).  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-b <varname>str</varname></command></term>
       <listitem>
        <para>
Back to record with <varname>str</varname> in module/file/repos
field.  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-c</command></term>
       <listitem>
        <para>
Report on committed (modified) files.  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-D <varname>date</varname></command></term>
       <listitem>
        <para>
Since <varname>date</varname>.  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-e</command></term>
       <listitem>
        <para>
Report on all record types.  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Last modified (committed or modified report).  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-m <varname>module</varname></command></term>
       <listitem>
        <para>
Report on <varname>module</varname> (repeatable).  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-n <varname>module</varname></command></term>
       <listitem>
        <para>
In <varname>module</varname>.  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-o</command></term>
       <listitem>
        <para>
Report on checked out modules.  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>rev</varname></command></term>
       <listitem>
        <para>
Since revision <varname>rev</varname>.  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-T</command></term>
       <listitem>
        <para>
Produce report on all TAGs.  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-t <varname>tag</varname></command></term>
       <listitem>
        <para>
Since tag record placed in history file (by anyone).
See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-u <varname>user</varname></command></term>
       <listitem>
        <para>
For user <varname>user</varname> (repeatable).  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-w</command></term>
       <listitem>
        <para>
Working directory must match.  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-x <varname>types</varname></command></term>
       <listitem>
        <para>
Report on <varname>types</varname>, one or more of
<command>TOEFWUCGMAR</command>.  See <xref linkend="history-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-z <varname>zone</varname></command></term>
       <listitem>
        <para>
Output for time zone <varname>zone</varname>.  See <xref linkend="history-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>import [<varname>options</varname>] <varname>repository</varname> <varname>vendor-tag</varname> <varname>release-tags</varname>&hellip;</command></term>
    <listitem>
     <para>
Import files into cvsnt, using vendor branches.  See
<xref linkend="import" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-b <varname>bra</varname></command></term>
       <listitem>
        <para>
Import to vendor branch <varname>bra</varname>.  See
<xref linkend="Multiple-vendor-branches" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-d</command></term>
       <listitem>
        <para>
Use the file's modification time as the time of
import.  See <xref linkend="import-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-k <varname>kflag</varname></command></term>
       <listitem>
        <para>
Set default keyword substitution mode.  See
<xref linkend="import-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-m <varname>msg</varname></command></term>
       <listitem>
        <para>
Use <varname>msg</varname> for log message.  See
<xref linkend="import-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-I <varname>ign</varname></command></term>
       <listitem>
        <para>
More files to ignore (! to reset).  See
<xref linkend="import-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-W <varname>spec</varname></command></term>
       <listitem>
        <para>
More wrappers.  See <xref linkend="import-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>init</command></term>
    <listitem>
     <para>
Create a cvsnt repository if it doesn't exist.  See
<xref linkend="Creating-a-repository" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>log [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Print out history information for files.  See <xref linkend="log" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-b</command></term>
       <listitem>
        <para>
Only list revisions on the default branch.  See <xref linkend="log-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-d <varname>dates</varname></command></term>
       <listitem>
        <para>
Specify dates (<varname>d1</varname>&lt;<varname>d2</varname> for range, <varname>d</varname> for
latest before).  See <xref linkend="log-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-h</command></term>
       <listitem>
        <para>
Only print header.  See <xref linkend="log-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-N</command></term>
       <listitem>
        <para>
Do not list tags.  See <xref linkend="log-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Only print name of rcs file.  See <xref linkend="log-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r<varname>revs</varname></command></term>
       <listitem>
        <para>
Only list revisions <varname>revs</varname>.  See <xref linkend="log-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-s <varname>states</varname></command></term>
       <listitem>
        <para>
Only list revisions with specified states.  See <xref linkend="log-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-t</command></term>
       <listitem>
        <para>
Only print header and descriptive text.  See <xref linkend="log-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-w<varname>logins</varname></command></term>
       <listitem>
        <para>
Only list revisions checked in by specified logins.  See <xref linkend="log-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>login</command></term>
    <listitem>
     <para>
Prompt for password for authenticating server.  See
<xref linkend="Authentication-client" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>logout</command></term>
    <listitem>
     <para>
Remove stored password for authenticating server.  See
<xref linkend="Authentication-client" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>rdiff [<varname>options</varname>] <varname>modules</varname>&hellip;</command></term>
    <listitem>
     <para>
Show differences between releases.  See <xref linkend="rdiff" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-c</command></term>
       <listitem>
        <para>
Context diff output format (default).  See <xref linkend="rdiff-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-D <varname>date</varname></command></term>
       <listitem>
        <para>
Select revisions based on <varname>date</varname>.  See <xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-f</command></term>
       <listitem>
        <para>
Use head revision if tag/date not found.  See
<xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>rev</varname></command></term>
       <listitem>
        <para>
Select revisions based on <varname>rev</varname>.  See <xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-s</command></term>
       <listitem>
        <para>
Short patch - one liner per file.  See <xref linkend="rdiff-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-t</command></term>
       <listitem>
        <para>
Top two diffs - last change made to the file.  See
<xref linkend="diff-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-u</command></term>
       <listitem>
        <para>
Unidiff output format.  See <xref linkend="rdiff-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-V <varname>vers</varname></command></term>
       <listitem>
        <para>
Use rcs Version <varname>vers</varname> for keyword expansion (obsolete).  See
<xref linkend="rdiff-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>release [<varname>options</varname>] <varname>directory</varname></command></term>
    <listitem>
     <para>
Indicate that a directory is no longer in use.  See
<xref linkend="release" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-d</command></term>
       <listitem>
        <para>
Delete the given directory.  See <xref linkend="release-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>remove [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Remove an entry from the repository.  See <xref linkend="Removing-files" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-f</command></term>
       <listitem>
        <para>
Delete the file before removing it.  See <xref linkend="Removing-files" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>rtag [<varname>options</varname>] <varname>tag</varname> <varname>modules</varname>&hellip;</command></term>
    <listitem>
     <para>
Add a symbolic tag to a module.
See <xref linkend="Revisions" /> and <xref linkend="Branching-and-merging" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-A</command></term>
       <listitem>
        <para>
		Create an alias of a branch rather than tagging the latest revision.  Requires -r.  See <xref linkend="Alias-Tags" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-b</command></term>
       <listitem>
        <para>
Create a branch named <varname>tag</varname>.  See <xref linkend="Branching-and-merging" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-D <varname>date</varname></command></term>
       <listitem>
        <para>
Tag revisions as of <varname>date</varname>.  See <xref linkend="Tagging-by-date-tag" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-d</command></term>
       <listitem>
        <para>
Delete <varname>tag</varname>.  See <xref linkend="Modifying-tags" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-F</command></term>
       <listitem>
        <para>
Move <varname>tag</varname> if it already exists.  See <xref linkend="Modifying-tags" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-f</command></term>
       <listitem>
        <para>
Force a head revision match if tag/date not found.
See <xref linkend="Tagging-by-date-tag" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-n</command></term>
       <listitem>
        <para>
No execution of tag program.  See <xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>rev</varname></command></term>
       <listitem>
        <para>
Tag existing tag <varname>rev</varname>.  See <xref linkend="Tagging-by-date-tag" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>status [<varname>options</varname>] <varname>files</varname>&hellip;</command></term>
    <listitem>
     <para>
Display status information in a working directory.  See
<xref linkend="File-status" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-v</command></term>
       <listitem>
        <para>
Include tag information for file.  See <xref linkend="Tags" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>tag [<varname>options</varname>] <varname>tag</varname> [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Add a symbolic tag to checked out version of files.
See <xref linkend="Revisions" /> and <xref linkend="Branching-and-merging" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-A</command></term>
       <listitem>
        <para>
		Create an alias of a branch rather than tagging the latest revision.  Requires -r.  See <xref linkend="Alias-Tags" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-b</command></term>
       <listitem>
        <para>
Create a branch named <varname>tag</varname>.  See <xref linkend="Branching-and-merging" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-c</command></term>
       <listitem>
        <para>
Check that working files are unmodified.  See
<xref linkend="Tagging-the-working-directory" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-D <varname>date</varname></command></term>
       <listitem>
        <para>
Tag revisions as of <varname>date</varname>.  See <xref linkend="Tagging-by-date-tag" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-d</command></term>
       <listitem>
        <para>
Delete <varname>tag</varname>.  See <xref linkend="Modifying-tags" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-F</command></term>
       <listitem>
        <para>
Move <varname>tag</varname> if it already exists.  See <xref linkend="Modifying-tags" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-f</command></term>
       <listitem>
        <para>
Force a head revision match if tag/date not found.
See <xref linkend="Tagging-by-date-tag" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>rev</varname></command></term>
       <listitem>
        <para>
Tag existing tag <varname>rev</varname>.  See <xref linkend="Tagging-by-date-tag" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>unedit [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Undo an edit command.  See <xref linkend="Editing-files" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-a <varname>actions</varname></command></term>
       <listitem>
        <para>
Specify actions for temporary watch, where
<varname>actions</varname> is <command>edit</command>, <command>unedit</command>,
<command>commit</command>, <command>all</command>, or <command>none</command>.  See
<xref linkend="Editing-files" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>update [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
Bring work tree in sync with repository.  See
<xref linkend="update" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-A</command></term>
       <listitem>
        <para>
Reset any sticky tags/date/options.  See <xref linkend="Sticky-tags" /> and <xref linkend="Keyword-substitution" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-C</command></term>
       <listitem>
        <para>
Overwrite locally modified files with clean copies from
the repository (the modified file is saved in
<command>.#<varname>file</varname>.<varname>revision</varname></command>, however).
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-D <varname>date</varname></command></term>
       <listitem>
        <para>
Check out revisions as of <varname>date</varname> (is sticky).  See
<xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-d</command></term>
       <listitem>
        <para>
Create directories.  See <xref linkend="update-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-f</command></term>
       <listitem>
        <para>
Use head revision if tag/date not found.  See
<xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-I <varname>ign</varname></command></term>
       <listitem>
        <para>
More files to ignore (! to reset).  See
<xref linkend="import-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-j <varname>rev</varname></command></term>
       <listitem>
        <para>
Merge in changes.  See <xref linkend="update-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-k <varname>kflag</varname></command></term>
       <listitem>
        <para>
Use <varname>kflag</varname> keyword expansion.  See
<xref linkend="Substitution-modes" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-P</command></term>
       <listitem>
        <para>
Prune empty directories.  See <xref linkend="Moving-directories" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-p</command></term>
       <listitem>
        <para>
Check out files to standard output (avoids
stickiness).  See <xref linkend="update-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-r <varname>tag</varname></command></term>
       <listitem>
        <para>
Checkout revision <varname>tag</varname> (is sticky).  See <xref linkend="Common-options" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-W <varname>spec</varname></command></term>
       <listitem>
        <para>
More wrappers.  See <xref linkend="import-options" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>version</command></term>
    <listitem>
     <para><indexterm role="cp"><primary>version (subcommand)</primary></indexterm>
Display the version of cvsnt being used.  If the repository
is remote, display both the client and server versions.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>watch [on|off|add|remove] [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>

     <para>
on/off: turn on/off read-only checkouts of files.  See
<xref linkend="Setting-a-watch" />.
     </para>

     <para>
add/remove: add or remove notification on actions.  See
<xref linkend="Getting-Notified" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-a <varname>actions</varname></command></term>
       <listitem>
        <para>
Specify actions for temporary watch, where
<varname>actions</varname> is <command>edit</command>, <command>unedit</command>,
<command>commit</command>, <command>all</command>, or <command>none</command>.  See
<xref linkend="Editing-files" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry>
   <varlistentry>
    <term><command>watchers [<varname>options</varname>] [<varname>files</varname>&hellip;]</command></term>
    <listitem>
     <para>
See who is watching a file.  See <xref linkend="Watch-information" />.
     </para>

     <variablelist>
      <varlistentry>
       <term><command>-l</command></term>
       <listitem>
        <para>
Local; run only in current working directory.  See <xref linkend="Recursive-behavior" />.
        </para>
</listitem></varlistentry>
      <varlistentry>
       <term><command>-R</command></term>
       <listitem>
        <para>
Operate recursively (default).  <xref linkend="Recursive-behavior" />.
        </para></listitem></varlistentry></variablelist>     
</listitem></varlistentry></variablelist>
</appendix>
 <appendix id="Administrative-files">
  <title>Reference manual for Administrative files
</title>
  <para><indexterm role="cp"><primary>Administrative files (reference)</primary></indexterm><indexterm role="cp"><primary>Files, reference manual</primary></indexterm><indexterm role="cp"><primary>Reference manual (files)</primary></indexterm><indexterm role="cp"><primary>CVSROOT (file)</primary></indexterm>
Inside the repository, in the directory
<command>$CVSROOT/CVSROOT</command>, there are a number of
supportive files for cvsnt.  You can use cvsnt in a limited
fashion without any of them, but if they are set up
properly they can help make life easier.  For a
discussion of how to edit them, see <xref linkend="Intro-administrative-files" />.
  </para>

  <para>
The most important of these files is the <command>modules</command>
file, which defines the modules inside the repository.
  </para>

  <sect1 id="modules">
   <title>The modules file
</title>
   <para><indexterm role="cp"><primary>Modules (admin file)</primary></indexterm><indexterm role="cp"><primary>Defining modules (reference manual)</primary></indexterm>
The <command>modules</command> file records your definitions of
names for collections of source code.  cvsnt will
use these definitions if you use cvsnt to update the
modules file (use normal commands like <command>add</command>,
<command>commit</command>, etc).
   </para>

   <para>
The <command>modules</command> file may contain blank lines and
comments (lines beginning with <command>#</command>) as well as
module definitions.  Long lines can be continued on the
next line by specifying a backslash (<command>\</command>) as the
last character on the line.
   </para>

   <para>
There are three basic types of modules: alias modules,
regular modules, and ampersand modules.  The difference
between them is the way that they map files in the
repository to files in the working directory.  In all
of the following examples, the top-level repository
contains a directory called <command>first-dir</command>, which
contains two files, <command>file1</command> and <command>file2</command>, and a
directory <command>sdir</command>.  <command>first-dir/sdir</command> contains
a file <command>sfile</command>.
   </para>

   <sect2 id="Alias-modules">
    <title>Alias modules
</title>
    <para><indexterm role="cp"><primary>Alias modules</primary></indexterm><indexterm role="cp"><primary>-a, in modules file</primary></indexterm>
Alias modules are the simplest kind of module:
    </para>

    <variablelist>
     <varlistentry>
      <term><command><varname>mname</varname> -a <varname>aliases</varname>&hellip;</command></term>
      <listitem>
       <para>
This represents the simplest way of defining a module
<varname>mname</varname>.  The <command>-a</command> flags the definition as a
simple alias: cvsnt will treat any use of <varname>mname</varname> (as
a command argument) as if the list of names
<varname>aliases</varname> had been specified instead.
<varname>aliases</varname> may contain either other module names or
paths.  When you use paths in aliases, <command>checkout</command>
creates all intermediate directories in the working
directory, just as if the path had been specified
explicitly in the cvsnt arguments.
       </para></listitem></varlistentry></variablelist>
    <para>
For example, if the modules file contains:
    </para>
    <para><screen>
amodule -a first-dir
</screen>       </para>

    <para>
then the following two commands are equivalent:
    </para>

    <para><screen>
$ cvs co amodule
$ cvs co first-dir
</screen>    </para>

    <para>
and they each would provide output such as:
    </para>

    <para><screen>
cvs checkout: Updating first-dir
U first-dir/file1
U first-dir/file2
cvs checkout: Updating first-dir/sdir
U first-dir/sdir/sfile
</screen>    </para>
</sect2>
   <sect2 id="Regular-modules">
    <title>Regular modules
</title>
    <para><indexterm role="cp"><primary>Regular modules</primary></indexterm>
    </para>
    <variablelist>
     <varlistentry>
      <term><command><varname>mname</varname> [ options ] <varname>dir</varname> [ <varname>files</varname>&hellip; ]</command></term>
      <listitem>
       <para>
In the simplest case, this form of module definition
reduces to <command><varname>mname</varname> <varname>dir</varname></command>.  This defines
all the files in directory <varname>dir</varname> as module mname.
<varname>dir</varname> is a relative path (from <command>$CVSROOT</command>) to a
directory of source in the source repository.  In this
case, on checkout, a single directory called
<varname>mname</varname> is created as a working directory; no
intermediate directory levels are used by default, even
if <varname>dir</varname> was a path involving several directory
levels.
       </para></listitem></varlistentry></variablelist>
    <para>
For example, if a module is defined by:
    </para>
    <para><screen>
regmodule first-dir
</screen>       </para>

    <para>
then regmodule will contain the files from first-dir:
    </para>

    <para><screen>
$ cvs co regmodule
cvs checkout: Updating regmodule
U regmodule/file1
U regmodule/file2
cvs checkout: Updating regmodule/sdir
U regmodule/sdir/sfile
$
</screen>    </para>
    <para>
By explicitly specifying files in the module definition
after <varname>dir</varname>, you can select particular files from
directory <varname>dir</varname>.  Here is
an example:
    </para>
    <para><screen>
regfiles first-dir/sdir sfile
</screen>       </para>

    <para>
With this definition, getting the regfiles module
will create a single working directory
<command>regfiles</command> containing the file listed, which
comes from a directory deeper
in the cvsnt source repository:
    </para>

    <para><screen>
$ cvs co regfiles
U regfiles/sfile
$
</screen>    </para>
</sect2>
   <sect2 id="Ampersand-modules">
    <title>Ampersand modules
</title>
    <para><indexterm role="cp"><primary>Ampersand modules</primary></indexterm><indexterm role="cp"><primary>&amp;, in modules file</primary></indexterm>
A module definition can refer to other modules by
including <command>&amp;<varname>module</varname></command> in its definition.
<screen><varname>mname</varname> [ options ] <varname>&amp;module</varname>&hellip;
</screen>    </para>
    <para>
Then getting the module creates a subdirectory for each such
module, in the directory containing the module.  For
example, if modules contains
    </para>
    <para><screen>
ampermod &amp;first-dir
</screen>       </para>
    <para>
then a checkout will create an <command>ampermod</command> directory
which contains a directory called <command>first-dir</command>,
which in turns contains all the directories and files
which live there.  For example, the command
    </para>
    <para><screen>
$ cvs co ampermod
</screen>       </para>

    <para>
will create the following files:
    </para>

    <para><screen>
ampermod/first-dir/file1
ampermod/first-dir/file2
ampermod/first-dir/sdir/sfile
</screen>    </para>
    <para>
There is one quirk/bug: the messages that cvsnt
prints omit the <command>ampermod</command>, and thus do not
correctly display the location to which it is checking
out the files:
    </para>
    <para><screen>
$ cvs co ampermod
cvs checkout: Updating first-dir
U first-dir/file1
U first-dir/file2
cvs checkout: Updating first-dir/sdir
U first-dir/sdir/sfile
$
</screen>       </para>
    <para>
Do not rely on this buggy behavior; it may get fixed in
a future release of cvsnt.
    </para>
</sect2>
   <sect2 id="Excluding-directories">
    <title>Excluding directories
</title>
    <para><indexterm role="cp"><primary>Excluding directories, in modules file</primary></indexterm><indexterm role="cp"><primary>!, in modules file</primary></indexterm>
An alias module may exclude particular directories from
other modules by using an exclamation mark (<command>!</command>)
before the name of each directory to be excluded.
    </para>

    <para>
For example, if the modules file contains:
    </para>

    <para><screen>exmodule -a !first-dir/sdir first-dir
</screen>    </para>
    <para>
then checking out the module <command>exmodule</command> will check
out everything in <command>first-dir</command> except any files in
the subdirectory <command>first-dir/sdir</command>.
    </para>
</sect2>
   <sect2 id="Module-options">
    <title>Module options
</title>
    <para><indexterm role="cp"><primary>Options, in modules file</primary></indexterm>
Either regular modules or ampersand modules can contain
options, which supply additional information concerning
the module.
    </para>

    <variablelist>
     <title><indexterm role="cp"><primary>-d, in modules file</primary></indexterm></title>
     <varlistentry>
      <term><command>-d <varname>name</varname></command></term>
      <listitem>
       <para>
Name the working directory something other than the
module name.
       </para>

       <para><indexterm role="cp"><primary>Export program</primary></indexterm><indexterm role="cp"><primary>-e, in modules file</primary></indexterm>       </para></listitem></varlistentry>
     <varlistentry>
      <term><command>-e <varname>prog</varname></command></term>
      <listitem>
       <para>
Specify a program <varname>prog</varname> to run whenever files in a
module are exported.  <varname>prog</varname> runs with a single
argument, the module name.
       </para>

       <para><indexterm role="cp"><primary>Checkin program</primary></indexterm><indexterm role="cp"><primary>-i, in modules file</primary></indexterm>       </para></listitem></varlistentry>
     <varlistentry>
      <term><command>-i <varname>prog</varname></command></term>
      <listitem>
       <para>
Specify a program <varname>prog</varname> to run whenever files in a
module are committed.  <varname>prog</varname> runs with a single
argument, the full pathname of the affected directory
in a source repository.  The <command>commitinfo</command>,
<command>loginfo</command>, and <command>verifymsg</command> files provide other
ways to call a program on commit.
       </para>

       <para><indexterm role="cp"><primary>Checkout program</primary></indexterm><indexterm role="cp"><primary>-o, in modules file</primary></indexterm>       </para></listitem></varlistentry>
     <varlistentry>
      <term><command>-o <varname>prog</varname></command></term>
      <listitem>
       <para>
Specify a program <varname>prog</varname> to run whenever files in a
module are checked out.  <varname>prog</varname> runs with a single
argument, the module name.
       </para>

       <para><indexterm role="cp"><primary>Status of a module</primary></indexterm><indexterm role="cp"><primary>Module status</primary></indexterm><indexterm role="cp"><primary>-s, in modules file</primary></indexterm>       </para></listitem></varlistentry>
     <varlistentry>
      <term><command>-s <varname>status</varname></command></term>
      <listitem>
       <para>
Assign a status to the module.  When the module file is
printed with <command>cvs checkout -s</command> the modules are
sorted according to primarily module status, and
secondarily according to the module name.  This option
has no other meaning.  You can use this option for
several things besides status: for instance, list the
person that is responsible for this module.
       </para>

       <para><indexterm role="cp"><primary>Tag program</primary></indexterm><indexterm role="cp"><primary>-t, in modules file</primary></indexterm>       </para></listitem></varlistentry>
     <varlistentry>
      <term><command>-t <varname>prog</varname></command></term>
      <listitem>
       <para>
Specify a program <varname>prog</varname> to run whenever files in a
module are tagged with <command>rtag</command>.  <varname>prog</varname> runs
with two arguments: the module name and the symbolic
tag specified to <command>rtag</command>.  It is not run
when <command>tag</command> is executed.  Generally you will find
that taginfo is a better solution (<xref linkend="user-defined-logging" />).
       </para></listitem></varlistentry></variablelist>
</sect2>
   <sect2 id="Module-program-options">
    <title>How the modules file "program options" programs are run
</title>
    <para><indexterm role="cp"><primary>Modules file program options</primary></indexterm><indexterm role="cp"><primary>-u, in modules file</primary></indexterm><indexterm role="cp"><primary>-t, in modules file</primary></indexterm><indexterm role="cp"><primary>-o, in modules file</primary></indexterm><indexterm role="cp"><primary>-i, in modules file</primary></indexterm><indexterm role="cp"><primary>-e, in modules file</primary></indexterm>
    </para>

    <para>
For checkout, rtag, and export, the program is server-based, and as such the
following applies:-
    </para>

    <para>
If using remote access methods (pserver, ext, etc.),
cvsnt will execute this program on the server from a temporary
directory. The path is searched for this program.
    </para>

    <para>
If using "local access" (on a local or remote NFS filesystem, i.e.
repository set just to a path),
the program will be executed from the newly checked-out tree, if
found there, or alternatively searched for in the path if not.
    </para>

    <para>
The programs are all run after the operation has effectively
completed.
    </para>


</sect2></sect1>
<sect1 id="modules2">
<title>The modules2 file</title>
<para><indexterm role="cp"><primary>modules2 (admin file)</primary></indexterm>
The <command>modules2</command> file provides a lower level definition of modules than the <command>modules</command> file.  Clients
see the <command>modules2</command> structure as if it existed physically on the server.
</para>
<sect2 id="modules2-comparison">
<title>How the modules2 file differs from the modules file</title>
<para><indexterm role="cp"><primary>modules2, compared to modules</primary></indexterm>
The <command>modules</command> provides different types of module, which are 'high level', in that
checking out a module is equivalent to calling checkout multiple times on different directories.  This
approach works well for simple cases, but breaks down in the more complex cases, causing unwanted interactions
with the <command>update</command> command for example.
</para>
<para>The <command>modules2</command> has only one way of describing a module, but operates on a much lower
level.  Clients are unaware that the directory structure that they are checking out does not actually exist,
and all cvs commands behave as normal.  A file or directory defined by modules2 may have a completely different name to
its real name, and updates/merging will be handled correctly even if multiple clients checkout under different names.
</para>
<para>Which file you choose depends on your requirements.  It isn't recommend that usage is mixed between the two files as
they both serve a similar function and it would get confusing.</para>
</sect2>
<sect2 id="modules2-usage">
<title>Modules2 syntax</title>
<para><indexterm role="cp"><primary>modules2, syntax</primary></indexterm>
The <command>modules2</command> file is structured in a similar way to the familiar Windows .ini file.  Each section
defines a module, and within each section is a description of the files and directories within that module.
</para>
<para>
An example modules2 file is:
</para>
<para>
<screen>
  [pets]
  dog
  cat

  [people]
  brother
  sister

  [household]
  pets
  people
</screen></para>
<para>
Checking out 'household' will create the directory structure:
</para>
<para><screen>
  household
    pets
      dog
      cat
    people
      brother
      sister
</screen></para>
<para>
In this example the 'household', 'pets', and 'people' directories don't have any files in them - they're just containers. However let's say we want to put the files listing pet food in the pets directory, above all the pet specific directories.
</para>
<para>
Modules2 lets you override what goes in the root of a module, to overlay another module in it:
</para>
<para><screen>
  [pets]
  / = !petfood
  dog
  cat

  [people]
  brother
  sister

  [household]
  pets
  people
</screen></para>
<para>
Now when we checkout we get the same directory structure as above, but the pets directory contains the contents of 'petfood'. Note also we said that we don't want any subdirectories of petfood, using the '!' prefix. This makes sure that the directory is never recursed into, even during an update -d. We still get the 'dog' and 'cat' directory of course.
</para>
<para>
You can simply rename an entire directory tree using this method. The following:
</para>
<para><screen>
  [project1]
  / = myproject

  [project2]
  / = myproject
  junk =
  total_junk =
  project/old_project = myproject/junk
</screen></para>
<para>
project1 will checkout the entire myproject tree. project2 is the same, except the 'junk' directory is removed, and moved to project/oldproject. The total_junk directory is hidden completely.
</para>
<para>
You can also mask certain files within a directory, or certain subdirectories using an extended regular expression.
</para>
<para><screen>
  [project1]
  / = myproject

  [project2]
  / = myproject (*\.cpp$|*\.[ch]$|*/$)
  junk =
  total_junk =
  project/old_project = myproject/junk
</screen></para>
<para>
Directories are subject to the same filtering, except they have a '/' directory separator after their name. If you just want to filter some files and allow subdirectories then add '|*/$' as an option.
</para>
<para>
(need to be more verbose here: FIXME)
</para>
<para>
The '+' prefix stops processing, so that entries that would be potentially recursive can be defined to be nonrecursive.
</para>
<para>
Spaces can be used in the file, delimited by quotes or using backslash escapes. File separators must always be forward slashes.
</para>
<para>
Comments are on a line beginning '#' 
</para>
</sect2>
</sect1>
  <sect1 id="Wrappers">
   <title>The cvswrappers file
</title>
   <para><indexterm role="cp"><primary>cvswrappers (admin file)</primary></indexterm><indexterm role="cp"><primary>CVSWRAPPERS, environment variable</primary></indexterm><indexterm role="cp"><primary>Wrappers</primary></indexterm>
   </para>

   <para>
Wrappers refers to a cvsnt feature which lets you
control certain settings based on the name of the file
which is being operated on.  The settings are <command>-k</command>
for binary files, and <command>-m</command> for nonmergeable text
files.
   </para>


   <para>
The <command>-m</command> option
specifies the merge methodology that should be used when
a non-binary file is updated.  <command>MERGE</command> means the usual
cvsnt behavior: try to merge the files.  <command>COPY</command>
means that <command>cvs update</command> will refuse to merge
files, as it also does for files specified as binary
with <command>-kb</command> (but if the file is specified as
binary, there is no need to specify <command>-m 'COPY'</command>).
cvsnt will provide the user with the
two versions of the files, and require the user using
mechanisms outside cvsnt, to insert any necessary
changes.  <emphasis>WARNING</emphasis>: do not use <command>COPY</command> with
cvsnt 1.9 or earlier-such versions of cvsnt will
copy one version of your file over the other, wiping
out the previous contents.
The <command>-m</command> wrapper option only affects behavior when
merging is done on update; it does not affect how files
are stored.  See <xref linkend="Binary-files" />, for more on
binary files.
   </para>

   <para>
The basic format of the file <command>cvswrappers</command> is:
   </para>

   <para><screen>wildcard     [option value][option value]...

where option is one of
-m           update methodology      value: MERGE or COPY
-k           keyword expansion       value: expansion mode

and value is a single-quote delimited value.
</screen>   </para>
   <para>
For example, the following command imports a
directory, treating files whose name ends in
<command>.exe</command> as binary:
   </para>
   <para><screen>
cvs import -I ! -W "*.exe -k 'b'" first-dir vendortag reltag
</screen>      </para>
</sect1>
  <sect1 id="commit-files">
   <title>The commit support files
</title>
   <para><indexterm role="cp"><primary>Commit files</primary></indexterm>
The <command>-i</command> flag in the <command>modules</command> file can be
used to run a certain program whenever files are
committed (<xref linkend="modules" />).  The files described in
this section provide other, more flexible, ways to run
programs whenever something is committed.
   </para>

   <para>
There are three kind of programs that can be run on
commit.  They are specified in files in the repository,
as described below.  The following table summarizes the
file names and the purpose of the corresponding
programs.
   </para>

   <variablelist>
    <varlistentry>
     <term><command>commitinfo</command></term>
     <listitem>
      <para>
The program is responsible for checking that the commit
is allowed.  If it exits with a non-zero exit status
the commit will be aborted.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>verifymsg</command></term>
     <listitem>
      <para>
The specified program is used to evaluate the log message,
and possibly verify that it contains all required
fields.  This is most useful in combination with the
<command>rcsinfo</command> file, which can hold a log message
template (<xref linkend="rcsinfo" />).
      </para>

      <para>
The verifymsg script may or may be able to change the
log message depending on the value of the RereadLogAfterVerify
setting in the <command>config</command> file.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>editinfo</command></term>
     <listitem>
      <para>
The specified program is used to edit the log message,
and possibly verify that it contains all required
fields.  This is most useful in combination with the
<command>rcsinfo</command> file, which can hold a log message
template (<xref linkend="rcsinfo" />).  (obsolete)
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>loginfo</command></term>
     <listitem>
      <para>
The specified program is called when the commit is
complete.  It receives the log message and some
additional information and can store the log message in
a file, or mail it to appropriate persons, or maybe
post it to a local newsgroup, or&hellip;  Your
imagination is the limit!
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>postcommit</command></term>
     <listitem>
      <para>
The specified program is called when the commit is complete,
and all locks have been released from the repository prior
to returning to the user.  This is useful to maintain checked-out
copies of repositories and to perform cvs actions after a commit.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>historyinfo</command></term>
     <listitem>
      <para>
This is called when any action which causes an entry in the history
file is initiated.  Its standard input receives the line to be written to the history log,
in a semi-compressed format.
      </para></listitem></varlistentry></variablelist>


   <sect2 id="syntax">
    <title>The common syntax
</title>
    <para><indexterm role="cp"><primary>Info files (syntax)</primary></indexterm><indexterm role="cp"><primary>Syntax of info files</primary></indexterm><indexterm role="cp"><primary>Common syntax of info files</primary></indexterm>
    </para>

    <para>
The administrative files such as <command>commitinfo</command>,
<command>loginfo</command>, <command>rcsinfo</command>, <command>verifymsg</command>, etc.,
all have a common format.  The purpose of the files are
described later on.  The common syntax is described
here.
    </para>

    <para><indexterm role="cp"><primary>Regular expression syntax</primary></indexterm>Each line contains the following:
    </para>
    <itemizedlist mark="bullet">
     <listitem>
      <para>
A regular expression.  This is a basic regular
expression in the syntax used by GNU emacs.
      </para>
</listitem>
     <listitem>
      <para>
A whitespace separator--one or more spaces and/or tabs.
      </para>
</listitem>
     <listitem>
      <para>
A file name or command-line template.
      </para></listitem></itemizedlist>

    <para>
Blank lines are ignored.  Lines that start with the
character <command>#</command> are treated as comments.  Long lines
unfortunately can <emphasis>not</emphasis> be broken in two parts in
any way.
    </para>

    <para>
The first regular expression that matches the current
directory name in the repository is used.  The rest of the line
is used as a file name or command-line as appropriate.
    </para>

</sect2></sect1>
  <sect1 id="commitinfo">
   <title>Commitinfo
</title>
   <para><indexterm role="cp"><primary>Commitinfo</primary></indexterm><indexterm role="cp"><primary>Checking commits</primary></indexterm><indexterm role="cp"><primary>Precommit checking</primary></indexterm>
The <command>commitinfo</command> file defines programs to execute
whenever <command>cvs commit</command> is about to execute.  These
programs are used for pre-commit checking to verify
that the modified, added and removed files are really
ready to be committed.  This could be used, for
instance, to verify that the changed files conform to
to your site's standards for coding practice.
   </para>

   <para>
As mentioned earlier, each line in the
<command>commitinfo</command> file consists of a regular expression
and a command-line template.  The template can include
a program name and any number of arguments you wish to
supply to it.  The full path to the current source
repository is appended to the template, followed by the
file names of any files involved in the commit (added,
removed, and modified files).
   </para>

   <para><indexterm role="cp"><primary>Exit status, of commitinfo</primary></indexterm>The first line with a regular expression matching the
directory within the repository will be used.  If the
command returns a non-zero exit status the commit will
be aborted.
   </para>

   <para><indexterm role="cp"><primary>DEFAULT in commitinfo</primary></indexterm>If the repository name does not match any of the
regular expressions in this file, the <command>DEFAULT</command>
line is used, if it is specified.
   </para>

   <para><indexterm role="cp"><primary>ALL in commitinfo</primary></indexterm>All occurrences of the name <command>ALL</command> appearing as a
regular expression are used in addition to the first
matching regular expression or the name <command>DEFAULT</command>.
   </para>

   <para>
Note: when cvsnt is accessing a remote repository,
<command>commitinfo</command> will be run on the <emphasis>remote</emphasis>
(i.e., server) side, not the client side (<xref linkend="Remote-repositories" />).
   </para>



</sect1>
  <sect1 id="postcommit">
   <title>Postcommit
</title>
   <para><indexterm role="cp"><primary>Postcommit</primary></indexterm><indexterm role="cp"><primary>Postcommit actions</primary></indexterm>
After commit has completed, the actions in this file are executed
so that you can perform operations on the repository before returning.
   </para>

   <para>
Typical uses of this would be to keep a checked-out copy of a repository.
   </para>
   <para>
Note: See CvsChapter180 on the wiki.  Needs transcribing into docbook format.
</para>

</sect1>
  <sect1 id="verifymsg">
   <title>Verifying log messages
</title>
   <para><indexterm role="cp"><primary>verifymsg (admin file)</primary></indexterm><indexterm role="cp"><primary>Log message, verifying</primary></indexterm>
Once you have entered a log message, you can evaluate
that message to check for specific content, such as
a bug ID.  Use the <command>verifymsg</command> file to
specify a program that is used to verify the log message.
This program could be a simple script that checks
that the entered message contains the required fields.
   </para>

   <para>
The <command>verifymsg</command> file is often most useful together
with the <command>rcsinfo</command> file, which can be used to
specify a log message template.
   </para>

   <para>
Each line in the <command>verifymsg</command> file consists of a
regular expression and a command-line template.  The
template must include a program name, and can include
any number of arguments.  The full path to the current
log message template file is appended to the template.
   </para>

   <para>
One thing that should be noted is that the <command>ALL</command>
keyword is not supported.  If more than one matching
line is found, the first one is used.  This can be
useful for specifying a default verification script in a
directory, and then overriding it in a subdirectory.
   </para>

   <para><indexterm role="cp"><primary>DEFAULT in verifymsg</primary></indexterm>If the repository name does not match any of the
regular expressions in this file, the <command>DEFAULT</command>
line is used, if it is specified.
   </para>

   <para><indexterm role="cp"><primary>Exit status, of verifymsg</primary></indexterm>If the verification script exits with a non-zero exit status,
the commit is aborted.
   </para>

   <para>
Note that the verification script cannot change the log
message; it can merely accept it or reject it.
   </para>

   <para>
The following is a little silly example of a
<command>verifymsg</command> file, together with the corresponding
<command>rcsinfo</command> file, the log message template and an
verification  script.  We begin with the log message template.
We want to always record a bug-id number on the first
line of the log message.  The rest of log message is
free text.  The following template is found in the file
<command>/usr/cvssupport/tc.template</command>.
   </para>

   <para><screen>BugId:
</screen>   </para>
   <para>
The script <command>/usr/cvssupport/bugid.verify</command> is used to
evaluate the log message.
   </para>
   <para><screen>
#!/bin/sh
#
#       bugid.verify filename
#
#  Verify that the log message contains a valid bugid
#  on the first line.
#
if head -1 &lt; $1 | grep '^BugId:[ ]*[0-9][0-9]*$' &gt; /dev/null; then
    exit 0
else
    echo "No BugId found."
    exit 1
fi
</screen>      </para>
   <para>
The <command>verifymsg</command> file contains this line:
   </para>
   <para><screen>
^tc     /usr/cvssupport/bugid.verify
</screen>      </para>
   <para>
The <command>rcsinfo</command> file contains this line:
   </para>
   <para><screen>
^tc     /usr/cvssupport/tc.template
</screen>      </para>
</sect1>
  <sect1 id="editinfo">
   <title>Editinfo
</title>
   <para><indexterm role="cp"><primary>editinfo (admin file)</primary></indexterm><indexterm role="cp"><primary>Editor, specifying per module</primary></indexterm><indexterm role="cp"><primary>Per-module editor</primary></indexterm><indexterm role="cp"><primary>Log messages, editing</primary></indexterm>
<emphasis>NOTE:</emphasis> The <command>editinfo</command> feature has been
rendered obsolete.  To set a default editor for log
messages use the <command>EDITOR</command> environment variable
(<xref linkend="Environment-variables" />) or the <command>-e</command> global
option (<xref linkend="Global-options" />).  See <xref linkend="verifymsg" />,
for information on the use of the <command>verifymsg</command>
feature for evaluating log messages.
   </para>

   <para>
If you want to make sure that all log messages look the
same way, you can use the <command>editinfo</command> file to
specify a program that is used to edit the log message.
This program could be a custom-made editor that always
enforces a certain style of the log message, or maybe a
simple shell script that calls an editor, and checks
that the entered message contains the required fields.
   </para>

   <para>
If no matching line is found in the <command>editinfo</command>
file, the editor specified in the environment variable
<command>$CVSEDITOR</command> is used instead.  If that variable is
not set, then the environment variable <command>$EDITOR</command>
is used instead.  If that variable is not
set a default will be used.  See <xref linkend="Committing-your-changes" />.
   </para>

   <para>
The <command>editinfo</command> file is often most useful together
with the <command>rcsinfo</command> file, which can be used to
specify a log message template.
   </para>

   <para>
Each line in the <command>editinfo</command> file consists of a
regular expression and a command-line template.  The
template must include a program name, and can include
any number of arguments.  The full path to the current
log message template file is appended to the template.
   </para>

   <para>
One thing that should be noted is that the <command>ALL</command>
keyword is not supported.  If more than one matching
line is found, the first one is used.  This can be
useful for specifying a default edit script in a
module, and then overriding it in a subdirectory.
   </para>

   <para><indexterm role="cp"><primary>DEFAULT in editinfo</primary></indexterm>If the repository name does not match any of the
regular expressions in this file, the <command>DEFAULT</command>
line is used, if it is specified.
   </para>

   <para>
If the edit script exits with a non-zero exit status,
the commit is aborted.
   </para>

   <para>
Note: when cvsnt is accessing a remote repository,
or when the <command>-m</command> or <command>-F</command> options to <command>cvs
commit</command> are used, <command>editinfo</command> will not be consulted.
There is no good workaround for this; use
<command>verifymsg</command> instead.
   </para>

   <sect2 id="editinfo-example">
    <title>Editinfo example
</title>

    <para>
The following is a little silly example of a
<command>editinfo</command> file, together with the corresponding
<command>rcsinfo</command> file, the log message template and an
editor script.  We begin with the log message template.
We want to always record a bug-id number on the first
line of the log message.  The rest of log message is
free text.  The following template is found in the file
<command>/usr/cvssupport/tc.template</command>.
    </para>

    <para><screen>BugId:
</screen>    </para>
    <para>
The script <command>/usr/cvssupport/bugid.edit</command> is used to
edit the log message.
    </para>
    <para><screen>
#!/bin/sh
#
#       bugid.edit filename
#
#  Call $EDITOR on FILENAME, and verify that the
#  resulting file contains a valid bugid on the first
#  line.
if [ "x$EDITOR" = "x" ]; then EDITOR=vi; fi
if [ "x$CVSEDITOR" = "x" ]; then CVSEDITOR=$EDITOR; fi
$CVSEDITOR $1
until head -1|grep '^BugId:[ ]*[0-9][0-9]*$' &lt; $1
do  echo -n  "No BugId found.  Edit again? ([y]/n)"
    read ans
    case ${ans} in
        n*) exit 1;;
    esac
    $CVSEDITOR $1
done
</screen>       </para>
    <para>
The <command>editinfo</command> file contains this line:
    </para>
    <para><screen>
^tc     /usr/cvssupport/bugid.edit
</screen>       </para>
    <para>
The <command>rcsinfo</command> file contains this line:
    </para>
    <para><screen>
^tc     /usr/cvssupport/tc.template
</screen>       </para>
</sect2></sect1>
  <sect1 id="loginfo">
   <title>Loginfo
</title>
   <para><indexterm role="cp"><primary>loginfo (admin file)</primary></indexterm><indexterm role="cp"><primary>Storing log messages</primary></indexterm><indexterm role="cp"><primary>Mailing log messages</primary></indexterm><indexterm role="cp"><primary>Distributing log messages</primary></indexterm><indexterm role="cp"><primary>Log messages</primary></indexterm>
The <command>loginfo</command> file is used to control where
<command>cvs commit</command> log information is sent.  The first
entry on a line is a regular expression which is tested
against the directory that the change is being made to,
relative to the <command>$CVSROOT</command>.  If a match is found, then
the remainder of the line is a filter program that
should expect log information on its standard input.
   </para>

   <para>
If the repository name does not match any of the
regular expressions in this file, the <command>DEFAULT</command>
line is used, if it is specified.
   </para>

   <para>
All occurrences of the name <command>ALL</command> appearing as a
regular expression are used in addition to the first
matching regular expression or <command>DEFAULT</command>.
   </para>

   <para>
The first matching regular expression is used.
   </para>

   <para><xref linkend="commit-files" />, for a description of the syntax of
the <command>loginfo</command> file.
   </para>

   <para>
The user may specify a format string as
part of the filter.  The string is composed of a
<command>%</command> followed by a space, or followed by a single
format character, or followed by a set of format
characters surrounded by <command>{</command> and <command>}</command> as
separators.  The format characters are:
   </para>

   <variablelist>
    <varlistentry>
     <term><wordasword>s</wordasword></term>
     <listitem>
      <para>
file name
      </para></listitem></varlistentry>
    <varlistentry>
     <term><wordasword>V</wordasword></term>
     <listitem>
      <para>
old version number (pre-checkin)
      </para></listitem></varlistentry>
    <varlistentry>
     <term><wordasword>v</wordasword></term>
     <listitem>
      <para>
new version number (post-checkin)
      </para></listitem></varlistentry></variablelist>
   <para>
All other characters that appear in a format string
expand to an empty field (commas separating fields are
still provided).
   </para>
   <para>
For example, some valid format strings are <command>%</command>,
<command>%s</command>, <command>%{s}</command>, and <command>%{sVv}</command>.
   </para>
   <para>
The output will be a string of tokens separated by
spaces.  For backwards compatibility, the first
token will be the repository subdirectory.  The rest of the
tokens will be comma-delimited lists of the information
requested in the format string.  For example, if
<command>/u/src/master/yoyodyne/tc</command> is the repository, <command>%{sVv}</command>
is the format string, and three files (<wordasword>ChangeLog</wordasword>,
<wordasword>Makefile</wordasword>, <wordasword>foo.c</wordasword>) were modified, the output
might be:
   </para>
   <para><screen>
yoyodyne/tc ChangeLog,1.1,1.2 Makefile,1.3,1.4 foo.c,1.12,1.13
</screen>      </para>
   <para>
As another example, <command>%{}</command> means that only the
name of the repository will be generated.
   </para>
   <para>
Note: when cvsnt is accessing a remote repository,
<command>loginfo</command> will be run on the <emphasis>remote</emphasis>
(i.e., server) side, not the client side (<xref linkend="Remote-repositories" />).
   </para>


   <sect2 id="loginfo-example">
    <title>Loginfo example
</title>

    <para>
The following <command>loginfo</command> file, together with the
tiny shell-script below, appends all log messages
to the file <command>$CVSROOT/CVSROOT/commitlog</command>,
and any commits to the administrative files (inside
the <command>CVSROOT</command> directory) are also logged in
<command>/usr/adm/cvsroot-log</command>.
Commits to the <command>prog1</command> directory are mailed to <wordasword>ceder</wordasword>.
    </para>

    <para><screen>ALL             /usr/local/bin/cvs-log $CVSROOT/CVSROOT/commitlog $USER
^CVSROOT        /usr/local/bin/cvs-log /usr/adm/cvsroot-log
^prog1          Mail -s %s ceder
</screen>    </para>
    <para>
The shell-script <command>/usr/local/bin/cvs-log</command> looks
like this:
    </para>
    <para><screen>
#!/bin/sh
(echo "------------------------------------------------------";
 echo -n $2"  ";
 date;
 echo;
 cat) &gt;&gt; $1
</screen>       </para>
</sect2>
   <sect2 id="Keeping-a-checked-out-copy">
    <title>Keeping a checked out copy
</title>

    <para><indexterm role="cp"><primary>Keeping a checked out copy</primary></indexterm><indexterm role="cp"><primary>Checked out copy, keeping</primary></indexterm><indexterm role="cp"><primary>Web pages, maintaining with CVS</primary></indexterm>
It is often useful to maintain a directory tree which
contains files which correspond to the latest version
in the repository.  For example, other developers might
want to refer to the latest sources without having to
check them out, or you might be maintaining a web site
with cvsnt and want every checkin to cause the files
used by the web server to be updated.
    </para>

    <para>
The way to do this is by having postcommit invoke
<command>cvs update</command>. 
Here is an example for unix (this should all be on one line):
    </para>

    <para><screen>^cyclic-pages		(date; cat; (sleep 2; cd /u/www/local-docs;
 cvs -q update -d) &amp;) &gt;&gt; $CVSROOT/CVSROOT/updatelog 2&gt;&amp;1
</screen>    </para>
    <para>
This will cause checkins to repository directories
starting with <command>cyclic-pages</command> to update the checked
out tree in <command>/u/www/local-docs</command>.
    </para>
</sect2></sect1>
  <sect1 id="rcsinfo">
   <title>rcsinfo
</title>
   <para><indexterm role="cp"><primary>rcsinfo (admin file)</primary></indexterm><indexterm role="cp"><primary>Form for log message</primary></indexterm><indexterm role="cp"><primary>Log message template</primary></indexterm><indexterm role="cp"><primary>Template for log message</primary></indexterm>
The <command>rcsinfo</command> file can be used to specify a form to
edit when filling out the commit log.  The
<command>rcsinfo</command> file has a syntax similar to the
<command>verifymsg</command>, <command>commitinfo</command> and <command>loginfo</command>
files.  <xref linkend="syntax" />.  Unlike the other files the second
part is <emphasis>not</emphasis> a command-line template.  Instead,
the part after the regular expression should be a full pathname to
a file containing the log message template.
   </para>

   <para>
If the repository name does not match any of the
regular expressions in this file, the <command>DEFAULT</command>
line is used, if it is specified.
   </para>

   <para>
All occurrences of the name <command>ALL</command> appearing as a
regular expression are used in addition to the first
matching regular expression or <command>DEFAULT</command>.
   </para>

   <para>
The log message template will be used as a default log
message.  If you specify a log message with <command>cvs
commit -m <varname>message</varname></command> or <command>cvs commit -f
<varname>file</varname></command> that log message will override the
template.
   </para>

   <para><xref linkend="verifymsg" />, for an example <command>rcsinfo</command>
file.
   </para>

   <para>
When cvsnt is accessing a remote repository,
the contents of <command>rcsinfo</command> at the time a directory
is first checked out will specify a template which does
not then change.  If you edit <command>rcsinfo</command> or its
templates, you may need to check out a new working
directory.
   </para>

</sect1>
  <sect1 id="historyinfo">
   <title>Advanced history logging
</title>
   <para><indexterm role="cp"><primary>historyinfo</primary></indexterm>
Each time an action is performed on the repository that generates a line
in the history file, scripts <command>historyinfo</command> are executed so that
you can perform advanced logging, for example to a separate machine.
   </para>

   <para>
The script is passed a line of history via its standard input in the
following format:
   </para>

   <para><screen>Action|Date|Repository|Directory|Version|File
</screen>   </para>
</sect1>
  <sect1 id="cvsignore">
   <title>Ignoring files via cvsignore
</title>
   <para><indexterm role="cp"><primary>cvsignore (admin file), global</primary></indexterm><indexterm role="cp"><primary>Global cvsignore</primary></indexterm><indexterm role="cp"><primary>Ignoring files</primary></indexterm>
There are certain file names that frequently occur
inside your working copy, but that you don't want to
put under cvsnt control.  Examples are all the object
files that you get while you compile your sources.
Normally, when you run <command>cvs update</command>, it prints a
line for each file it encounters that it doesn't know
about (<xref linkend="update-output" />).
   </para>

   <para>
cvsnt has a list of files (or sh(1) file name patterns)
that it should ignore while running <command>update</command>,
<command>import</command> and <command>release</command>.
This list is constructed in the following way.
   </para>

   <itemizedlist mark="bullet">
    <listitem>
     <para>
The list is initialized to include certain file name
patterns: names associated with cvsnt
administration, or with other common source control
systems; common names for patch files, object files,
archive files, and editor backup files; and other names
that are usually artifacts of assorted utilities.
Currently, the default list of ignored file name
patterns is:
     </para>

     <para><indexterm role="cp"><primary>Ignored files</primary></indexterm><indexterm role="cp"><primary>Automatically ignored files</primary></indexterm><screen>    rcs     SCCS    CVS     CVS.adm
    rcsLOG  cvslog.*
    tags    TAGS
    .make.state     .nse_depinfo
    *~      #*      .#*     ,*      _$*     *$
    *.old   *.bak   *.BAK   *.orig  *.rej   .del-*
    *.a     *.olb   *.o     *.obj   *.so    *.exe
    *.Z     *.elc   *.ln
    core
</screen>          </para>
</listitem>
    <listitem>
     <para>
The per-repository list in
<command>$CVSROOT/CVSROOT/cvsignore</command> is appended to
the list, if that file exists.
     </para>
</listitem>
    <listitem>
     <para>
The per-user list in <command>.cvsignore</command> in your home
directory is appended to the list, if it exists.
     </para>
</listitem>
    <listitem>
     <para>
Any entries in the environment variable
<command>$CVSIGNORE</command> is appended to the list.
     </para>
</listitem>
    <listitem>
     <para>
Any <command>-I</command> options given to cvsnt is appended.
     </para>
</listitem>
    <listitem>
     <para>
As cvsnt traverses through your directories, the contents
of any <command>.cvsignore</command> will be appended to the list.
The patterns found in <command>.cvsignore</command> are only valid
for the directory that contains them, not for
any sub-directories.
     </para></listitem></itemizedlist>

   <para>
In any of the 5 places listed above, a single
exclamation mark (<command>!</command>) clears the ignore list.
This can be used if you want to store any file which
normally is ignored by cvsnt.
   </para>

   <para>
Specifying <command>-I !</command> to <command>cvs import</command> will import
everything, which is generally what you want to do if
you are importing files from a pristine distribution or
any other source which is known to not contain any
extraneous files.  However, looking at the rules above
you will see there is a fly in the ointment; if the
distribution contains any <command>.cvsignore</command> files, then
the patterns from those files will be processed even if
<command>-I !</command> is specified.  The only workaround is to
remove the <command>.cvsignore</command> files in order to do the
import.  Because this is awkward, in the future
<command>-I !</command> might be modified to override
<command>.cvsignore</command> files in each directory.
   </para>

   <para>
Note that the syntax of the ignore files consists of a
series of lines, each of which contains a space
separated list of filenames.  This offers no clean way
to specify filenames which contain spaces, but you can
use a workaround like <command>foo?bar</command> to match a file
named <command>foo bar</command> (it also matches <command>fooxbar</command>
and the like).  Also note that there is currently no
way to specify comments.
   </para>

</sect1>
  <sect1 id="checkoutlist">
   <title>The checkoutlist file
</title>
   <para><indexterm role="cp"><primary>checkoutlist</primary></indexterm>
It may be helpful to use cvsnt to maintain your own
files in the <command>CVSROOT</command> directory.  For example,
suppose that you have a script <command>logcommit.pl</command>
which you run by including the following line in the
<command>commitinfo</command> administrative file:
   </para>

   <para><screen>ALL   $CVSROOT/CVSROOT/logcommit.pl
</screen>   </para>
   <para>
To maintain <command>logcommit.pl</command> with cvsnt you would
add the following line to the <command>checkoutlist</command>
administrative file:
   </para>
   <para><screen>
logcommit.pl
</screen>      </para>
   <para>
The format of <command>checkoutlist</command> is one line for each
file that you want to maintain using cvsnt, giving
the name of the file.
   </para>
   <para>
After setting up <command>checkoutlist</command> in this fashion,
the files listed there will function just like
cvsnt's built-in administrative files.  For example,
when checking in one of the files you should get a
message such as:
   </para>
   <para><screen>
cvs commit: Rebuilding administrative file database
</screen>      </para>
   <para>
and the checked out copy in the <command>CVSROOT</command>
directory should be updated.
   </para>
   <para>
Note that listing <command>passwd</command> (<xref linkend="Authentication-server" />) in <command>checkoutlist</command> is not
recommended for security reasons.
   </para>
   <para>
For information about keeping a checkout out copy in a
more general context than the one provided by
<command>checkoutlist</command>, see <xref linkend="Keeping-a-checked-out-copy" />.
   </para>
</sect1>
  <sect1 id="history-file">
   <title>The history file
</title>
   <para><indexterm role="cp"><primary>History file</primary></indexterm><indexterm role="cp"><primary>Log information, saving</primary></indexterm>
The file <command>$CVSROOT/CVSROOT/history</command> is used
to log information for the <command>history</command> command
(<xref linkend="history" />).  This file must be created to turn
on logging.  This is done automatically if the
<command>cvs init</command> command is used to set up the
repository (<xref linkend="Creating-a-repository" />).
   </para>

   <para>
The file format of the <command>history</command> file is
documented only in comments in the cvsnt source
code, but generally programs should use the <command>cvs
history</command> command to access it anyway, in case the
format changes with future releases of cvsnt.
   </para>

</sect1>
  <sect1 id="Variables">
   <title>Expansions in administrative files
</title>
   <para><indexterm role="cp"><primary>Internal variables</primary></indexterm><indexterm role="cp"><primary>Variables</primary></indexterm>
Sometimes in writing an administrative file, you might
want the file to be able to know various things based
on environment cvsnt is running in.  There are
several mechanisms to do that.
   </para>

   <para>
To find the home directory of the user running cvsnt
(from the <command>HOME</command> environment variable), use
<command>~</command> followed by <command>/</command> or the end of the line.
Likewise for the home directory of <varname>user</varname>, use
<command>~<varname>user</varname></command>.  These variables are expanded on
the server machine, and don't get any reasonable
expansion if pserver (<xref linkend="Password-authenticated" />)
is in use; therefore user variables (see below) may be
a better choice to customize behavior based on the user
running cvsnt.
   </para>

   <para>
One may want to know about various pieces of
information internal to cvsnt.  A cvsnt internal
variable has the syntax <command>${<varname>variable</varname>}</command>,
where <varname>variable</varname> starts with a letter and consists
of alphanumeric characters and <command>_</command>.  If the
character following <varname>variable</varname> is a
non-alphanumeric character other than <command>_</command>, the
<command>{</command> and <command>}</command> can be omitted.  The cvsnt
internal variables are:
   </para>

   <variablelist>
    <varlistentry>
     <term><command>CVSROOT</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>CVSROOT, internal variable</primary></indexterm>This is the value of the cvsnt root in use.
<xref linkend="Repository" />, for a description of the various
ways to specify this.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>rcsBIN</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>RCSBIN, internal variable</primary></indexterm>In CVS 1.9.18 and older, this specified the
directory where cvsnt was looking for rcs
programs.  Because cvsnt no longer runs rcs
programs, specifying this internal variable is now an
error.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>CVSEDITOR</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>CVSEDITOR, internal variable</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>VISUAL</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>VISUAL, internal variable</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>EDITOR</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>EDITOR, internal variable</primary></indexterm>These all expand to the same value, which is the editor
that cvsnt is using.  <xref linkend="Global-options" />, for how
to specify this.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>USER</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>USER, internal variable</primary></indexterm>Username of the user running cvsnt (on the cvsnt
server machine).
When using pserver, this is the user specified in the repository
specification which need not be the same as the username the
server is running as (<xref linkend="Authentication-server" />).
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>CVSPID</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>CVSPID, internal variable</primary></indexterm>Parent process ID of the cvsnt process.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>SESSIONID</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>SESSIONID, internal variable</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>COMMITID</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>COMMITID, internal variable</primary></indexterm>Unique Session ID of cvsnt process.  This is a random string of printable characters
that may be up to 256 characters long.
      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>PREFIX</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>PREFIX, internal variable</primary></indexterm>
Repository prefix, if any, currently active on the server.
      </para></listitem></varlistentry></variablelist>
   <para>
If you want to pass a value to the administrative files
which the user who is running cvsnt can specify,
use a user variable.
<indexterm role="cp"><primary>User variables</primary></indexterm>To expand a user variable, the
administrative file contains
<command>${=<varname>variable</varname>}</command>.  To set a user variable,
specify the global option <command>-s</command> to cvsnt, with
argument <command><varname>variable</varname>=<varname>value</varname></command>.  It may be
particularly useful to specify this option via
<command>.cvsrc</command> (<xref linkend="cvsrc" />).
   </para>
   <para>
For example, if you want the administrative file to
refer to a test directory you might create a user
variable <command>TESTDIR</command>.  Then if cvsnt is invoked
as
   </para>
   <para><screen>
cvs -s TESTDIR=/work/local/tests
</screen>      </para>

   <para>
and the
administrative file contains <command>sh
${=TESTDIR}/runtests</command>, then that string is expanded
to <command>sh /work/local/tests/runtests</command>.
   </para>

   <para>
All other strings containing <command>$</command> are reserved;
there is no way to quote a <command>$</command> character so that
<command>$</command> represents itself.
   </para>

   <para>
Environment variables passed to administrative files are:
   </para>

   <variablelist>
    <title><indexterm role="cp"><primary>environment variables, passed to administrative files</primary></indexterm>
</title>
    <varlistentry>
     <term><command>CVS_USER</command></term>
     <listitem>
      <para>
The cvsnt-specific username provided by the user, if it
can be provided (currently just for the pserver access
method), and to the empty string otherwise.  (CVS_USER
and USER may differ when <command>$CVSROOT/CVSROOT/passwd</command>
is used to map cvs usernames to system usernames.)
      </para></listitem></varlistentry></variablelist>
</sect1>
  <sect1 id="config">
   <title>The CVSROOT/config configuration file
</title>

   <para><indexterm role="cp"><primary>config, in CVSROOT</primary></indexterm><indexterm role="cp"><primary>CVSROOT/config</primary></indexterm>
The administrative file <command>config</command> contains various
miscellaneous settings which affect the behavior of
cvsnt.  The syntax is slightly different from the
other administrative files.  Variables are not
expanded.  Lines which start with <command>#</command> are
considered comments.
Other lines consist of a keyword, <command>=</command>, and a
value.  Note that this syntax is very strict.
Extraneous spaces or tabs are not permitted.
   </para>

   <para>
Currently defined keywords are:
   </para>

   <variablelist>
    <title><indexterm role="cp"><primary>rcsBIN, in CVSROOT/config</primary></indexterm></title>
    <varlistentry>
     <term><command>rcsBIN=<varname>bindir</varname></command></term>
     <listitem>
      <para>
For CVS 1.9.12 through 1.9.18, this setting told
cvsnt to look for rcs programs in the
<varname>bindir</varname> directory.  Current versions of cvsnt
do not run rcs programs; for compatibility this
setting is accepted, but it does nothing.
      </para>

      <para><indexterm role="cp"><primary>SystemAuth, in CVSROOT/config</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>SystemAuth=<varname>value</varname></command></term>
     <listitem>
      <para>
If <varname>value</varname> is <command>yes</command>, then pserver should check
for users in the system's user database if not found in
<command>CVSROOT/passwd</command>.  If it is <command>no</command>, then all
pserver users must exist in <command>CVSROOT/passwd</command>.
The default is <command>yes</command>.  For more on pserver, see
<xref linkend="Password-authenticated" />.
      </para>


      <para><indexterm role="cp"><primary>TopLevelAdmin, in CVSROOT/config</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>TopLevelAdmin=<varname>value</varname></command></term>
     <listitem>
      <para>
Modify the <command>checkout</command> command to create a
<command>CVS</command> directory at the top level of the new
working directory, in addition to <command>CVS</command>
directories created within checked-out directories.
The default value is <command>no</command>.
      </para>

      <para>
This option is useful if you find yourself performing
many commands at the top level of your working
directory, rather than in one of the checked out
subdirectories.  The <command>CVS</command> directory created there
will mean you don't have to specify <command>CVSROOT</command> for
each command.  It also provides a place for the
<command>CVS/Template</command> file (<xref linkend="Working-directory-storage" />).
      </para>

      <para><indexterm role="cp"><primary>LockDir, in CVSROOT/config</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>LockDir=<varname>directory</varname></command></term>
     <listitem>
      <para>
<command>Depreciated.</command>  Put cvsnt lock files in <varname>directory</varname> rather than
directly in the repository.  This is useful if you want
to let users read from the repository while giving them
write access only to <varname>directory</varname>, not to the
repository.  You need to create <varname>directory</varname>, but
cvsnt will create subdirectories of <varname>directory</varname> as it
needs them.  For information on cvsnt locks, see
<xref linkend="Concurrency" />.
      </para>

      <para>
Before enabling the LockDir option, make sure that you
have tracked down and removed any copies of cvsnt 1.9 or
older.  Such versions neither support LockDir, nor will
give an error indicating that they don't support it.
The result, if this is allowed to happen, is that some
cvsnt users will put the locks one place, and others will
put them another place, and therefore the repository
could become corrupted.  CVS 1.10 does not support
LockDir but it will print a warning if run on a
repository with LockDir enabled.
      </para>

      <para><indexterm role="cp"><primary>LockServer, in CVSROOT/config</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>LockServer=<varname>hostname</varname>[:port]</command></term>
     <listitem>
      <para>
Uses the cvsnt lock server to handle locking rather
than using files in the repository.  This is useful if you want
to let users read from the repository while giving them
write access only to <varname>directory</varname>, not to the
repository.  For information on cvsnt locks, see
<xref linkend="Concurrency" />.  cvsnt 2.0.15 and above use the LockServer
by default and other methods of locking are depreciated.  You can override this
behaviour by using the line <command>LockServer=none</command>.  Note however that future
versions may not allow this override.  See also <xref linkend="Lockserver" />
      </para>

      <para>
Before enabling the LockServer option, make sure that you
have tracked down and removed any copies of cvsnt 1.9 or
older.  Such versions neither support LockServer, nor will
give an error indicating that they don't support it.
The result, if this is allowed to happen, is that some
cvsnt users will put the locks one place, and others will
put them another place, and therefore the repository
could become corrupted.  CVS 1.10 does not support
LockServer but it will print a warning if run on a
repository with LockServer enabled.
      </para>

      <para><indexterm role="cp"><primary>LogHistory, in CVSROOT/config</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>LogHistory=<varname>value</varname></command></term>
     <listitem>
      <para>
Control what is logged to the <command>CVSROOT/history</command> file.
Default of <command>TOFEWGCMAR</command> (or simply <command>all</command>) will log
all transactions.  Any subset of the default is
legal.  (For example, to only log transactions that modify the
<command>*,v</command> files, use <command>LogHistory=TMAR</command>.)
      </para>

      <para><indexterm role="cp"><primary>RereadLogAfterVerify, in CVSROOT/config</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>RereadLogAfterVerify=<varname>value</varname></command></term>
     <listitem>
      <para>
If enabled the log message parsed by <command>verifymsg</command> is reread after the script
has run.  The default behavoiur is to not reread this file.
      </para></listitem></varlistentry></variablelist>
</sect1></appendix>
 <appendix id="Environment-variables">
  <title>All environment variables which affect CVS
</title>
  <para><indexterm role="cp"><primary>Environment variables</primary></indexterm><indexterm role="cp"><primary>Reference manual for variables</primary></indexterm>
This is a complete list of all environment variables
that affect cvsnt.
  </para>

  <variablelist>
   <title><indexterm role="cp"><primary>CVSIGNORE, environment variable</primary></indexterm></title>
   <varlistentry>
    <term><command>$CVSIGNORE</command></term>
    <listitem>
     <para>
A whitespace-separated list of file name patterns that
cvsnt should ignore. <xref linkend="cvsignore" />.
     </para>

     <para><indexterm role="cp"><primary>CVSWRAPPERS, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$CVSWRAPPERS</command></term>
    <listitem>
     <para>
A whitespace-separated list of file name patterns that
cvsnt should treat as wrappers. <xref linkend="Wrappers" />.
     </para>

     <para><indexterm role="cp"><primary>CVSREAD, environment variable</primary></indexterm><indexterm role="cp"><primary>Read-only files, and CVSREAD</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$CVSREAD</command></term>
    <listitem>
     <para>
If this is set, <command>checkout</command> and <command>update</command> will
try hard to make the files in your working directory
read-only.  When this is not set, the default behavior
is to permit modification of your working files.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>$CVSUMASK</command></term>
    <listitem>
     <para>
Controls permissions of files in the repository.  See
<xref linkend="File-permissions" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>$CVSROOT</command></term>
    <listitem>
     <para>
Should contain the full pathname to the root of the cvsnt
source repository (where the rcs files are
kept).  This information must be available to cvsnt for
most commands to execute; if <command>$CVSROOT</command> is not set,
or if you wish to override it for one invocation, you
can supply it on the command line: <command>cvs -d cvsroot
cvs_command&hellip;</command> Once you have checked out a working
directory, cvsnt stores the appropriate root (in
the file <command>CVS/Root</command>), so normally you only need to
worry about this when initially checking out a working
directory.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>$EDITOR</command></term>
    <term><command>$CVSEDITOR</command></term>
    <term><command>$VISUAL</command></term>
    <listitem>
     <para>
Specifies the program to use for recording log messages
during commit.  <command>$CVSEDITOR</command> overrides
<command>$EDITOR</command>.  See <xref linkend="Committing-your-changes" />.
     </para>

     <para><indexterm role="cp"><primary>PATH, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$PATH</command></term>
    <listitem>
     <para>
If <command>$rcsBIN</command> is not set, and no path is compiled
into cvsnt, it will use <command>$PATH</command> to try to find all
programs it uses.
     </para>

     <para><indexterm role="cp"><primary>HOME, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$HOME</command></term>
    <listitem>
     <para><indexterm role="cp"><primary>HOMEPATH, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$HOMEPATH</command></term>
    <listitem>
     <para><indexterm role="cp"><primary>HOMEDRIVE, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$HOMEDRIVE</command></term>
    <listitem>
     <para>
Used to locate the directory where the <command>.cvsrc</command>
file, and other such files, are searched.  On Unix, cvsnt
just checks for <command>HOME</command>.  On Windows NT, the system will
set <command>HOMEDRIVE</command>, for example to <command>d:</command> and <command>HOMEPATH</command>,
for example to <command>\joe</command>.  On Windows 95, you'll
probably need to set <command>HOMEDRIVE</command> and <command>HOMEPATH</command> yourself.
     </para>

     <para><indexterm role="cp"><primary>CVS_EXT, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$CVS_EXT</command></term>
    <listitem>
     <para><indexterm role="cp"><primary>CVS_RSH, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$CVS_RSH</command></term>
    <listitem>
     <para>
Specifies the external program which cvsnt connects with,
when <command>:ext:</command> access method is specified.
This replaces the <command>CVS_RSH</command> environment used in older implementations
of cvs.
     </para>

     <para>
The <command>CVS_EXT</command> variable parsed as a formatting string specifying the
command to pass to invoke the remote server.  The default string is: <command>ssh -l %u %h</command>
The <command>%u</command> parameter is replaced with the username specified in the CVSROOT (or
the current username if none is specified) and the <command>%h</command> parameter is replaced with the hostname
specified in the CVSROOT.
     </para>

     <para>
The CVS_EXT string has the string ' cvs server' appended to it, and this is then passed to
the command processor for execution.
     </para>

     <para><xref linkend="Connecting-via-ssh" />.
     </para>
</listitem></varlistentry>
   <varlistentry>
    <term><command>$CVS_PASSFILE</command></term>
    <listitem>
     <para>
Used in client-server mode when accessing the <command>cvs
login server</command>.  Default value is <command>$HOME/.cvspass</command>.
<xref linkend="Authentication-client" />     </para>

</listitem></varlistentry>
   <varlistentry>
    <term><command>$CVS_CLIENT_PORT</command></term>
    <listitem>
     <para>
Used in client-server mode when accessing the server
via Kerberos, GSSAPI, or cvsnt's password authentication if the port is not
specified in $CVSROOT.
<xref linkend="Remote-repositories" />     </para>


     <para><indexterm role="cp"><primary>CVS_CLIENT_LOG, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$CVS_CLIENT_LOG</command></term>
    <listitem>
     <para>
Used for debugging only in client-server
mode.  If set, everything sent to the server is logged
into <command><command>$CVS_CLIENT_LOG</command>.in</command> and everything
sent from the server is logged into
<command><command>$CVS_CLIENT_LOG</command>.out</command>.
     </para>

     <para><indexterm role="cp"><primary>CVS_SERVER_SLEEP, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$CVS_SERVER_SLEEP</command></term>
    <listitem>
     <para>
Used only for debugging the server side in
client-server mode.  If set, delays the start of the
server child process the specified amount of
seconds so that you can attach to it with a debugger.
     </para>

     <para><indexterm role="cp"><primary>COMSPEC, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$COMSPEC</command></term>
    <listitem>
     <para>
Used under DOS/Windows and OS/2 only.  It specifies the name of the
command interpreter and defaults to cmd.exe.
     </para>

     <para><indexterm role="cp"><primary>TMPDIR, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$TMPDIR</command></term>
    <listitem>
     <para><indexterm role="cp"><primary>TMP, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$TMP</command></term>
    <listitem>
     <para><indexterm role="cp"><primary>TEMP, environment variable</primary></indexterm>     </para></listitem></varlistentry>
   <varlistentry>
    <term><command>$TEMP</command></term>
    <listitem>
     <para><indexterm role="cp"><primary>Temporary files, location of</primary></indexterm>Directory in which temporary files are located.
The cvsnt server uses
<command>TMPDIR</command>.  <xref linkend="Global-options" />, for a
description of how to specify this.
Some parts of cvsnt will always use <command>/tmp</command> (via
the <command>tmpnam</command> function provided by the system).
     </para>

     <para>
On Windows NT, <command>TMP</command> is used (via the <command>_tempnam</command>
function provided by the system).
     </para>

     <para>
The <command>patch</command> program which is used by the cvsnt
client uses <command>TMPDIR</command>, and if it is not set, uses
<command>/tmp</command> (at least with GNU patch 2.1).  Note that
if your server and client are both running cvsnt
1.9.10 or later, cvsnt will not invoke an external
<command>patch</command> program.
     </para></listitem></varlistentry></variablelist>
</appendix>
 <appendix id="Compatibility">
  <title>Compatibility between CVS Versions
</title>

  <para><indexterm role="cp"><primary>CVS, versions of</primary></indexterm><indexterm role="cp"><primary>Versions, of CVS</primary></indexterm><indexterm role="cp"><primary>Compatibility, between CVS versions</primary></indexterm>The repository format is compatible going back to
cvsnt 1.3.  But see <xref linkend="Watches-Compatibility" />, if
you have copies of cvsnt 1.6 or older and you want
to use the optional developer communication features.
  </para>

  <para>
The working directory format is compatible going back
to cvsnt 1.5.  It did change between cvsnt 1.3
and cvsnt 1.5.  If you run cvsnt 1.5 or newer on
a working directory checked out with cvsnt 1.3,
cvsnt will convert it, but to go back to cvsnt
1.3 you need to check out a new working directory with
cvsnt 1.3.
  </para>

  <para>
The remote protocol is interoperable going back to cvsnt 1.5, but no
further (1.5 was the first official release with the remote protocol,
but some older versions might still be floating around).  In many
cases you need to upgrade both the client and the server to take
advantage of new features and bugfixes, however.
  </para>

  <para>
cvsnt is largely compatible with older versions of cvs, however newer
features of cvsnt such as permissions might not be recognised by older
clients.
  </para>

<para><indexterm role="cp"><primary>cygwin, compatibility issues</primary></indexterm>
The Win32 port of CVSNT is a fully native application and does not require cygwin.  It is not recommended that cygwin CVS and CVSNT are installed on the same machine as confusion and incompatibities may arise between versions.  
</para>
<para>
CVSNT obeys the CYGWIN environment variable when deciding where to store extended permissions.  However its default is ntea not ntsec, so this will be needed to be specified if using both environments.  The recommended setting is CYGWIN="ntea nontsec tty" which will force both CYGWIN and CVSNT to use the same permissions structure.
</para>
</appendix>
 <appendix id="Troubleshooting">
  <title>Troubleshooting
</title>

  <para>
If you are having trouble with cvsnt, this appendix
may help.  If there is a particular error message which
you are seeing, then you can look up the message
alphabetically.  If not, you can look through the
section on other problems to see if your problem is
mentioned there.
  </para>

  <sect1 id="Error-messages">
   <title>Partial list of error messages
</title>

   <para>
Here is a partial list of error messages that you may
see from cvsnt.  It is not a complete list--cvsnt
is capable of printing many, many error messages, often
with parts of them supplied by the operating system,
but the intention is to list the common and/or
potentially confusing error messages.
   </para>

   <para>
The messages are alphabetical, but introductory text
such as <command>cvs update: </command> is not considered in
ordering them.
   </para>

   <para>
In some cases the list includes messages printed by old
versions of cvsnt (partly because users may not be
sure which version of cvsnt they are using at any
particular moment).
   </para>

   <variablelist>
    <varlistentry>
     <term><command>cvs <varname>command</varname>: authorization failed: server <varname>host</varname> rejected access</command></term>
     <listitem>
      <para>
This is a generic response when trying to connect to a
pserver server which chooses not to provide a
specific reason for denying authorization.  Check that
the username and password specified are correct and
that the <command>CVSROOT</command> specified is allowed by <command>-allow-root</command>
in <command>inetd.conf</command>.  See <xref linkend="Password-authenticated" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command><varname>file</varname>:<varname>line</varname>: Assertion '<varname>text</varname>' failed</command></term>
     <listitem>
      <para>
The exact format of this message may vary depending on
your system.  It indicates a bug in cvsnt, which can
be handled as described in <xref linkend="BUGS" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs <varname>command</varname>: conflict: removed <varname>file</varname> was modified by second party</command></term>
     <listitem>
      <para>
This message indicates that you removed a file, and
someone else modified it.  To resolve the conflict,
first run <command>cvs add <varname>file</varname></command>.  If desired, look
at the other party's modification to decide whether you
still want to remove it.  If you don't want to remove
it, stop here.  If you do want to remove it, proceed
with <command>cvs remove <varname>file</varname></command> and commit your
removal.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cannot change permissions on temporary directory</command></term>
     <listitem>
      <para><screen>Operation not permitted
</screen>     This message has been happening in a non-reproducible,
occasional way when we run the client/server testsuite,
both on Red Hat Linux 3.0.3 and 4.1.  We haven't been
able to figure out what causes it, nor is it known
whether it is specific to linux (or even to this
particular machine!).  If the problem does occur on
other unices, <command>Operation not permitted</command> would be
likely to read <command>Not owner</command> or whatever the system
in question uses for the unix <command>EPERM</command> error.  If
you have any information to add, please let us know as
described in <xref linkend="BUGS" />.  If you experience this error
while using cvsnt, retrying the operation which
produced it should work fine.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [server aborted]: Cannot check out files into the repository itself</command></term>
     <listitem>
      <para>
The obvious cause for this message (especially for
non-client/server cvsnt) is that the cvsnt root
is, for example, <command>/usr/local/cvsroot</command> and you try
to check out files when you are in a subdirectory, such
as <command>/usr/local/cvsroot/test</command>.  However, there is a
more subtle cause, which is that the temporary
directory on the server is set to a subdirectory of the
root (which is also not allowed).  If this is the
problem, set the temporary directory to somewhere else,
for example <command>/var/tmp</command>; see <command>TMPDIR</command> in
<xref linkend="Environment-variables" />, for how to set the
temporary directory.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cannot open CVS/Entries for reading: No such file or directory</command></term>
     <listitem>
      <para>
This generally indicates a cvsnt internal error, and
can be handled as with other cvsnt bugs
(<xref linkend="BUGS" />).  Usually there is a workaround--the
exact nature of which would depend on the situation but
which hopefully could be figured out.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [init aborted]: cannot open CVS/Root: No such file or directory</command></term>
     <listitem>
      <para>
This message is harmless.  Provided it is not
accompanied by other errors, the operation has
completed successfully.  This message should not occur
with current versions of cvsnt, but it is documented
here for the benefit of cvsnt 1.9 and older.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [checkout aborted]: cannot rename file <varname>file</varname> to CVS/,,<varname>file</varname>: Invalid argument</command></term>
     <listitem>
      <para>
This message has been reported as intermittently
happening with cvsnt 1.9 on Solaris 2.5.  The cause is
unknown; if you know more about what causes it, let us
know as described in <xref linkend="BUGS" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [<varname>command</varname> aborted]: cannot start server via rcmd</command></term>
     <listitem>
      <para>
This, unfortunately, is a rather nonspecific error
message which cvsnt 1.9 will print if you are
running the cvsnt client and it is having trouble
connecting to the server.  Current versions of cvsnt
should print a much more specific error message.  If
you get this message when you didn't mean to run the
client at all, you probably forgot to specify
<command>:local:</command>, as described in <xref linkend="Repository" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>ci: <varname>file</varname>,v: bad diff output line: Binary files - and /tmp/T2a22651 differ</command></term>
     <listitem>
      <para>
cvsnt 1.9 and older will print this message
when trying to check in a binary file if
rcs is not correctly installed.  Re-read the
instructions that came with your rcs distribution
and the install file in the cvsnt
distribution.  Alternately, upgrade to a current
version of cvsnt, which checks in files itself
rather than via rcs.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs checkout: could not check out <varname>file</varname></command></term>
     <listitem>
      <para>
With cvsnt 1.9, this can mean that the <command>co</command> program
(part of rcs) returned a failure.  It should be
preceded by another error message, however it has been
observed without another error message and the cause is
not well-understood.  With the current version of cvsnt,
which does not run <command>co</command>, if this message occurs
without another error message, it is definitely a cvsnt
bug (<xref linkend="BUGS" />).
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [login aborted]: could not find out home directory</command></term>
     <listitem>
      <para>
This means that you need to set the environment
variables that cvsnt uses to locate your home directory.
See the discussion of <command>HOME</command>, <command>HOMEDRIVE</command>, and <command>HOMEPATH</command> in
<xref linkend="Environment-variables" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs update: could not merge revision <varname>rev</varname> of <varname>file</varname>: No such file or directory</command></term>
     <listitem>
      <para>
cvsnt 1.9 and older will print this message if there was
a problem finding the <command>rcsmerge</command> program.  Make
sure that it is in your <command>PATH</command>, or upgrade to a
current version of cvsnt, which does not require
an external <command>rcsmerge</command> program.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [update aborted]: could not patch <varname>file</varname>: No such file or directory</command></term>
     <listitem>
      <para>
This means that there was a problem finding the
<command>patch</command> program.  Make sure that it is in your
<command>PATH</command>.  Note that despite appearances the message
is <emphasis>not</emphasis> referring to whether it can find <varname>file</varname>.
If both the client and the server are running a current
version of cvsnt, then there is no need for an
external patch program and you should not see this
message.  But if either client or server is running
cvsnt 1.9, then you need <command>patch</command>.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs update: could not patch <varname>file</varname>; will refetch</command></term>
     <listitem>
      <para>
This means that for whatever reason the client was
unable to apply a patch that the server sent.  The
message is nothing to be concerned about, because
inability to apply the patch only slows things down and
has no effect on what cvsnt does.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>dying gasps from <varname>server</varname> unexpected</command></term>
     <listitem>
      <para>
There is a known bug in the server for CVS 1.9.18
and older which can cause this.  For me, this was
reproducible if I used the <command>-t</command> global option.  It
was fixed by Andy Piper's 14 Nov 1997 change to
src/filesubr.c, if anyone is curious.
If you see the message,
you probably can just retry the operation which failed,
or if you have discovered information concerning its
cause, please let us know as described in <xref linkend="BUGS" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>end of file from server (consult above messages if any)</command></term>
     <listitem>
      <para>
The most common cause for this message is if you are
using an external <command>rsh</command> program and it exited with
an error.  In this case the <command>rsh</command> program should
have printed a message, which will appear before the
above message.  For more information on setting up a
cvsnt client and server, see <xref linkend="Remote-repositories" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [update aborted]: EOF in key in rcs file <varname>file</varname>,v</command></term>
     <term><command>cvs [checkout aborted]: EOF while looking for end of string in rcs file <varname>file</varname>,v</command></term>
     <listitem>
      <para>
This means that there is a syntax error in the given
rcs file.  Note that this might be true even if rcs can
read the file OK; cvsnt does more error checking of
errors in the rcs file.  That is why you may see this
message when upgrading from CVS 1.9 to CVS
1.10.  The likely cause for the original corruption is
hardware, the operating system, or the like.  Of
course, if you find a case in which cvsnt seems to
corrupting the file, by all means report it,
(<xref linkend="BUGS" />).
There are quite a few variations of this error message,
depending on exactly where in the rcs file cvsnt
finds the syntax error.
      </para>

      <para><indexterm role="cp"><primary>mkmodules</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>cvs commit: Executing 'mkmodules'</command></term>
     <listitem>
      <para>
This means that your repository is set up for a version
of cvsnt prior to cvsnt 1.8.  When using cvsnt
1.8 or later, the above message will be preceded by
      </para>

      <para><screen>
cvs commit: Rebuilding administrative file database
</screen>           </para>

      <para>
If you see both messages, the database is being rebuilt
twice, which is unnecessary but harmless.  If you wish
to avoid the duplication, and you have no versions of
cvsnt 1.7 or earlier in use, remove <command>-i mkmodules</command>
every place it appears in your <command>modules</command>
file.  For more information on the <command>modules</command> file,
see <xref linkend="modules" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>missing author</command></term>
     <listitem>
      <para>
Typically this can happen if you created an rcs file
with your username set to empty.  cvsnt will, bogusly,
create an illegal rcs file with no value for the author
field.  The solution is to make sure your username is
set to a non-empty value and re-create the rcs file.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [checkout aborted]: no such tag <varname>tag</varname></command></term>
     <listitem>
      <para>
This message means that cvsnt isn't familiar with
the tag <varname>tag</varname>.  Usually this means that you have
mistyped a tag name; however there are (relatively
obscure) cases in which cvsnt will require you to
try a few other cvsnt commands involving that tag,
before you find one which will cause cvsnt to update
the <command>val-tags</command> file; see discussion of val-tags in
<xref linkend="File-permissions" />.  You only need to worry about
this once for a given tag; when a tag is listed in
<command>val-tags</command>, it stays there.  Note that using
<command>-f</command> to not require tag matches does not override
this check; see <xref linkend="Common-options" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>*PANIC* administration files missing</command></term>
     <listitem>
      <para>
This typically means that there is a directory named
cvsnt but it does not contain the administrative files
which cvsnt puts in a CVS directory.  If the problem is
that you created a CVS directory via some mechanism
other than cvsnt, then the answer is simple, use a name
other than cvsnt.  If not, it indicates a cvsnt bug
(<xref linkend="BUGS" />).
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>rcs error: Unknown option: -x,v/</command></term>
     <listitem>
      <para>
This message will be followed by a usage message for
rcs.  It means that you have an old version of
rcs (probably supplied with your operating
system), as well as an old version of cvsnt.
CVS 1.9.18 and earlier only work with rcs version 5 and
later; current versions of cvsnt do not run rcs programs.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [server aborted]: received broken pipe signal</command></term>
     <listitem>
      <para>
This message seems to be caused by a hard-to-track-down
bug in cvsnt or the systems it runs on (we don't
know--we haven't tracked it down yet!).  It seems to
happen only after a cvsnt command has completed, and
you should be able to just ignore the message.
However, if you have discovered information concerning its
cause, please let us know as described in <xref linkend="BUGS" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>Too many arguments!</command></term>
     <listitem>
      <para>
This message is typically printed by the <command>log.pl</command>
script which is in the <command>contrib</command> directory in the
cvsnt source distribution.  In some versions of
cvsnt, <command>log.pl</command> has been part of the default
cvsnt installation.  The <command>log.pl</command> script gets
called from the <command>loginfo</command> administrative file.
Check that the arguments passed in <command>loginfo</command> match
what your version of <command>log.pl</command> expects.  In
particular, the <command>log.pl</command> from cvsnt 1.3 and
older expects the logfile as an argument whereas the
<command>log.pl</command> from cvsnt 1.5 and newer expects the
logfile to be specified with a <command>-f</command> option.  Of
course, if you don't need <command>log.pl</command> you can just
comment it out of <command>loginfo</command>.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [update aborted]: unexpected EOF reading <varname>file</varname>,v</command></term>
     <listitem>
      <para>
See <command>EOF in key in rcs file</command>.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs [login aborted]: unrecognized auth response from <varname>server</varname></command></term>
     <listitem>
      <para>
This message typically means that the server is not set
up properly.  For example, if <command>inetd.conf</command> points
to a nonexistent cvs executable.  To debug it further,
find the log file which inetd writes
(<command>/var/log/messages</command> or whatever inetd uses on
your system).  For details, see <xref linkend="Connection" />, and
<xref linkend="Authentication-server" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs server: cannot open /root/.cvsignore: Permission denied</command></term>
     <term><command>cvs [server aborted]: can't chdir(/root): Permission denied</command></term>
     <listitem>
      <para>
See <xref linkend="Connection" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs commit: Up-to-date check failed for `<varname>file</varname>'</command></term>
     <listitem>
      <para>
This means that someone else has committed a change to
that file since the last time that you did a <command>cvs
update</command>.  So before proceeding with your <command>cvs
commit</command> you need to <command>cvs update</command>.  cvsnt will merge
the changes that you made and the changes that the
other person made.  If it does not detect any conflicts
it will report <command>M <varname>file</varname></command> and you are ready
to <command>cvs commit</command>.  If it detects conflicts it will
print a message saying so, will report <command>C <varname>file</varname></command>,
and you need to manually resolve the
conflict.  For more details on this process see
<xref linkend="Conflicts-example" />.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>Usage:	diff3 [-exEX3 [-i | -m] [-L label1 -L label3]] file1 file2 file3</command></term>
     <listitem>
      <para><screen>
Only one of [exEX3] allowed
</screen>     This indicates a problem with the installation of
<command>diff3</command> and <command>rcsmerge</command>.  Specifically
<command>rcsmerge</command> was compiled to look for GNU diff3, but
it is finding unix diff3 instead.  The exact text of
the message will vary depending on the system.  The
simplest solution is to upgrade to a current version of
cvsnt, which does not rely on external
<command>rcsmerge</command> or <command>diff3</command> programs.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>warning: unrecognized response `<varname>text</varname>' from cvs server</command></term>
     <listitem>
      <para>
If <varname>text</varname> contains a valid response (such as
<command>ok</command>) followed by an extra carriage return
character (on many systems this will cause the second
part of the message to overwrite the first part), then
it probably means that you are using the <command>:ext:</command>
access method with a version of rsh, such as most
non-unix rsh versions, which does not by default
provide a transparent data stream.  In such cases you
probably want to try <command>:server:</command> instead of
<command>:ext:</command>.  If <varname>text</varname> is something else, this
may signify a problem with your cvsnt server.
Double-check your installation against the instructions
for setting up the cvsnt server.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs commit: [<varname>time</varname>] waiting for <varname>user</varname>'s lock in <varname>directory</varname></command></term>
     <listitem>
      <para>
This is a normal message, not an error.  See
<xref linkend="Concurrency" />, for more details.
      </para>
</listitem></varlistentry>
    <varlistentry>
     <term><command>cvs commit: warning: editor session failed</command></term>
     <listitem>
      <para><indexterm role="cp"><primary>Exit status, of editor</primary></indexterm>This means that the editor which cvsnt is using exits with a nonzero
exit status.  Some versions of vi will do this even when there was not
a problem editing the file.  If so, point the
<command>CVSEDITOR</command> environment variable to a small script
such as:
      </para>

      <para><screen>
#!/bin/sh
vi $*
exit 0
</screen>           </para>
</listitem></varlistentry></variablelist>

</sect1>
  <sect1 id="Connection">
   <title>Trouble making a connection to a CVS server
</title>

   <para>
This section concerns what to do if you are having
trouble making a connection to a cvsnt server.  If
you are running the cvsnt command line client
running on Windows, first upgrade the client to
cvsnt 1.9.12 or later.  The error reporting in
earlier versions provided much less information about
what the problem was.  If the client is non-Windows,
cvsnt 1.9 should be fine.
   </para>

   <para>
If the error messages are not sufficient to track down
the problem, the next steps depend largely on which
access method you are using.
   </para>

   <variablelist>
    <title><indexterm role="cp"><primary>:ext:, troubleshooting</primary></indexterm></title>
    <varlistentry>
     <term><command>:ext:</command></term>
     <listitem>
      <para>
Try running the ssh program from the command line.  For
example: "ssh servername cvs -v" should print cvsnt
version information.  If this doesn't work, you need to
fix it before you can worry about cvsnt problems.
      </para>

      <para><indexterm role="cp"><primary>:server:, troubleshooting</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>:server:</command></term>
     <listitem>
      <para>
You don't need a command line rsh program to use this
access method, but if you have an rsh program around,
it may be useful as a debugging tool.  Follow the
directions given for :ext:.
      </para>

      <para><indexterm role="cp"><primary>:pserver:, troubleshooting</primary></indexterm>      </para></listitem></varlistentry>
    <varlistentry>
     <term><command>:pserver:</command></term>
     <listitem>
      <para>
Errors along the lines of "connection refused" typically indicate
that inetd isn't even listening for connections on port 2401
whereas errors like "connection reset by peer" or "recv() from
server: EOF" typically indicate that inetd is listening for
connections but is unable to start cvsnt (this is frequently
caused by having an incorrect path in <command>inetd.conf</command>).
"unrecognized auth response" errors are caused by a bad command
line in <command>inetd.conf</command>, typically an invalid option or forgetting
to put the <command>authserver</command> command at the end of the line.
Another less common problem is invisible control characters that
your editor "helpfully" added without you noticing.
      </para>

      <para>
One good debugging tool is to "telnet servername
2401".  After connecting, send any text (for example
"foo" followed by return).  If cvsnt is working
correctly, it will respond with
      </para>

      <para><screen>cvs [authserver aborted]: bad auth protocol start: foo
</screen>           </para>

      <para>
If instead you get:
      </para>

      <para><screen>
Usage: cvs [cvs-options] command [command-options-and-arguments]
...
</screen>           </para>

      <para>
then you're missing the <command>authserver</command> command at the end of the
line in <command>inetd.conf</command>; check to make sure that the entire command
is on one line and that it's complete.
      </para>

      <para>
Likewise, if you get something like:
      </para>

      <para><screen>
Unknown command: `authserver'

CVS commands are:
        add          Add a new file/directory to the repository
...
</screen>           </para>

      <para>
then you've misspelled <command>authserver</command> in some way.  If it isn't
obvious, check for invisible control characters (particularly
carriage returns) in <command>inetd.conf</command>.
      </para>

      <para>
If it fails to work at all, then make sure inetd is working
right.  Change the invocation in <command>inetd.conf</command> to run the
echo program instead of cvs.  For example:
      </para>

      <para><screen>
2401  stream  tcp  nowait  root /bin/echo echo hello
</screen>           </para>

      <para>
After making that change and instructing inetd to
re-read its configuration file, "telnet servername
2401" should show you the text hello and then the
server should close the connection.  If this doesn't
work, you need to fix it before you can worry about
cvsnt problems.
      </para>

      <para>
On AIX systems, the system will often have its own
program trying to use port 2401.  This is AIX's problem
in the sense that port 2401 is registered for use with
cvsnt.  I hear that there is an AIX patch available
to address this problem.
      </para>

      <para>
Another good debugging tool is the <command>-d</command>
(debugging) option to inetd.  Consult your system
documentation for more information.
      </para>

      <para>
If you seem to be connecting but get errors like:
      </para>

      <para><screen>
cvs server: cannot open /root/.cvsignore: Permission denied
cvs [server aborted]: can't chdir(/root): Permission denied
</screen>           </para>

      <para>
then you probably haven't specified <command>-f</command> in <command>inetd.conf</command>.
      </para>

      <para>
If you can connect successfully for a while but then can't,
you've probably hit inetd's rate limit.
(If inetd receives too many requests for the same service
in a short period of time, it assumes that something is wrong
and temporarily disables the service.)
Check your inetd documentation to find out how to adjust the
rate limit (some versions of inetd have a single rate limit,
others allow you to set the limit for each service separately.)
      </para></listitem></varlistentry></variablelist>

</sect1>
  <sect1 id="Other-problems">
   <title>Other common problems
</title>

   <para>
Here is a list of problems which do not fit into the
above categories.  They are in no particular order.
   </para>

   <itemizedlist mark="bullet">
    <listitem>
     <para>
On Windows, if there is a 30 second or so delay when
you run a cvsnt command, it may mean that you have
your home directory set to <command>C:/</command>, for example (see
<command>HOMEDRIVE</command> and <command>HOMEPATH</command> in
<xref linkend="Environment-variables" />).  cvsnt expects the home
directory to not end in a slash, for example <command>C:</command>
or <command>C:\cvs</command>.
     </para>
</listitem>
    <listitem>
     <para>
If you are running CVS 1.9.18 or older, and
<command>cvs update</command> finds a conflict and tries to
merge, as described in <xref linkend="Conflicts-example" />, but
doesn't tell you there were conflicts, then you may
have an old version of rcs.  The easiest solution
probably is to upgrade to a current version of
cvsnt, which does not rely on external rcs
programs.
     </para></listitem></itemizedlist>
</sect1></appendix>
 <appendix id="Credits">
  <title>Credits
</title>

  <para><indexterm role="cp"><primary>Contributors (manual)</primary></indexterm><indexterm role="cp"><primary>Credits (manual)</primary></indexterm>Roland Pesch, then of Cygnus Support &lt;<wordasword>roland@wrs.com</wordasword>&gt;
wrote the manual pages which were distributed with
CVS 1.3.  Much of their text was copied into this
manual.  He also read an early draft
of this manual and contributed many ideas and
corrections.
  </para>

  <para>
The mailing-list <command>info-cvs</command> is sometimes
informative. I have included information from postings
made by the following persons:
David G. Grubbs &lt;<wordasword>dgg@think.com</wordasword>&gt;.
  </para>

  <para>
Some text has been extracted from the man pages for
rcs.
  </para>

  <para>
The cvsnt faq by David G. Grubbs has provided
useful material.  The faq is no longer maintained,
however, and this manual is about the closest thing there
is to a successor (with respect to documenting how to
use cvsnt, at least).
  </para>

  <para>
In addition, the following persons have helped by
telling me about mistakes I've made:
  </para>

  <para><screen>Roxanne Brunskill &lt;<wordasword>rbrunski@datap.ca</wordasword>&gt;,
Kathy Dyer &lt;<wordasword>dyer@phoenix.ocf.llnl.gov</wordasword>&gt;,
Karl Pingle &lt;<wordasword>pingle@acuson.com</wordasword>&gt;,
Thomas A Peterson &lt;<wordasword>tap@src.honeywell.com</wordasword>&gt;,
Inge Wallin &lt;<wordasword>ingwa@signum.se</wordasword>&gt;,
Dirk Koschuetzki &lt;<wordasword>koschuet@fmi.uni-passau.de</wordasword>&gt;
and Michael Brown &lt;<wordasword>brown@wi.extrel.com</wordasword>&gt;.
</screen>  </para>
  <para>
The list of contributors here is not comprehensive; for a more
complete list of who has contributed to this manual see
the file <command>doc/ChangeLog</command> in the cvsnt source
distribution.
  </para>
</appendix>
 <appendix id="BUGS">
  <title>Dealing with bugs in CVS or this manual
</title>

  <para><indexterm role="cp"><primary>Bugs in this manual or CVS</primary></indexterm>Neither cvsnt nor this manual is perfect, and they
probably never will be.  If you are having trouble
using cvsnt, or think you have found a bug, there
are a number of things you can do about it.  Note that
if the manual is unclear, that can be considered a bug
in the manual, so these problems are often worth doing
something about as well as problems with cvsnt itself.
  </para>

  <para><indexterm role="cp"><primary>Reporting bugs</primary></indexterm><indexterm role="cp"><primary>Bugs, reporting</primary></indexterm><indexterm role="cp"><primary>Errors, reporting</primary></indexterm>  </para>
  <itemizedlist mark="bullet">
   <listitem>
    <para>
cvsnt is produced by volunteers.  If you want to help them
to fix any bugs that you report please report as much
information as possible about your system and which version
of cvsnt that you are using.
    </para>
</listitem>
   <listitem>
    <para>
General bug reports for cvsnt should be reported via the
cvsnt mailing list, cvsnt@cvsnt.org.
    </para>
</listitem>
   <listitem>
    <para>
If you got cvsnt through a distributor, such as an
operating system vendor or a vendor of freeware
cd-roms, you may wish to see whether the
distributor provides support.  Often, they will provide
no support or minimal support, but this may vary from
distributor to distributor.
    </para>
</listitem>
   <listitem>
    <para>
If you have the skills and time to do so, you may wish
to fix the bug yourself.  If you wish to submit your
fix for inclusion in future releases of cvsnt.
    </para>
</listitem>
   <listitem>
    <para>
There may be resources on the net which can help.  A
good place to start is:
    </para>

    <para><screen>http://www.cvsnt.org
</screen>         </para>
</listitem></itemizedlist>

</appendix><index id="Index" />
</book>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-indent-step:1
sgml-indent-data:nil
End:
-->
